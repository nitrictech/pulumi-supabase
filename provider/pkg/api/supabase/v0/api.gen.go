// Package v0 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.15.0 DO NOT EDIT.
package v0

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

const (
	BearerScopes = "bearer.Scopes"
)

// Defines values for ColumnPrivilegePrivilegeType.
const (
	ColumnPrivilegePrivilegeTypeALL        ColumnPrivilegePrivilegeType = "ALL"
	ColumnPrivilegePrivilegeTypeINSERT     ColumnPrivilegePrivilegeType = "INSERT"
	ColumnPrivilegePrivilegeTypeREFERENCES ColumnPrivilegePrivilegeType = "REFERENCES"
	ColumnPrivilegePrivilegeTypeSELECT     ColumnPrivilegePrivilegeType = "SELECT"
	ColumnPrivilegePrivilegeTypeUPDATE     ColumnPrivilegePrivilegeType = "UPDATE"
)

// Defines values for CreateColumnBodyDefaultValueFormat.
const (
	CreateColumnBodyDefaultValueFormatExpression CreateColumnBodyDefaultValueFormat = "expression"
	CreateColumnBodyDefaultValueFormatLiteral    CreateColumnBodyDefaultValueFormat = "literal"
)

// Defines values for CreateColumnBodyIdentityGeneration.
const (
	CreateColumnBodyIdentityGenerationALWAYS    CreateColumnBodyIdentityGeneration = "ALWAYS"
	CreateColumnBodyIdentityGenerationBYDEFAULT CreateColumnBodyIdentityGeneration = "BY DEFAULT"
)

// Defines values for CreateContentParamsType.
const (
	CreateContentParamsTypeLogSql CreateContentParamsType = "log_sql"
	CreateContentParamsTypeReport CreateContentParamsType = "report"
	CreateContentParamsTypeSql    CreateContentParamsType = "sql"
)

// Defines values for CreateContentParamsVisibility.
const (
	CreateContentParamsVisibilityOrg     CreateContentParamsVisibility = "org"
	CreateContentParamsVisibilityProject CreateContentParamsVisibility = "project"
	CreateContentParamsVisibilityPublic  CreateContentParamsVisibility = "public"
	CreateContentParamsVisibilityUser    CreateContentParamsVisibility = "user"
)

// Defines values for CreateFunctionBodyBehavior.
const (
	CreateFunctionBodyBehaviorIMMUTABLE CreateFunctionBodyBehavior = "IMMUTABLE"
	CreateFunctionBodyBehaviorSTABLE    CreateFunctionBodyBehavior = "STABLE"
	CreateFunctionBodyBehaviorVOLATILE  CreateFunctionBodyBehavior = "VOLATILE"
)

// Defines values for CreateOrganizationBodyV2Tier.
const (
	TierEnterprise CreateOrganizationBodyV2Tier = "tier_enterprise"
	TierFree       CreateOrganizationBodyV2Tier = "tier_free"
	TierPayg       CreateOrganizationBodyV2Tier = "tier_payg"
	TierPro        CreateOrganizationBodyV2Tier = "tier_pro"
	TierTeam       CreateOrganizationBodyV2Tier = "tier_team"
)

// Defines values for CreatePolicyBodyAction.
const (
	CreatePolicyBodyActionPERMISSIVE  CreatePolicyBodyAction = "PERMISSIVE"
	CreatePolicyBodyActionRESTRICTIVE CreatePolicyBodyAction = "RESTRICTIVE"
)

// Defines values for CreatePolicyBodyCommand.
const (
	CreatePolicyBodyCommandALL    CreatePolicyBodyCommand = "ALL"
	CreatePolicyBodyCommandDELETE CreatePolicyBodyCommand = "DELETE"
	CreatePolicyBodyCommandINSERT CreatePolicyBodyCommand = "INSERT"
	CreatePolicyBodyCommandSELECT CreatePolicyBodyCommand = "SELECT"
	CreatePolicyBodyCommandUPDATE CreatePolicyBodyCommand = "UPDATE"
)

// Defines values for CreateTriggerBodyActivation.
const (
	CreateTriggerBodyActivationAFTER  CreateTriggerBodyActivation = "AFTER"
	CreateTriggerBodyActivationBEFORE CreateTriggerBodyActivation = "BEFORE"
)

// Defines values for CreateTriggerBodyEnabledMode.
const (
	CreateTriggerBodyEnabledModeALWAYS   CreateTriggerBodyEnabledMode = "ALWAYS"
	CreateTriggerBodyEnabledModeDISABLED CreateTriggerBodyEnabledMode = "DISABLED"
	CreateTriggerBodyEnabledModeORIGIN   CreateTriggerBodyEnabledMode = "ORIGIN"
	CreateTriggerBodyEnabledModeREPLICA  CreateTriggerBodyEnabledMode = "REPLICA"
)

// Defines values for CreateTriggerBodyEvents.
const (
	CreateTriggerBodyEventsDELETE CreateTriggerBodyEvents = "DELETE"
	CreateTriggerBodyEventsINSERT CreateTriggerBodyEvents = "INSERT"
	CreateTriggerBodyEventsUPDATE CreateTriggerBodyEvents = "UPDATE"
)

// Defines values for CreateTriggerBodyOrientation.
const (
	CreateTriggerBodyOrientationROW       CreateTriggerBodyOrientation = "ROW"
	CreateTriggerBodyOrientationSTATEMENT CreateTriggerBodyOrientation = "STATEMENT"
)

// Defines values for GetMetricsBodyInterval.
const (
	GetMetricsBodyIntervalN1d GetMetricsBodyInterval = "1d"
	GetMetricsBodyIntervalN3d GetMetricsBodyInterval = "3d"
	GetMetricsBodyIntervalN7d GetMetricsBodyInterval = "7d"
)

// Defines values for GetMetricsBodyMetric.
const (
	UserQueries GetMetricsBodyMetric = "user_queries"
)

// Defines values for GrantColumnPrivilegesBodyPrivilegeType.
const (
	GrantColumnPrivilegesBodyPrivilegeTypeALL        GrantColumnPrivilegesBodyPrivilegeType = "ALL"
	GrantColumnPrivilegesBodyPrivilegeTypeINSERT     GrantColumnPrivilegesBodyPrivilegeType = "INSERT"
	GrantColumnPrivilegesBodyPrivilegeTypeREFERENCES GrantColumnPrivilegesBodyPrivilegeType = "REFERENCES"
	GrantColumnPrivilegesBodyPrivilegeTypeSELECT     GrantColumnPrivilegesBodyPrivilegeType = "SELECT"
	GrantColumnPrivilegesBodyPrivilegeTypeUPDATE     GrantColumnPrivilegesBodyPrivilegeType = "UPDATE"
)

// Defines values for GrantTablePrivilegesBodyPrivilegeType.
const (
	GrantTablePrivilegesBodyPrivilegeTypeALL        GrantTablePrivilegesBodyPrivilegeType = "ALL"
	GrantTablePrivilegesBodyPrivilegeTypeDELETE     GrantTablePrivilegesBodyPrivilegeType = "DELETE"
	GrantTablePrivilegesBodyPrivilegeTypeINSERT     GrantTablePrivilegesBodyPrivilegeType = "INSERT"
	GrantTablePrivilegesBodyPrivilegeTypeREFERENCES GrantTablePrivilegesBodyPrivilegeType = "REFERENCES"
	GrantTablePrivilegesBodyPrivilegeTypeSELECT     GrantTablePrivilegesBodyPrivilegeType = "SELECT"
	GrantTablePrivilegesBodyPrivilegeTypeTRIGGER    GrantTablePrivilegesBodyPrivilegeType = "TRIGGER"
	GrantTablePrivilegesBodyPrivilegeTypeTRUNCATE   GrantTablePrivilegesBodyPrivilegeType = "TRUNCATE"
	GrantTablePrivilegesBodyPrivilegeTypeUPDATE     GrantTablePrivilegesBodyPrivilegeType = "UPDATE"
)

// Defines values for PgbouncerConfigResponsePgbouncerStatus.
const (
	PgbouncerConfigResponsePgbouncerStatusCOMINGDOWN PgbouncerConfigResponsePgbouncerStatus = "COMING_DOWN"
	PgbouncerConfigResponsePgbouncerStatusCOMINGUP   PgbouncerConfigResponsePgbouncerStatus = "COMING_UP"
	PgbouncerConfigResponsePgbouncerStatusDISABLED   PgbouncerConfigResponsePgbouncerStatus = "DISABLED"
	PgbouncerConfigResponsePgbouncerStatusENABLED    PgbouncerConfigResponsePgbouncerStatus = "ENABLED"
	PgbouncerConfigResponsePgbouncerStatusRELOADING  PgbouncerConfigResponsePgbouncerStatus = "RELOADING"
)

// Defines values for PgbouncerConfigResponsePoolMode.
const (
	PgbouncerConfigResponsePoolModeSession     PgbouncerConfigResponsePoolMode = "session"
	PgbouncerConfigResponsePoolModeStatement   PgbouncerConfigResponsePoolMode = "statement"
	PgbouncerConfigResponsePoolModeTransaction PgbouncerConfigResponsePoolMode = "transaction"
)

// Defines values for PostgresConfigResponseSessionReplicationRole.
const (
	PostgresConfigResponseSessionReplicationRoleLocal   PostgresConfigResponseSessionReplicationRole = "local"
	PostgresConfigResponseSessionReplicationRoleOrigin  PostgresConfigResponseSessionReplicationRole = "origin"
	PostgresConfigResponseSessionReplicationRoleReplica PostgresConfigResponseSessionReplicationRole = "replica"
)

// Defines values for PostgresFunctionBehavior.
const (
	PostgresFunctionBehaviorIMMUTABLE PostgresFunctionBehavior = "IMMUTABLE"
	PostgresFunctionBehaviorSTABLE    PostgresFunctionBehavior = "STABLE"
	PostgresFunctionBehaviorVOLATILE  PostgresFunctionBehavior = "VOLATILE"
)

// Defines values for PostgresPolicyAction.
const (
	PostgresPolicyActionPERMISSIVE  PostgresPolicyAction = "PERMISSIVE"
	PostgresPolicyActionRESTRICTIVE PostgresPolicyAction = "RESTRICTIVE"
)

// Defines values for PostgresPolicyCommand.
const (
	PostgresPolicyCommandALL    PostgresPolicyCommand = "ALL"
	PostgresPolicyCommandDELETE PostgresPolicyCommand = "DELETE"
	PostgresPolicyCommandINSERT PostgresPolicyCommand = "INSERT"
	PostgresPolicyCommandSELECT PostgresPolicyCommand = "SELECT"
	PostgresPolicyCommandUPDATE PostgresPolicyCommand = "UPDATE"
)

// Defines values for PostgresTableReplicaIdentity.
const (
	PostgresTableReplicaIdentityDEFAULT PostgresTableReplicaIdentity = "DEFAULT"
	PostgresTableReplicaIdentityFULL    PostgresTableReplicaIdentity = "FULL"
	PostgresTableReplicaIdentityINDEX   PostgresTableReplicaIdentity = "INDEX"
	PostgresTableReplicaIdentityNOTHING PostgresTableReplicaIdentity = "NOTHING"
)

// Defines values for PostgresTriggerActivation.
const (
	PostgresTriggerActivationAFTER  PostgresTriggerActivation = "AFTER"
	PostgresTriggerActivationBEFORE PostgresTriggerActivation = "BEFORE"
)

// Defines values for PostgresTriggerEnabledMode.
const (
	PostgresTriggerEnabledModeALWAYS   PostgresTriggerEnabledMode = "ALWAYS"
	PostgresTriggerEnabledModeDISABLED PostgresTriggerEnabledMode = "DISABLED"
	PostgresTriggerEnabledModeORIGIN   PostgresTriggerEnabledMode = "ORIGIN"
	PostgresTriggerEnabledModeREPLICA  PostgresTriggerEnabledMode = "REPLICA"
)

// Defines values for PostgresTriggerOrientation.
const (
	PostgresTriggerOrientationROW       PostgresTriggerOrientation = "ROW"
	PostgresTriggerOrientationSTATEMENT PostgresTriggerOrientation = "STATEMENT"
)

// Defines values for ProjectDetailResponseStatus.
const (
	ProjectDetailResponseStatusACTIVEHEALTHY   ProjectDetailResponseStatus = "ACTIVE_HEALTHY"
	ProjectDetailResponseStatusACTIVEUNHEALTHY ProjectDetailResponseStatus = "ACTIVE_UNHEALTHY"
	ProjectDetailResponseStatusCOMINGUP        ProjectDetailResponseStatus = "COMING_UP"
	ProjectDetailResponseStatusGOINGDOWN       ProjectDetailResponseStatus = "GOING_DOWN"
	ProjectDetailResponseStatusINACTIVE        ProjectDetailResponseStatus = "INACTIVE"
	ProjectDetailResponseStatusINITFAILED      ProjectDetailResponseStatus = "INIT_FAILED"
	ProjectDetailResponseStatusREMOVED         ProjectDetailResponseStatus = "REMOVED"
	ProjectDetailResponseStatusRESTORING       ProjectDetailResponseStatus = "RESTORING"
	ProjectDetailResponseStatusUNKNOWN         ProjectDetailResponseStatus = "UNKNOWN"
	ProjectDetailResponseStatusUPGRADING       ProjectDetailResponseStatus = "UPGRADING"
)

// Defines values for RestartServiceRequestServices.
const (
	Adminapi     RestartServiceRequestServices = "adminapi"
	ApiGateway   RestartServiceRequestServices = "api-gateway"
	Autoshutdown RestartServiceRequestServices = "autoshutdown"
	Functions    RestartServiceRequestServices = "functions"
	Gotrue       RestartServiceRequestServices = "gotrue"
	Kong         RestartServiceRequestServices = "kong"
	Pgbouncer    RestartServiceRequestServices = "pgbouncer"
	Pgsodium     RestartServiceRequestServices = "pgsodium"
	Postgresql   RestartServiceRequestServices = "postgresql"
	Postgrest    RestartServiceRequestServices = "postgrest"
	Realtime     RestartServiceRequestServices = "realtime"
	Storage      RestartServiceRequestServices = "storage"
	Walg         RestartServiceRequestServices = "walg"
)

// Defines values for RevokeColumnPrivilegesBodyPrivilegeType.
const (
	RevokeColumnPrivilegesBodyPrivilegeTypeALL        RevokeColumnPrivilegesBodyPrivilegeType = "ALL"
	RevokeColumnPrivilegesBodyPrivilegeTypeINSERT     RevokeColumnPrivilegesBodyPrivilegeType = "INSERT"
	RevokeColumnPrivilegesBodyPrivilegeTypeREFERENCES RevokeColumnPrivilegesBodyPrivilegeType = "REFERENCES"
	RevokeColumnPrivilegesBodyPrivilegeTypeSELECT     RevokeColumnPrivilegesBodyPrivilegeType = "SELECT"
	RevokeColumnPrivilegesBodyPrivilegeTypeUPDATE     RevokeColumnPrivilegesBodyPrivilegeType = "UPDATE"
)

// Defines values for RevokeTablePrivilegesBodyPrivilegeType.
const (
	RevokeTablePrivilegesBodyPrivilegeTypeALL        RevokeTablePrivilegesBodyPrivilegeType = "ALL"
	RevokeTablePrivilegesBodyPrivilegeTypeDELETE     RevokeTablePrivilegesBodyPrivilegeType = "DELETE"
	RevokeTablePrivilegesBodyPrivilegeTypeINSERT     RevokeTablePrivilegesBodyPrivilegeType = "INSERT"
	RevokeTablePrivilegesBodyPrivilegeTypeREFERENCES RevokeTablePrivilegesBodyPrivilegeType = "REFERENCES"
	RevokeTablePrivilegesBodyPrivilegeTypeSELECT     RevokeTablePrivilegesBodyPrivilegeType = "SELECT"
	RevokeTablePrivilegesBodyPrivilegeTypeTRIGGER    RevokeTablePrivilegesBodyPrivilegeType = "TRIGGER"
	RevokeTablePrivilegesBodyPrivilegeTypeTRUNCATE   RevokeTablePrivilegesBodyPrivilegeType = "TRUNCATE"
	RevokeTablePrivilegesBodyPrivilegeTypeUPDATE     RevokeTablePrivilegesBodyPrivilegeType = "UPDATE"
)

// Defines values for StorageObjectTransformOptionsFormat.
const (
	StorageObjectTransformOptionsFormatOrigin StorageObjectTransformOptionsFormat = "origin"
)

// Defines values for StorageObjectTransformOptionsResize.
const (
	Contain StorageObjectTransformOptionsResize = "contain"
	Cover   StorageObjectTransformOptionsResize = "cover"
	Fill    StorageObjectTransformOptionsResize = "fill"
)

// Defines values for TablePrivilegePrivilegeType.
const (
	TablePrivilegePrivilegeTypeALL        TablePrivilegePrivilegeType = "ALL"
	TablePrivilegePrivilegeTypeDELETE     TablePrivilegePrivilegeType = "DELETE"
	TablePrivilegePrivilegeTypeINSERT     TablePrivilegePrivilegeType = "INSERT"
	TablePrivilegePrivilegeTypeREFERENCES TablePrivilegePrivilegeType = "REFERENCES"
	TablePrivilegePrivilegeTypeSELECT     TablePrivilegePrivilegeType = "SELECT"
	TablePrivilegePrivilegeTypeTRIGGER    TablePrivilegePrivilegeType = "TRIGGER"
	TablePrivilegePrivilegeTypeTRUNCATE   TablePrivilegePrivilegeType = "TRUNCATE"
	TablePrivilegePrivilegeTypeUPDATE     TablePrivilegePrivilegeType = "UPDATE"
)

// Defines values for UpdateColumnBodyDefaultValueFormat.
const (
	UpdateColumnBodyDefaultValueFormatExpression UpdateColumnBodyDefaultValueFormat = "expression"
	UpdateColumnBodyDefaultValueFormatLiteral    UpdateColumnBodyDefaultValueFormat = "literal"
)

// Defines values for UpdateColumnBodyIdentityGeneration.
const (
	UpdateColumnBodyIdentityGenerationALWAYS    UpdateColumnBodyIdentityGeneration = "ALWAYS"
	UpdateColumnBodyIdentityGenerationBYDEFAULT UpdateColumnBodyIdentityGeneration = "BY DEFAULT"
)

// Defines values for UpdateContentParamsType.
const (
	UpdateContentParamsTypeLogSql UpdateContentParamsType = "log_sql"
	UpdateContentParamsTypeReport UpdateContentParamsType = "report"
	UpdateContentParamsTypeSql    UpdateContentParamsType = "sql"
)

// Defines values for UpdateContentParamsVisibility.
const (
	UpdateContentParamsVisibilityOrg     UpdateContentParamsVisibility = "org"
	UpdateContentParamsVisibilityProject UpdateContentParamsVisibility = "project"
	UpdateContentParamsVisibilityPublic  UpdateContentParamsVisibility = "public"
	UpdateContentParamsVisibilityUser    UpdateContentParamsVisibility = "user"
)

// Defines values for UpdateFunctionBodyBehavior.
const (
	IMMUTABLE UpdateFunctionBodyBehavior = "IMMUTABLE"
	STABLE    UpdateFunctionBodyBehavior = "STABLE"
	VOLATILE  UpdateFunctionBodyBehavior = "VOLATILE"
)

// Defines values for UpdatePgbouncerConfigBodyPoolMode.
const (
	UpdatePgbouncerConfigBodyPoolModeSession     UpdatePgbouncerConfigBodyPoolMode = "session"
	UpdatePgbouncerConfigBodyPoolModeStatement   UpdatePgbouncerConfigBodyPoolMode = "statement"
	UpdatePgbouncerConfigBodyPoolModeTransaction UpdatePgbouncerConfigBodyPoolMode = "transaction"
)

// Defines values for UpdatePoolingConfigResponsePgbouncerStatus.
const (
	UpdatePoolingConfigResponsePgbouncerStatusCOMINGDOWN UpdatePoolingConfigResponsePgbouncerStatus = "COMING_DOWN"
	UpdatePoolingConfigResponsePgbouncerStatusCOMINGUP   UpdatePoolingConfigResponsePgbouncerStatus = "COMING_UP"
	UpdatePoolingConfigResponsePgbouncerStatusDISABLED   UpdatePoolingConfigResponsePgbouncerStatus = "DISABLED"
	UpdatePoolingConfigResponsePgbouncerStatusENABLED    UpdatePoolingConfigResponsePgbouncerStatus = "ENABLED"
	UpdatePoolingConfigResponsePgbouncerStatusRELOADING  UpdatePoolingConfigResponsePgbouncerStatus = "RELOADING"
)

// Defines values for UpdatePoolingConfigResponsePoolMode.
const (
	Session     UpdatePoolingConfigResponsePoolMode = "session"
	Statement   UpdatePoolingConfigResponsePoolMode = "statement"
	Transaction UpdatePoolingConfigResponsePoolMode = "transaction"
)

// Defines values for UpdatePostgresConfigBodySessionReplicationRole.
const (
	Local   UpdatePostgresConfigBodySessionReplicationRole = "local"
	Origin  UpdatePostgresConfigBodySessionReplicationRole = "origin"
	Replica UpdatePostgresConfigBodySessionReplicationRole = "replica"
)

// Defines values for UpdateTableBodyReplicaIdentity.
const (
	UpdateTableBodyReplicaIdentityDEFAULT UpdateTableBodyReplicaIdentity = "DEFAULT"
	UpdateTableBodyReplicaIdentityFULL    UpdateTableBodyReplicaIdentity = "FULL"
	UpdateTableBodyReplicaIdentityINDEX   UpdateTableBodyReplicaIdentity = "INDEX"
	UpdateTableBodyReplicaIdentityNOTHING UpdateTableBodyReplicaIdentity = "NOTHING"
)

// Defines values for UpdateTriggerBodyActivation.
const (
	AFTER  UpdateTriggerBodyActivation = "AFTER"
	BEFORE UpdateTriggerBodyActivation = "BEFORE"
)

// Defines values for UpdateTriggerBodyEnabledMode.
const (
	UpdateTriggerBodyEnabledModeALWAYS   UpdateTriggerBodyEnabledMode = "ALWAYS"
	UpdateTriggerBodyEnabledModeDISABLED UpdateTriggerBodyEnabledMode = "DISABLED"
	UpdateTriggerBodyEnabledModeORIGIN   UpdateTriggerBodyEnabledMode = "ORIGIN"
	UpdateTriggerBodyEnabledModeREPLICA  UpdateTriggerBodyEnabledMode = "REPLICA"
)

// Defines values for UpdateTriggerBodyEvents.
const (
	UpdateTriggerBodyEventsDELETE UpdateTriggerBodyEvents = "DELETE"
	UpdateTriggerBodyEventsINSERT UpdateTriggerBodyEvents = "INSERT"
	UpdateTriggerBodyEventsUPDATE UpdateTriggerBodyEvents = "UPDATE"
)

// Defines values for UpdateTriggerBodyOrientation.
const (
	ROW       UpdateTriggerBodyOrientation = "ROW"
	STATEMENT UpdateTriggerBodyOrientation = "STATEMENT"
)

// Defines values for UpsertContentParamsType.
const (
	LogSql UpsertContentParamsType = "log_sql"
	Report UpsertContentParamsType = "report"
	Sql    UpsertContentParamsType = "sql"
)

// Defines values for UpsertContentParamsVisibility.
const (
	Org     UpsertContentParamsVisibility = "org"
	Project UpsertContentParamsVisibility = "project"
	Public  UpsertContentParamsVisibility = "public"
	User    UpsertContentParamsVisibility = "user"
)

// Defines values for GetTemplateParamsTemplate.
const (
	GetTemplateParamsTemplateConfirmation GetTemplateParamsTemplate = "confirmation"
	GetTemplateParamsTemplateEmailChange  GetTemplateParamsTemplate = "email-change"
	GetTemplateParamsTemplateInvite       GetTemplateParamsTemplate = "invite"
	GetTemplateParamsTemplateMagicLink    GetTemplateParamsTemplate = "magic-link"
	GetTemplateParamsTemplateRecovery     GetTemplateParamsTemplate = "recovery"
)

// Defines values for GetFunctionStatusParamsInterval.
const (
	N15min GetFunctionStatusParamsInterval = "15min"
	N1day  GetFunctionStatusParamsInterval = "1day"
	N1hr   GetFunctionStatusParamsInterval = "1hr"
	N5min  GetFunctionStatusParamsInterval = "5min"
	N7day  GetFunctionStatusParamsInterval = "7day"
)

// Defines values for GetApiCountsParamsInterval.
const (
	Daily    GetApiCountsParamsInterval = "daily"
	Hourly   GetApiCountsParamsInterval = "hourly"
	Minutely GetApiCountsParamsInterval = "minutely"
)

// Defines values for GetUsageMetricsParamsAttribute.
const (
	AvgCpuUsage       GetUsageMetricsParamsAttribute = "avg_cpu_usage"
	CpuUsage          GetUsageMetricsParamsAttribute = "cpu_usage"
	DiskIoBudget      GetUsageMetricsParamsAttribute = "disk_io_budget"
	DiskIoConsumption GetUsageMetricsParamsAttribute = "disk_io_consumption"
	MaxCpuUsage       GetUsageMetricsParamsAttribute = "max_cpu_usage"
	RamUsage          GetUsageMetricsParamsAttribute = "ram_usage"
	SwapUsage         GetUsageMetricsParamsAttribute = "swap_usage"
)

// Defines values for GetUsageMetricsParamsInterval.
const (
	GetUsageMetricsParamsIntervalN10m GetUsageMetricsParamsInterval = "10m"
	GetUsageMetricsParamsIntervalN1d  GetUsageMetricsParamsInterval = "1d"
	GetUsageMetricsParamsIntervalN1h  GetUsageMetricsParamsInterval = "1h"
	GetUsageMetricsParamsIntervalN1m  GetUsageMetricsParamsInterval = "1m"
	GetUsageMetricsParamsIntervalN30m GetUsageMetricsParamsInterval = "30m"
	GetUsageMetricsParamsIntervalN5m  GetUsageMetricsParamsInterval = "5m"
)

// AmiSearchOptions defines model for AmiSearchOptions.
type AmiSearchOptions struct {
	SearchTags *map[string]interface{} `json:"search_tags,omitempty"`
}

// AnalyticsResponse defines model for AnalyticsResponse.
type AnalyticsResponse struct {
	Error  *AnalyticsResponse_Error  `json:"error,omitempty"`
	Result *[]map[string]interface{} `json:"result,omitempty"`
}

// AnalyticsResponseError0 defines model for .
type AnalyticsResponseError0 struct {
	Code   *float32 `json:"code,omitempty"`
	Errors *[]struct {
		Domain       *string `json:"domain,omitempty"`
		Location     *string `json:"location,omitempty"`
		LocationType *string `json:"locationType,omitempty"`
		Message      *string `json:"message,omitempty"`
		Reason       *string `json:"reason,omitempty"`
	} `json:"errors,omitempty"`
	Message *string `json:"message,omitempty"`
	Status  *string `json:"status,omitempty"`
}

// AnalyticsResponseError1 defines model for .
type AnalyticsResponseError1 = string

// AnalyticsResponse_Error defines model for AnalyticsResponse.Error.
type AnalyticsResponse_Error struct {
	union json.RawMessage
}

// Backup defines model for Backup.
type Backup struct {
	Id               float32                `json:"id"`
	InsertedAt       string                 `json:"inserted_at"`
	IsPhysicalBackup bool                   `json:"isPhysicalBackup"`
	ProjectId        float32                `json:"project_id"`
	Status           map[string]interface{} `json:"status"`
}

// BackupId defines model for BackupId.
type BackupId struct {
	Id float32 `json:"id"`
}

// BackupsResponse defines model for BackupsResponse.
type BackupsResponse struct {
	Backups            []Backup `json:"backups"`
	PhysicalBackupData struct {
		EarliestPhysicalBackupDateUnix *float32 `json:"earliestPhysicalBackupDateUnix,omitempty"`
		LatestPhysicalBackupDateUnix   *float32 `json:"latestPhysicalBackupDateUnix,omitempty"`
	} `json:"physicalBackupData"`
	PitrEnabled bool   `json:"pitr_enabled"`
	Region      string `json:"region"`
	TierId      string `json:"tierId"`
	TierKey     string `json:"tierKey"`
	WalgEnabled bool   `json:"walg_enabled"`
}

// Buffer defines model for Buffer.
type Buffer = map[string]interface{}

// Column defines model for Column.
type Column struct {
	Id      float32 `json:"id"`
	Name    string  `json:"name"`
	Schema  string  `json:"schema"`
	Table   string  `json:"table"`
	TableId float32 `json:"table_id"`
}

// ColumnPrivilege defines model for ColumnPrivilege.
type ColumnPrivilege struct {
	Grantee       string                       `json:"grantee"`
	Grantor       string                       `json:"grantor"`
	IsGrantable   bool                         `json:"is_grantable"`
	PrivilegeType ColumnPrivilegePrivilegeType `json:"privilege_type"`
}

// ColumnPrivilegePrivilegeType defines model for ColumnPrivilege.PrivilegeType.
type ColumnPrivilegePrivilegeType string

// CopyObjectBody defines model for CopyObjectBody.
type CopyObjectBody struct {
	From string `json:"from"`
	To   string `json:"to"`
}

// CopyObjectResponse defines model for CopyObjectResponse.
type CopyObjectResponse struct {
	Path string `json:"path"`
}

// CreateColumnBody defines model for CreateColumnBody.
type CreateColumnBody struct {
	Check              *string                             `json:"check,omitempty"`
	Comment            *string                             `json:"comment,omitempty"`
	DefaultValue       *map[string]interface{}             `json:"defaultValue,omitempty"`
	DefaultValueFormat *CreateColumnBodyDefaultValueFormat `json:"defaultValueFormat,omitempty"`
	IdentityGeneration *CreateColumnBodyIdentityGeneration `json:"identityGeneration,omitempty"`
	IsIdentity         *bool                               `json:"isIdentity,omitempty"`
	IsNullable         *bool                               `json:"isNullable,omitempty"`
	IsPrimaryKey       *bool                               `json:"isPrimaryKey,omitempty"`
	IsUnique           *bool                               `json:"isUnique,omitempty"`
	Name               string                              `json:"name"`
	TableId            float32                             `json:"tableId"`
	Type               string                              `json:"type"`
}

// CreateColumnBodyDefaultValueFormat defines model for CreateColumnBody.DefaultValueFormat.
type CreateColumnBodyDefaultValueFormat string

// CreateColumnBodyIdentityGeneration defines model for CreateColumnBody.IdentityGeneration.
type CreateColumnBodyIdentityGeneration string

// CreateContentParams defines model for CreateContentParams.
type CreateContentParams struct {
	Content     *map[string]interface{}       `json:"content,omitempty"`
	Description string                        `json:"description"`
	Id          string                        `json:"id"`
	Name        string                        `json:"name"`
	OwnerId     *float32                      `json:"owner_id,omitempty"`
	Type        CreateContentParamsType       `json:"type"`
	Visibility  CreateContentParamsVisibility `json:"visibility"`
}

// CreateContentParamsType defines model for CreateContentParams.Type.
type CreateContentParamsType string

// CreateContentParamsVisibility defines model for CreateContentParams.Visibility.
type CreateContentParamsVisibility string

// CreateExtensionBody defines model for CreateExtensionBody.
type CreateExtensionBody struct {
	Cascade bool   `json:"cascade"`
	Name    string `json:"name"`
	Schema  string `json:"schema"`
	Version string `json:"version"`
}

// CreateFunctionBody defines model for CreateFunctionBody.
type CreateFunctionBody struct {
	Args            []string                   `json:"args"`
	Behavior        CreateFunctionBodyBehavior `json:"behavior"`
	ConfigParams    *map[string]interface{}    `json:"config_params,omitempty"`
	Definition      string                     `json:"definition"`
	Language        string                     `json:"language"`
	Name            string                     `json:"name"`
	ReturnType      string                     `json:"return_type"`
	Schema          string                     `json:"schema"`
	SecurityDefiner bool                       `json:"security_definer"`
}

// CreateFunctionBodyBehavior defines model for CreateFunctionBody.Behavior.
type CreateFunctionBodyBehavior string

// CreateOrganizationBodyV2 defines model for CreateOrganizationBodyV2.
type CreateOrganizationBodyV2 struct {
	Kind          *string                      `json:"kind,omitempty"`
	Name          string                       `json:"name"`
	PaymentMethod *string                      `json:"payment_method,omitempty"`
	Size          *string                      `json:"size,omitempty"`
	Tier          CreateOrganizationBodyV2Tier `json:"tier"`
}

// CreateOrganizationBodyV2Tier defines model for CreateOrganizationBodyV2.Tier.
type CreateOrganizationBodyV2Tier string

// CreatePolicyBody defines model for CreatePolicyBody.
type CreatePolicyBody struct {
	Action     *CreatePolicyBodyAction  `json:"action,omitempty"`
	Check      *string                  `json:"check,omitempty"`
	Command    *CreatePolicyBodyCommand `json:"command,omitempty"`
	Definition *string                  `json:"definition,omitempty"`
	Name       string                   `json:"name"`
	Roles      *[]string                `json:"roles,omitempty"`
	Schema     *string                  `json:"schema,omitempty"`
	Table      string                   `json:"table"`
}

// CreatePolicyBodyAction defines model for CreatePolicyBody.Action.
type CreatePolicyBodyAction string

// CreatePolicyBodyCommand defines model for CreatePolicyBody.Command.
type CreatePolicyBodyCommand string

// CreateProjectBody defines model for CreateProjectBody.
type CreateProjectBody struct {
	AuthSiteUrl                    *string                        `json:"auth_site_url,omitempty"`
	CloudProvider                  string                         `json:"cloud_provider"`
	CustomSupabaseInternalRequests CustomSupabaseInternalRequests `json:"custom_supabase_internal_requests"`
	DbPass                         string                         `json:"db_pass"`
	DbPricingTierId                string                         `json:"db_pricing_tier_id"`
	DbRegion                       string                         `json:"db_region"`
	DbSql                          *string                        `json:"db_sql,omitempty"`
	KpsEnabled                     *bool                          `json:"kps_enabled,omitempty"`
	Name                           string                         `json:"name"`
	OrgId                          float32                        `json:"org_id"`
	VercelConfigurationId          *string                        `json:"vercel_configuration_id,omitempty"`
}

// CreateProjectResponse defines model for CreateProjectResponse.
type CreateProjectResponse struct {
	AnonKey               string   `json:"anon_key"`
	CloudProvider         string   `json:"cloud_provider"`
	Endpoint              string   `json:"endpoint"`
	Id                    float32  `json:"id"`
	InsertedAt            string   `json:"inserted_at"`
	IsBranchEnabled       bool     `json:"is_branch_enabled"`
	IsReadonlyModeEnabled *bool    `json:"is_readonly_mode_enabled,omitempty"`
	Name                  string   `json:"name"`
	OrganizationId        float32  `json:"organization_id"`
	PreviewBranchRefs     []string `json:"preview_branch_refs"`
	Ref                   string   `json:"ref"`
	Region                string   `json:"region"`
	ServiceKey            string   `json:"service_key"`
	Status                string   `json:"status"`
	SubscriptionId        string   `json:"subscription_id"`
}

// CreatePublicationBody defines model for CreatePublicationBody.
type CreatePublicationBody struct {
	Name            string    `json:"name"`
	Owner           *string   `json:"owner,omitempty"`
	PublishDelete   *bool     `json:"publish_delete,omitempty"`
	PublishInsert   *bool     `json:"publish_insert,omitempty"`
	PublishTruncate *bool     `json:"publish_truncate,omitempty"`
	PublishUpdate   *bool     `json:"publish_update,omitempty"`
	Tables          *[]string `json:"tables"`
}

// CreateRoleBody defines model for CreateRoleBody.
type CreateRoleBody struct {
	Admins            *[]string               `json:"admins,omitempty"`
	CanBypassRls      *bool                   `json:"can_bypass_rls,omitempty"`
	CanCreateDb       *bool                   `json:"can_create_db,omitempty"`
	CanCreateRole     *bool                   `json:"can_create_role,omitempty"`
	CanLogin          *bool                   `json:"can_login,omitempty"`
	Config            *map[string]interface{} `json:"config,omitempty"`
	ConnectionLimit   *float32                `json:"connection_limit,omitempty"`
	InheritRole       *bool                   `json:"inherit_role,omitempty"`
	IsReplicationRole *bool                   `json:"is_replication_role,omitempty"`
	IsSuperuser       *bool                   `json:"is_superuser,omitempty"`
	MemberOf          *[]string               `json:"member_of,omitempty"`
	Members           *[]string               `json:"members,omitempty"`
	Name              string                  `json:"name"`
	Password          *string                 `json:"password,omitempty"`
	ValidUntil        *string                 `json:"valid_until,omitempty"`
}

// CreateSchemaBody defines model for CreateSchemaBody.
type CreateSchemaBody struct {
	Name  string `json:"name"`
	Owner string `json:"owner"`
}

// CreateStorageBucketBody defines model for CreateStorageBucketBody.
type CreateStorageBucketBody struct {
	AllowedMimeTypes []string `json:"allowed_mime_types"`
	FileSizeLimit    float32  `json:"file_size_limit"`
	Id               string   `json:"id"`
	Public           bool     `json:"public"`
}

// CreateTableBody defines model for CreateTableBody.
type CreateTableBody struct {
	Comment *string `json:"comment,omitempty"`
	Name    string  `json:"name"`
	Schema  *string `json:"schema,omitempty"`
}

// CreateTriggerBody defines model for CreateTriggerBody.
type CreateTriggerBody struct {
	Activation     CreateTriggerBodyActivation  `json:"activation"`
	EnabledMode    CreateTriggerBodyEnabledMode `json:"enabled_mode"`
	Events         []CreateTriggerBodyEvents    `json:"events"`
	FunctionArgs   []string                     `json:"function_args"`
	FunctionName   string                       `json:"function_name"`
	FunctionSchema string                       `json:"function_schema"`
	Name           string                       `json:"name"`
	Orientation    CreateTriggerBodyOrientation `json:"orientation"`
	Schema         string                       `json:"schema"`
	Table          string                       `json:"table"`
	TableId        *float32                     `json:"table_id,omitempty"`
}

// CreateTriggerBodyActivation defines model for CreateTriggerBody.Activation.
type CreateTriggerBodyActivation string

// CreateTriggerBodyEnabledMode defines model for CreateTriggerBody.EnabledMode.
type CreateTriggerBodyEnabledMode string

// CreateTriggerBodyEvents defines model for CreateTriggerBody.Events.
type CreateTriggerBodyEvents string

// CreateTriggerBodyOrientation defines model for CreateTriggerBody.Orientation.
type CreateTriggerBodyOrientation string

// CustomSupabaseInternalRequests defines model for CustomSupabaseInternalRequests.
type CustomSupabaseInternalRequests struct {
	Ami AmiSearchOptions `json:"ami"`
}

// DeleteObjectsBody defines model for DeleteObjectsBody.
type DeleteObjectsBody struct {
	Paths []string `json:"paths"`
}

// DownloadBackupBody defines model for DownloadBackupBody.
type DownloadBackupBody struct {
	Data       map[string]interface{} `json:"data"`
	Id         float32                `json:"id"`
	InsertedAt string                 `json:"inserted_at"`
	ProjectId  float32                `json:"project_id"`
	S3Bucket   string                 `json:"s3_bucket"`
	S3Path     string                 `json:"s3_path"`
	Status     string                 `json:"status"`
}

// DownloadBackupResponse defines model for DownloadBackupResponse.
type DownloadBackupResponse struct {
	FileUrl string `json:"fileUrl"`
}

// DownloadObjectBody defines model for DownloadObjectBody.
type DownloadObjectBody struct {
	Options *DownloadObjectOptions `json:"options,omitempty"`
	Path    string                 `json:"path"`
}

// DownloadObjectOptions defines model for DownloadObjectOptions.
type DownloadObjectOptions struct {
	Download     *bool                          `json:"download,omitempty"`
	DownloadName *string                        `json:"downloadName,omitempty"`
	Transform    *StorageObjectTransformOptions `json:"transform,omitempty"`
}

// FormatQueryBody defines model for FormatQueryBody.
type FormatQueryBody struct {
	Query string `json:"query"`
}

// GetGoTrueConfigResponse defines model for GetGoTrueConfigResponse.
type GetGoTrueConfigResponse struct {
	DISABLESIGNUP                                 bool    `json:"DISABLE_SIGNUP"`
	EXTERNALAPPLEADDITIONALCLIENTIDS              *string `json:"EXTERNAL_APPLE_ADDITIONAL_CLIENT_IDS,omitempty"`
	EXTERNALAPPLECLIENTID                         string  `json:"EXTERNAL_APPLE_CLIENT_ID"`
	EXTERNALAPPLEENABLED                          bool    `json:"EXTERNAL_APPLE_ENABLED"`
	EXTERNALAPPLESECRET                           string  `json:"EXTERNAL_APPLE_SECRET"`
	EXTERNALAZURECLIENTID                         string  `json:"EXTERNAL_AZURE_CLIENT_ID"`
	EXTERNALAZUREENABLED                          bool    `json:"EXTERNAL_AZURE_ENABLED"`
	EXTERNALAZURESECRET                           string  `json:"EXTERNAL_AZURE_SECRET"`
	EXTERNALAZUREURL                              string  `json:"EXTERNAL_AZURE_URL"`
	EXTERNALBITBUCKETCLIENTID                     string  `json:"EXTERNAL_BITBUCKET_CLIENT_ID"`
	EXTERNALBITBUCKETENABLED                      bool    `json:"EXTERNAL_BITBUCKET_ENABLED"`
	EXTERNALBITBUCKETSECRET                       string  `json:"EXTERNAL_BITBUCKET_SECRET"`
	EXTERNALDISCORDCLIENTID                       string  `json:"EXTERNAL_DISCORD_CLIENT_ID"`
	EXTERNALDISCORDENABLED                        bool    `json:"EXTERNAL_DISCORD_ENABLED"`
	EXTERNALDISCORDSECRET                         string  `json:"EXTERNAL_DISCORD_SECRET"`
	EXTERNALEMAILENABLED                          bool    `json:"EXTERNAL_EMAIL_ENABLED"`
	EXTERNALFACEBOOKCLIENTID                      string  `json:"EXTERNAL_FACEBOOK_CLIENT_ID"`
	EXTERNALFACEBOOKENABLED                       bool    `json:"EXTERNAL_FACEBOOK_ENABLED"`
	EXTERNALFACEBOOKSECRET                        string  `json:"EXTERNAL_FACEBOOK_SECRET"`
	EXTERNALFIGMACLIENTID                         string  `json:"EXTERNAL_FIGMA_CLIENT_ID"`
	EXTERNALFIGMAENABLED                          bool    `json:"EXTERNAL_FIGMA_ENABLED"`
	EXTERNALFIGMASECRET                           string  `json:"EXTERNAL_FIGMA_SECRET"`
	EXTERNALGITHUBCLIENTID                        string  `json:"EXTERNAL_GITHUB_CLIENT_ID"`
	EXTERNALGITHUBENABLED                         bool    `json:"EXTERNAL_GITHUB_ENABLED"`
	EXTERNALGITHUBSECRET                          string  `json:"EXTERNAL_GITHUB_SECRET"`
	EXTERNALGITLABCLIENTID                        string  `json:"EXTERNAL_GITLAB_CLIENT_ID"`
	EXTERNALGITLABENABLED                         bool    `json:"EXTERNAL_GITLAB_ENABLED"`
	EXTERNALGITLABSECRET                          string  `json:"EXTERNAL_GITLAB_SECRET"`
	EXTERNALGITLABURL                             string  `json:"EXTERNAL_GITLAB_URL"`
	EXTERNALGOOGLEADDITIONALCLIENTIDS             *string `json:"EXTERNAL_GOOGLE_ADDITIONAL_CLIENT_IDS,omitempty"`
	EXTERNALGOOGLECLIENTID                        string  `json:"EXTERNAL_GOOGLE_CLIENT_ID"`
	EXTERNALGOOGLEENABLED                         bool    `json:"EXTERNAL_GOOGLE_ENABLED"`
	EXTERNALGOOGLESECRET                          string  `json:"EXTERNAL_GOOGLE_SECRET"`
	EXTERNALKAKAOCLIENTID                         string  `json:"EXTERNAL_KAKAO_CLIENT_ID"`
	EXTERNALKAKAOENABLED                          bool    `json:"EXTERNAL_KAKAO_ENABLED"`
	EXTERNALKAKAOSECRET                           string  `json:"EXTERNAL_KAKAO_SECRET"`
	EXTERNALKEYCLOAKCLIENTID                      string  `json:"EXTERNAL_KEYCLOAK_CLIENT_ID"`
	EXTERNALKEYCLOAKENABLED                       bool    `json:"EXTERNAL_KEYCLOAK_ENABLED"`
	EXTERNALKEYCLOAKSECRET                        string  `json:"EXTERNAL_KEYCLOAK_SECRET"`
	EXTERNALKEYCLOAKURL                           string  `json:"EXTERNAL_KEYCLOAK_URL"`
	EXTERNALLINKEDINCLIENTID                      string  `json:"EXTERNAL_LINKEDIN_CLIENT_ID"`
	EXTERNALLINKEDINENABLED                       bool    `json:"EXTERNAL_LINKEDIN_ENABLED"`
	EXTERNALLINKEDINSECRET                        string  `json:"EXTERNAL_LINKEDIN_SECRET"`
	EXTERNALNOTIONCLIENTID                        string  `json:"EXTERNAL_NOTION_CLIENT_ID"`
	EXTERNALNOTIONENABLED                         bool    `json:"EXTERNAL_NOTION_ENABLED"`
	EXTERNALNOTIONSECRET                          string  `json:"EXTERNAL_NOTION_SECRET"`
	EXTERNALPHONEENABLED                          bool    `json:"EXTERNAL_PHONE_ENABLED"`
	EXTERNALSLACKCLIENTID                         string  `json:"EXTERNAL_SLACK_CLIENT_ID"`
	EXTERNALSLACKENABLED                          bool    `json:"EXTERNAL_SLACK_ENABLED"`
	EXTERNALSLACKSECRET                           string  `json:"EXTERNAL_SLACK_SECRET"`
	EXTERNALSPOTIFYCLIENTID                       string  `json:"EXTERNAL_SPOTIFY_CLIENT_ID"`
	EXTERNALSPOTIFYENABLED                        bool    `json:"EXTERNAL_SPOTIFY_ENABLED"`
	EXTERNALSPOTIFYSECRET                         string  `json:"EXTERNAL_SPOTIFY_SECRET"`
	EXTERNALTWITCHCLIENTID                        string  `json:"EXTERNAL_TWITCH_CLIENT_ID"`
	EXTERNALTWITCHENABLED                         bool    `json:"EXTERNAL_TWITCH_ENABLED"`
	EXTERNALTWITCHSECRET                          string  `json:"EXTERNAL_TWITCH_SECRET"`
	EXTERNALTWITTERCLIENTID                       string  `json:"EXTERNAL_TWITTER_CLIENT_ID"`
	EXTERNALTWITTERENABLED                        bool    `json:"EXTERNAL_TWITTER_ENABLED"`
	EXTERNALTWITTERSECRET                         string  `json:"EXTERNAL_TWITTER_SECRET"`
	EXTERNALWORKOSCLIENTID                        string  `json:"EXTERNAL_WORKOS_CLIENT_ID"`
	EXTERNALWORKOSENABLED                         bool    `json:"EXTERNAL_WORKOS_ENABLED"`
	EXTERNALWORKOSSECRET                          string  `json:"EXTERNAL_WORKOS_SECRET"`
	EXTERNALWORKOSURL                             string  `json:"EXTERNAL_WORKOS_URL"`
	EXTERNALZOOMCLIENTID                          string  `json:"EXTERNAL_ZOOM_CLIENT_ID"`
	EXTERNALZOOMENABLED                           bool    `json:"EXTERNAL_ZOOM_ENABLED"`
	EXTERNALZOOMSECRET                            string  `json:"EXTERNAL_ZOOM_SECRET"`
	JWTEXP                                        float32 `json:"JWT_EXP"`
	MAILERAUTOCONFIRM                             bool    `json:"MAILER_AUTOCONFIRM"`
	MAILEROTPEXP                                  float32 `json:"MAILER_OTP_EXP"`
	MAILERSECUREEMAILCHANGEENABLED                bool    `json:"MAILER_SECURE_EMAIL_CHANGE_ENABLED"`
	MAILERSUBJECTSCONFIRMATION                    string  `json:"MAILER_SUBJECTS_CONFIRMATION"`
	MAILERSUBJECTSEMAILCHANGE                     string  `json:"MAILER_SUBJECTS_EMAIL_CHANGE"`
	MAILERSUBJECTSINVITE                          string  `json:"MAILER_SUBJECTS_INVITE"`
	MAILERSUBJECTSMAGICLINK                       string  `json:"MAILER_SUBJECTS_MAGIC_LINK"`
	MAILERSUBJECTSRECOVERY                        string  `json:"MAILER_SUBJECTS_RECOVERY"`
	MAILERTEMPLATESCONFIRMATIONCONTENT            string  `json:"MAILER_TEMPLATES_CONFIRMATION_CONTENT"`
	MAILERTEMPLATESEMAILCHANGECONTENT             string  `json:"MAILER_TEMPLATES_EMAIL_CHANGE_CONTENT"`
	MAILERTEMPLATESINVITECONTENT                  string  `json:"MAILER_TEMPLATES_INVITE_CONTENT"`
	MAILERTEMPLATESMAGICLINKCONTENT               string  `json:"MAILER_TEMPLATES_MAGIC_LINK_CONTENT"`
	MAILERTEMPLATESRECOVERYCONTENT                string  `json:"MAILER_TEMPLATES_RECOVERY_CONTENT"`
	MFAMAXENROLLEDFACTORS                         float32 `json:"MFA_MAX_ENROLLED_FACTORS"`
	PASSWORDMINLENGTH                             float32 `json:"PASSWORD_MIN_LENGTH"`
	RATELIMITEMAILSENT                            float32 `json:"RATE_LIMIT_EMAIL_SENT"`
	RATELIMITSMSSENT                              float32 `json:"RATE_LIMIT_SMS_SENT"`
	REFRESHTOKENROTATIONENABLED                   bool    `json:"REFRESH_TOKEN_ROTATION_ENABLED"`
	SAMLENABLED                                   *bool   `json:"SAML_ENABLED,omitempty"`
	SECURITYCAPTCHAENABLED                        bool    `json:"SECURITY_CAPTCHA_ENABLED"`
	SECURITYCAPTCHAPROVIDER                       string  `json:"SECURITY_CAPTCHA_PROVIDER"`
	SECURITYCAPTCHASECRET                         string  `json:"SECURITY_CAPTCHA_SECRET"`
	SECURITYREFRESHTOKENREUSEINTERVAL             float32 `json:"SECURITY_REFRESH_TOKEN_REUSE_INTERVAL"`
	SECURITYUPDATEPASSWORDREQUIREREAUTHENTICATION bool    `json:"SECURITY_UPDATE_PASSWORD_REQUIRE_REAUTHENTICATION"`
	SITEURL                                       string  `json:"SITE_URL"`
	SMSAUTOCONFIRM                                bool    `json:"SMS_AUTOCONFIRM"`
	SMSMAXFREQUENCY                               float32 `json:"SMS_MAX_FREQUENCY"`
	SMSMESSAGEBIRDACCESSKEY                       string  `json:"SMS_MESSAGEBIRD_ACCESS_KEY"`
	SMSMESSAGEBIRDORIGINATOR                      string  `json:"SMS_MESSAGEBIRD_ORIGINATOR"`
	SMSOTPEXP                                     float32 `json:"SMS_OTP_EXP"`
	SMSOTPLENGTH                                  float32 `json:"SMS_OTP_LENGTH"`
	SMSPROVIDER                                   string  `json:"SMS_PROVIDER"`
	SMSTEMPLATE                                   string  `json:"SMS_TEMPLATE"`
	SMSTESTOTP                                    string  `json:"SMS_TEST_OTP"`
	SMSTESTOTPVALIDUNTIL                          string  `json:"SMS_TEST_OTP_VALID_UNTIL"`
	SMSTEXTLOCALAPIKEY                            string  `json:"SMS_TEXTLOCAL_API_KEY"`
	SMSTEXTLOCALSENDER                            string  `json:"SMS_TEXTLOCAL_SENDER"`
	SMSTWILIOACCOUNTSID                           string  `json:"SMS_TWILIO_ACCOUNT_SID"`
	SMSTWILIOAUTHTOKEN                            string  `json:"SMS_TWILIO_AUTH_TOKEN"`
	SMSTWILIOMESSAGESERVICESID                    string  `json:"SMS_TWILIO_MESSAGE_SERVICE_SID"`
	SMSTWILIOVERIFYACCOUNTSID                     string  `json:"SMS_TWILIO_VERIFY_ACCOUNT_SID"`
	SMSTWILIOVERIFYAUTHTOKEN                      string  `json:"SMS_TWILIO_VERIFY_AUTH_TOKEN"`
	SMSTWILIOVERIFYMESSAGESERVICESID              string  `json:"SMS_TWILIO_VERIFY_MESSAGE_SERVICE_SID"`
	SMSVONAGEAPIKEY                               string  `json:"SMS_VONAGE_API_KEY"`
	SMSVONAGEAPISECRET                            string  `json:"SMS_VONAGE_API_SECRET"`
	SMSVONAGEFROM                                 string  `json:"SMS_VONAGE_FROM"`
	SMTPADMINEMAIL                                string  `json:"SMTP_ADMIN_EMAIL"`
	SMTPHOST                                      string  `json:"SMTP_HOST"`
	SMTPMAXFREQUENCY                              float32 `json:"SMTP_MAX_FREQUENCY"`
	SMTPPASS                                      *string `json:"SMTP_PASS"`
	SMTPPASSENCRYPTED                             *string `json:"SMTP_PASS_ENCRYPTED"`
	SMTPPORT                                      string  `json:"SMTP_PORT"`
	SMTPSENDERNAME                                *string `json:"SMTP_SENDER_NAME,omitempty"`
	SMTPUSER                                      string  `json:"SMTP_USER"`
	URIALLOWLIST                                  string  `json:"URI_ALLOW_LIST"`
}

// GetMetricsBody defines model for GetMetricsBody.
type GetMetricsBody struct {
	Interval    GetMetricsBodyInterval `json:"interval"`
	Metric      GetMetricsBodyMetric   `json:"metric"`
	ProjectRefs []string               `json:"project_refs"`
	Region      string                 `json:"region"`
}

// GetMetricsBodyInterval defines model for GetMetricsBody.Interval.
type GetMetricsBodyInterval string

// GetMetricsBodyMetric defines model for GetMetricsBody.Metric.
type GetMetricsBodyMetric string

// GetMetricsResponse defines model for GetMetricsResponse.
type GetMetricsResponse struct {
	Metrics []ProjectMetric `json:"metrics"`
}

// GetObjectsBody defines model for GetObjectsBody.
type GetObjectsBody struct {
	Options StorageObjectSearchOptions `json:"options"`
	Path    string                     `json:"path"`
}

// GetPublicUrlBody defines model for GetPublicUrlBody.
type GetPublicUrlBody struct {
	Options *PublicUrlOptions `json:"options,omitempty"`
	Path    string            `json:"path"`
}

// GetSignedUrlBody defines model for GetSignedUrlBody.
type GetSignedUrlBody struct {
	ExpiresIn float32           `json:"expiresIn"`
	Options   *SignedUrlOptions `json:"options,omitempty"`
	Path      string            `json:"path"`
}

// GetSignedUrlsBody defines model for GetSignedUrlsBody.
type GetSignedUrlsBody struct {
	ExpiresIn float32            `json:"expiresIn"`
	Options   *SignedUrlsOptions `json:"options,omitempty"`
	Path      []string           `json:"path"`
}

// GetUserContentObject defines model for GetUserContentObject.
type GetUserContentObject struct {
	Description   *string `json:"description,omitempty"`
	Id            string  `json:"id"`
	InsertedAt    string  `json:"inserted_at"`
	LastUpdatedBy float32 `json:"last_updated_by"`
	Name          string  `json:"name"`
	Owner         struct {
		Id       float32 `json:"id"`
		Username string  `json:"username"`
	} `json:"owner"`
	OwnerId   float32                `json:"owner_id"`
	ProjectId float32                `json:"project_id"`
	Type      map[string]interface{} `json:"type"`
	UpdatedAt string                 `json:"updated_at"`
	UpdatedBy struct {
		Id       float32 `json:"id"`
		Username string  `json:"username"`
	} `json:"updated_by"`
	Visibility map[string]interface{} `json:"visibility"`
}

// GetUserContentResponse defines model for GetUserContentResponse.
type GetUserContentResponse struct {
	Data []GetUserContentObject `json:"data"`
}

// GoTrueConfig defines model for GoTrueConfig.
type GoTrueConfig struct {
	DISABLESIGNUP                                 bool    `json:"DISABLE_SIGNUP"`
	EXTERNALAPPLEADDITIONALCLIENTIDS              *string `json:"EXTERNAL_APPLE_ADDITIONAL_CLIENT_IDS,omitempty"`
	EXTERNALAPPLECLIENTID                         string  `json:"EXTERNAL_APPLE_CLIENT_ID"`
	EXTERNALAPPLEENABLED                          bool    `json:"EXTERNAL_APPLE_ENABLED"`
	EXTERNALAPPLESECRET                           string  `json:"EXTERNAL_APPLE_SECRET"`
	EXTERNALAZURECLIENTID                         string  `json:"EXTERNAL_AZURE_CLIENT_ID"`
	EXTERNALAZUREENABLED                          bool    `json:"EXTERNAL_AZURE_ENABLED"`
	EXTERNALAZURESECRET                           string  `json:"EXTERNAL_AZURE_SECRET"`
	EXTERNALAZUREURL                              string  `json:"EXTERNAL_AZURE_URL"`
	EXTERNALBITBUCKETCLIENTID                     string  `json:"EXTERNAL_BITBUCKET_CLIENT_ID"`
	EXTERNALBITBUCKETENABLED                      bool    `json:"EXTERNAL_BITBUCKET_ENABLED"`
	EXTERNALBITBUCKETSECRET                       string  `json:"EXTERNAL_BITBUCKET_SECRET"`
	EXTERNALDISCORDCLIENTID                       string  `json:"EXTERNAL_DISCORD_CLIENT_ID"`
	EXTERNALDISCORDENABLED                        bool    `json:"EXTERNAL_DISCORD_ENABLED"`
	EXTERNALDISCORDSECRET                         string  `json:"EXTERNAL_DISCORD_SECRET"`
	EXTERNALEMAILENABLED                          bool    `json:"EXTERNAL_EMAIL_ENABLED"`
	EXTERNALFACEBOOKCLIENTID                      string  `json:"EXTERNAL_FACEBOOK_CLIENT_ID"`
	EXTERNALFACEBOOKENABLED                       bool    `json:"EXTERNAL_FACEBOOK_ENABLED"`
	EXTERNALFACEBOOKSECRET                        string  `json:"EXTERNAL_FACEBOOK_SECRET"`
	EXTERNALFIGMACLIENTID                         string  `json:"EXTERNAL_FIGMA_CLIENT_ID"`
	EXTERNALFIGMAENABLED                          bool    `json:"EXTERNAL_FIGMA_ENABLED"`
	EXTERNALFIGMASECRET                           string  `json:"EXTERNAL_FIGMA_SECRET"`
	EXTERNALGITHUBCLIENTID                        string  `json:"EXTERNAL_GITHUB_CLIENT_ID"`
	EXTERNALGITHUBENABLED                         bool    `json:"EXTERNAL_GITHUB_ENABLED"`
	EXTERNALGITHUBSECRET                          string  `json:"EXTERNAL_GITHUB_SECRET"`
	EXTERNALGITLABCLIENTID                        string  `json:"EXTERNAL_GITLAB_CLIENT_ID"`
	EXTERNALGITLABENABLED                         bool    `json:"EXTERNAL_GITLAB_ENABLED"`
	EXTERNALGITLABSECRET                          string  `json:"EXTERNAL_GITLAB_SECRET"`
	EXTERNALGITLABURL                             string  `json:"EXTERNAL_GITLAB_URL"`
	EXTERNALGOOGLEADDITIONALCLIENTIDS             *string `json:"EXTERNAL_GOOGLE_ADDITIONAL_CLIENT_IDS,omitempty"`
	EXTERNALGOOGLECLIENTID                        string  `json:"EXTERNAL_GOOGLE_CLIENT_ID"`
	EXTERNALGOOGLEENABLED                         bool    `json:"EXTERNAL_GOOGLE_ENABLED"`
	EXTERNALGOOGLESECRET                          string  `json:"EXTERNAL_GOOGLE_SECRET"`
	EXTERNALKAKAOCLIENTID                         string  `json:"EXTERNAL_KAKAO_CLIENT_ID"`
	EXTERNALKAKAOENABLED                          bool    `json:"EXTERNAL_KAKAO_ENABLED"`
	EXTERNALKAKAOSECRET                           string  `json:"EXTERNAL_KAKAO_SECRET"`
	EXTERNALKEYCLOAKCLIENTID                      string  `json:"EXTERNAL_KEYCLOAK_CLIENT_ID"`
	EXTERNALKEYCLOAKENABLED                       bool    `json:"EXTERNAL_KEYCLOAK_ENABLED"`
	EXTERNALKEYCLOAKSECRET                        string  `json:"EXTERNAL_KEYCLOAK_SECRET"`
	EXTERNALKEYCLOAKURL                           string  `json:"EXTERNAL_KEYCLOAK_URL"`
	EXTERNALLINKEDINCLIENTID                      string  `json:"EXTERNAL_LINKEDIN_CLIENT_ID"`
	EXTERNALLINKEDINENABLED                       bool    `json:"EXTERNAL_LINKEDIN_ENABLED"`
	EXTERNALLINKEDINSECRET                        string  `json:"EXTERNAL_LINKEDIN_SECRET"`
	EXTERNALNOTIONCLIENTID                        string  `json:"EXTERNAL_NOTION_CLIENT_ID"`
	EXTERNALNOTIONENABLED                         bool    `json:"EXTERNAL_NOTION_ENABLED"`
	EXTERNALNOTIONSECRET                          string  `json:"EXTERNAL_NOTION_SECRET"`
	EXTERNALPHONEENABLED                          bool    `json:"EXTERNAL_PHONE_ENABLED"`
	EXTERNALSLACKCLIENTID                         string  `json:"EXTERNAL_SLACK_CLIENT_ID"`
	EXTERNALSLACKENABLED                          bool    `json:"EXTERNAL_SLACK_ENABLED"`
	EXTERNALSLACKSECRET                           string  `json:"EXTERNAL_SLACK_SECRET"`
	EXTERNALSPOTIFYCLIENTID                       string  `json:"EXTERNAL_SPOTIFY_CLIENT_ID"`
	EXTERNALSPOTIFYENABLED                        bool    `json:"EXTERNAL_SPOTIFY_ENABLED"`
	EXTERNALSPOTIFYSECRET                         string  `json:"EXTERNAL_SPOTIFY_SECRET"`
	EXTERNALTWITCHCLIENTID                        string  `json:"EXTERNAL_TWITCH_CLIENT_ID"`
	EXTERNALTWITCHENABLED                         bool    `json:"EXTERNAL_TWITCH_ENABLED"`
	EXTERNALTWITCHSECRET                          string  `json:"EXTERNAL_TWITCH_SECRET"`
	EXTERNALTWITTERCLIENTID                       string  `json:"EXTERNAL_TWITTER_CLIENT_ID"`
	EXTERNALTWITTERENABLED                        bool    `json:"EXTERNAL_TWITTER_ENABLED"`
	EXTERNALTWITTERSECRET                         string  `json:"EXTERNAL_TWITTER_SECRET"`
	EXTERNALWORKOSCLIENTID                        string  `json:"EXTERNAL_WORKOS_CLIENT_ID"`
	EXTERNALWORKOSENABLED                         bool    `json:"EXTERNAL_WORKOS_ENABLED"`
	EXTERNALWORKOSSECRET                          string  `json:"EXTERNAL_WORKOS_SECRET"`
	EXTERNALWORKOSURL                             string  `json:"EXTERNAL_WORKOS_URL"`
	EXTERNALZOOMCLIENTID                          string  `json:"EXTERNAL_ZOOM_CLIENT_ID"`
	EXTERNALZOOMENABLED                           bool    `json:"EXTERNAL_ZOOM_ENABLED"`
	EXTERNALZOOMSECRET                            string  `json:"EXTERNAL_ZOOM_SECRET"`
	JWTEXP                                        float32 `json:"JWT_EXP"`
	MAILERAUTOCONFIRM                             bool    `json:"MAILER_AUTOCONFIRM"`
	MAILEROTPEXP                                  float32 `json:"MAILER_OTP_EXP"`
	MAILERSECUREEMAILCHANGEENABLED                bool    `json:"MAILER_SECURE_EMAIL_CHANGE_ENABLED"`
	MAILERSUBJECTSCONFIRMATION                    string  `json:"MAILER_SUBJECTS_CONFIRMATION"`
	MAILERSUBJECTSEMAILCHANGE                     string  `json:"MAILER_SUBJECTS_EMAIL_CHANGE"`
	MAILERSUBJECTSINVITE                          string  `json:"MAILER_SUBJECTS_INVITE"`
	MAILERSUBJECTSMAGICLINK                       string  `json:"MAILER_SUBJECTS_MAGIC_LINK"`
	MAILERSUBJECTSRECOVERY                        string  `json:"MAILER_SUBJECTS_RECOVERY"`
	MAILERTEMPLATESCONFIRMATIONCONTENT            string  `json:"MAILER_TEMPLATES_CONFIRMATION_CONTENT"`
	MAILERTEMPLATESEMAILCHANGECONTENT             string  `json:"MAILER_TEMPLATES_EMAIL_CHANGE_CONTENT"`
	MAILERTEMPLATESINVITECONTENT                  string  `json:"MAILER_TEMPLATES_INVITE_CONTENT"`
	MAILERTEMPLATESMAGICLINKCONTENT               string  `json:"MAILER_TEMPLATES_MAGIC_LINK_CONTENT"`
	MAILERTEMPLATESRECOVERYCONTENT                string  `json:"MAILER_TEMPLATES_RECOVERY_CONTENT"`
	MFAMAXENROLLEDFACTORS                         float32 `json:"MFA_MAX_ENROLLED_FACTORS"`
	PASSWORDMINLENGTH                             float32 `json:"PASSWORD_MIN_LENGTH"`
	RATELIMITEMAILSENT                            float32 `json:"RATE_LIMIT_EMAIL_SENT"`
	RATELIMITSMSSENT                              float32 `json:"RATE_LIMIT_SMS_SENT"`
	REFRESHTOKENROTATIONENABLED                   bool    `json:"REFRESH_TOKEN_ROTATION_ENABLED"`
	SAMLENABLED                                   *bool   `json:"SAML_ENABLED,omitempty"`
	SECURITYCAPTCHAENABLED                        bool    `json:"SECURITY_CAPTCHA_ENABLED"`
	SECURITYCAPTCHAPROVIDER                       string  `json:"SECURITY_CAPTCHA_PROVIDER"`
	SECURITYCAPTCHASECRET                         string  `json:"SECURITY_CAPTCHA_SECRET"`
	SECURITYREFRESHTOKENREUSEINTERVAL             float32 `json:"SECURITY_REFRESH_TOKEN_REUSE_INTERVAL"`
	SECURITYUPDATEPASSWORDREQUIREREAUTHENTICATION bool    `json:"SECURITY_UPDATE_PASSWORD_REQUIRE_REAUTHENTICATION"`
	SITEURL                                       string  `json:"SITE_URL"`
	SMSAUTOCONFIRM                                bool    `json:"SMS_AUTOCONFIRM"`
	SMSMAXFREQUENCY                               float32 `json:"SMS_MAX_FREQUENCY"`
	SMSMESSAGEBIRDACCESSKEY                       string  `json:"SMS_MESSAGEBIRD_ACCESS_KEY"`
	SMSMESSAGEBIRDORIGINATOR                      string  `json:"SMS_MESSAGEBIRD_ORIGINATOR"`
	SMSOTPEXP                                     float32 `json:"SMS_OTP_EXP"`
	SMSOTPLENGTH                                  float32 `json:"SMS_OTP_LENGTH"`
	SMSPROVIDER                                   string  `json:"SMS_PROVIDER"`
	SMSTEMPLATE                                   string  `json:"SMS_TEMPLATE"`
	SMSTESTOTP                                    string  `json:"SMS_TEST_OTP"`
	SMSTESTOTPVALIDUNTIL                          string  `json:"SMS_TEST_OTP_VALID_UNTIL"`
	SMSTEXTLOCALAPIKEY                            string  `json:"SMS_TEXTLOCAL_API_KEY"`
	SMSTEXTLOCALSENDER                            string  `json:"SMS_TEXTLOCAL_SENDER"`
	SMSTWILIOACCOUNTSID                           string  `json:"SMS_TWILIO_ACCOUNT_SID"`
	SMSTWILIOAUTHTOKEN                            string  `json:"SMS_TWILIO_AUTH_TOKEN"`
	SMSTWILIOMESSAGESERVICESID                    string  `json:"SMS_TWILIO_MESSAGE_SERVICE_SID"`
	SMSTWILIOVERIFYACCOUNTSID                     string  `json:"SMS_TWILIO_VERIFY_ACCOUNT_SID"`
	SMSTWILIOVERIFYAUTHTOKEN                      string  `json:"SMS_TWILIO_VERIFY_AUTH_TOKEN"`
	SMSTWILIOVERIFYMESSAGESERVICESID              string  `json:"SMS_TWILIO_VERIFY_MESSAGE_SERVICE_SID"`
	SMSVONAGEAPIKEY                               string  `json:"SMS_VONAGE_API_KEY"`
	SMSVONAGEAPISECRET                            string  `json:"SMS_VONAGE_API_SECRET"`
	SMSVONAGEFROM                                 string  `json:"SMS_VONAGE_FROM"`
	SMTPADMINEMAIL                                string  `json:"SMTP_ADMIN_EMAIL"`
	SMTPHOST                                      string  `json:"SMTP_HOST"`
	SMTPMAXFREQUENCY                              float32 `json:"SMTP_MAX_FREQUENCY"`
	SMTPPASS                                      *string `json:"SMTP_PASS"`
	SMTPPASSENCRYPTED                             *string `json:"SMTP_PASS_ENCRYPTED"`
	SMTPPORT                                      string  `json:"SMTP_PORT"`
	SMTPSENDERNAME                                *string `json:"SMTP_SENDER_NAME,omitempty"`
	SMTPUSER                                      string  `json:"SMTP_USER"`
	URIALLOWLIST                                  string  `json:"URI_ALLOW_LIST"`
}

// GrantColumnPrivilegesBody defines model for GrantColumnPrivilegesBody.
type GrantColumnPrivilegesBody struct {
	ColumnId      string                                 `json:"column_id"`
	Grantee       string                                 `json:"grantee"`
	IsGrantable   *bool                                  `json:"is_grantable,omitempty"`
	PrivilegeType GrantColumnPrivilegesBodyPrivilegeType `json:"privilege_type"`
}

// GrantColumnPrivilegesBodyPrivilegeType defines model for GrantColumnPrivilegesBody.PrivilegeType.
type GrantColumnPrivilegesBodyPrivilegeType string

// GrantTablePrivilegesBody defines model for GrantTablePrivilegesBody.
type GrantTablePrivilegesBody struct {
	Grantee       string                                `json:"grantee"`
	IsGrantable   *bool                                 `json:"is_grantable,omitempty"`
	PrivilegeType GrantTablePrivilegesBodyPrivilegeType `json:"privilege_type"`
	RelationId    float32                               `json:"relation_id"`
}

// GrantTablePrivilegesBodyPrivilegeType defines model for GrantTablePrivilegesBody.PrivilegeType.
type GrantTablePrivilegesBodyPrivilegeType string

// Invite defines model for Invite.
type Invite struct {
	InvitedAt    string  `json:"invited_at"`
	InvitedEmail string  `json:"invited_email"`
	InvitedId    float32 `json:"invited_id"`
	RoleId       float32 `json:"role_id"`
}

// InviteResponse defines model for InviteResponse.
type InviteResponse struct {
	AuthorizedUser    bool   `json:"authorized_user"`
	EmailMatch        bool   `json:"email_match"`
	ExpiredToken      bool   `json:"expired_token"`
	InviteId          string `json:"invite_id"`
	OrganizationName  string `json:"organization_name"`
	TokenDoesNotExist bool   `json:"token_does_not_exist"`
}

// InviteUserBody defines model for InviteUserBody.
type InviteUserBody struct {
	InvitedEmail string  `json:"invited_email"`
	OwnerId      float32 `json:"owner_id"`
	RoleId       float32 `json:"role_id"`
}

// JoinResponse defines model for JoinResponse.
type JoinResponse struct {
	BillingEmail     string  `json:"billing_email"`
	Id               float32 `json:"id"`
	Name             string  `json:"name"`
	Slug             string  `json:"slug"`
	StripeCustomerId string  `json:"stripe_customer_id"`
}

// Member defines model for Member.
type Member struct {
	GotrueId     string    `json:"gotrue_id"`
	PrimaryEmail string    `json:"primary_email"`
	RoleIds      []float32 `json:"role_ids"`
	Username     string    `json:"username"`
}

// MoveObjectBody defines model for MoveObjectBody.
type MoveObjectBody struct {
	From string `json:"from"`
	To   string `json:"to"`
}

// NotificationResponseV1 defines model for NotificationResponseV1.
type NotificationResponseV1 struct {
	Data               map[string]interface{} `json:"data"`
	Id                 string                 `json:"id"`
	InsertedAt         string                 `json:"inserted_at"`
	Meta               map[string]interface{} `json:"meta"`
	NotificationName   string                 `json:"notification_name"`
	NotificationStatus string                 `json:"notification_status"`
	ProjectId          float32                `json:"project_id"`
}

// NotificationResponseV2 defines model for NotificationResponseV2.
type NotificationResponseV2 struct {
	Data       map[string]interface{} `json:"data"`
	Id         string                 `json:"id"`
	InsertedAt string                 `json:"inserted_at"`
	Meta       map[string]interface{} `json:"meta"`
	Name       string                 `json:"name"`
	Priority   map[string]interface{} `json:"priority"`
	Status     map[string]interface{} `json:"status"`
	Type       map[string]interface{} `json:"type"`
}

// OrganizationResponse defines model for OrganizationResponse.
type OrganizationResponse struct {
	BillingEmail     string   `json:"billing_email"`
	Id               float32  `json:"id"`
	IsOwner          bool     `json:"is_owner"`
	Name             string   `json:"name"`
	OptInTags        []string `json:"opt_in_tags"`
	Slug             string   `json:"slug"`
	StripeCustomerId string   `json:"stripe_customer_id"`
	SubscriptionId   *string  `json:"subscription_id,omitempty"`
}

// OrganizationSlugResponse defines model for OrganizationSlugResponse.
type OrganizationSlugResponse struct {
	BillingEmail     string   `json:"billing_email"`
	Id               float32  `json:"id"`
	Name             string   `json:"name"`
	OptInTags        []string `json:"opt_in_tags"`
	Slug             string   `json:"slug"`
	StripeCustomerId string   `json:"stripe_customer_id"`
}

// PgbouncerConfigResponse defines model for PgbouncerConfigResponse.
type PgbouncerConfigResponse struct {
	ConnectionString        string                                 `json:"connectionString"`
	DbDnsName               string                                 `json:"db_dns_name"`
	DbHost                  string                                 `json:"db_host"`
	DbName                  string                                 `json:"db_name"`
	DbPort                  float32                                `json:"db_port"`
	DbSsl                   bool                                   `json:"db_ssl"`
	DbUser                  string                                 `json:"db_user"`
	DefaultPoolSize         *float32                               `json:"default_pool_size,omitempty"`
	IgnoreStartupParameters *string                                `json:"ignore_startup_parameters,omitempty"`
	InsertedAt              string                                 `json:"inserted_at"`
	MaxClientConn           *float32                               `json:"max_client_conn,omitempty"`
	PgbouncerEnabled        bool                                   `json:"pgbouncer_enabled"`
	PgbouncerStatus         PgbouncerConfigResponsePgbouncerStatus `json:"pgbouncer_status"`
	PoolMode                *PgbouncerConfigResponsePoolMode       `json:"pool_mode,omitempty"`
	SupavisorEnabled        bool                                   `json:"supavisor_enabled"`
}

// PgbouncerConfigResponsePgbouncerStatus defines model for PgbouncerConfigResponse.PgbouncerStatus.
type PgbouncerConfigResponsePgbouncerStatus string

// PgbouncerConfigResponsePoolMode defines model for PgbouncerConfigResponse.PoolMode.
type PgbouncerConfigResponsePoolMode string

// PointInTimeRestoreBody defines model for PointInTimeRestoreBody.
type PointInTimeRestoreBody struct {
	RecoveryTimeTargetUnix float32 `json:"recovery_time_target_unix"`
}

// PostgresColumn defines model for PostgresColumn.
type PostgresColumn struct {
	Check              *string                `json:"check"`
	Comment            *string                `json:"comment"`
	DataType           string                 `json:"data_type"`
	DefaultValue       map[string]interface{} `json:"default_value"`
	Enums              []string               `json:"enums"`
	Format             string                 `json:"format"`
	Id                 string                 `json:"id"`
	IdentityGeneration map[string]interface{} `json:"identity_generation"`
	IsGenerated        bool                   `json:"is_generated"`
	IsIdentity         bool                   `json:"is_identity"`
	IsNullable         bool                   `json:"is_nullable"`
	IsUnique           bool                   `json:"is_unique"`
	IsUpdatable        bool                   `json:"is_updatable"`
	Name               string                 `json:"name"`
	OrdinalPosition    float32                `json:"ordinal_position"`
	Schema             string                 `json:"schema"`
	Table              string                 `json:"table"`
	TableId            float32                `json:"table_id"`
}

// PostgresColumnPrivileges defines model for PostgresColumnPrivileges.
type PostgresColumnPrivileges struct {
	ColumnId       string            `json:"column_id"`
	ColumnName     string            `json:"column_name"`
	Privileges     []ColumnPrivilege `json:"privileges"`
	RelationName   string            `json:"relation_name"`
	RelationSchema string            `json:"relation_schema"`
}

// PostgresConfigResponse defines model for PostgresConfigResponse.
type PostgresConfigResponse struct {
	EffectiveCacheSize            *string                                       `json:"effective_cache_size,omitempty"`
	MaintenanceWorkMem            *string                                       `json:"maintenance_work_mem,omitempty"`
	MaxConnections                *int                                          `json:"max_connections,omitempty"`
	MaxParallelMaintenanceWorkers *int                                          `json:"max_parallel_maintenance_workers,omitempty"`
	MaxParallelWorkers            *int                                          `json:"max_parallel_workers,omitempty"`
	MaxParallelWorkersPerGather   *int                                          `json:"max_parallel_workers_per_gather,omitempty"`
	MaxWorkerProcesses            *int                                          `json:"max_worker_processes,omitempty"`
	SessionReplicationRole        *PostgresConfigResponseSessionReplicationRole `json:"session_replication_role,omitempty"`
	SharedBuffers                 *string                                       `json:"shared_buffers,omitempty"`
	StatementTimeout              *string                                       `json:"statement_timeout,omitempty"`
	WorkMem                       *string                                       `json:"work_mem,omitempty"`
}

// PostgresConfigResponseSessionReplicationRole defines model for PostgresConfigResponse.SessionReplicationRole.
type PostgresConfigResponseSessionReplicationRole string

// PostgresExtension defines model for PostgresExtension.
type PostgresExtension struct {
	Comment          *string `json:"comment"`
	DefaultVersion   string  `json:"default_version"`
	InstalledVersion *string `json:"installed_version"`
	Name             string  `json:"name"`
	Schema           *string `json:"schema"`
}

// PostgresForeignTable defines model for PostgresForeignTable.
type PostgresForeignTable struct {
	Columns *[]PostgresColumn `json:"columns,omitempty"`
	Comment *string           `json:"comment"`
	Id      float32           `json:"id"`
	Name    string            `json:"name"`
	Schema  string            `json:"schema"`
}

// PostgresFunction defines model for PostgresFunction.
type PostgresFunction struct {
	ArgumentTypes         string                   `json:"argument_types"`
	Behavior              PostgresFunctionBehavior `json:"behavior"`
	CompleteStatement     string                   `json:"complete_statement"`
	ConfigParams          *map[string]interface{}  `json:"config_params"`
	Definition            string                   `json:"definition"`
	Id                    float32                  `json:"id"`
	IdentityArgumentTypes string                   `json:"identity_argument_types"`
	Language              string                   `json:"language"`
	Name                  string                   `json:"name"`
	ReturnType            string                   `json:"return_type"`
	Schema                string                   `json:"schema"`
	SecurityDefiner       bool                     `json:"security_definer"`
}

// PostgresFunctionBehavior defines model for PostgresFunction.Behavior.
type PostgresFunctionBehavior string

// PostgresMaterializedView defines model for PostgresMaterializedView.
type PostgresMaterializedView struct {
	Columns     *[]PostgresColumn `json:"columns,omitempty"`
	Comment     *string           `json:"comment"`
	Id          float32           `json:"id"`
	IsPopulated bool              `json:"is_populated"`
	Name        string            `json:"name"`
	Schema      string            `json:"schema"`
}

// PostgresPolicy defines model for PostgresPolicy.
type PostgresPolicy struct {
	Action     PostgresPolicyAction  `json:"action"`
	Check      *string               `json:"check"`
	Command    PostgresPolicyCommand `json:"command"`
	Definition *string               `json:"definition"`
	Id         float32               `json:"id"`
	Name       string                `json:"name"`
	Roles      []string              `json:"roles"`
	Schema     string                `json:"schema"`
	Table      string                `json:"table"`
	TableId    float32               `json:"table_id"`
}

// PostgresPolicyAction defines model for PostgresPolicy.Action.
type PostgresPolicyAction string

// PostgresPolicyCommand defines model for PostgresPolicy.Command.
type PostgresPolicyCommand string

// PostgresPublication defines model for PostgresPublication.
type PostgresPublication struct {
	Id              float32  `json:"id"`
	Name            string   `json:"name"`
	Owner           string   `json:"owner"`
	PublishDelete   bool     `json:"publish_delete"`
	PublishInsert   bool     `json:"publish_insert"`
	PublishTruncate bool     `json:"publish_truncate"`
	PublishUpdate   bool     `json:"publish_update"`
	Tables          *[]Table `json:"tables"`
}

// PostgresRole defines model for PostgresRole.
type PostgresRole struct {
	ActiveConnections float32   `json:"active_connections"`
	CanBypassRls      bool      `json:"can_bypass_rls"`
	CanCreateDb       bool      `json:"can_create_db"`
	CanCreateRole     bool      `json:"can_create_role"`
	CanLogin          bool      `json:"can_login"`
	Config            *[]string `json:"config"`
	ConnectionLimit   float32   `json:"connection_limit"`
	Id                float32   `json:"id"`
	InheritRole       bool      `json:"inherit_role"`
	IsReplicationRole bool      `json:"is_replication_role"`
	IsSuperuser       bool      `json:"is_superuser"`
	Name              string    `json:"name"`
	Password          string    `json:"password"`
	ValidUntil        *string   `json:"valid_until"`
}

// PostgresSchema defines model for PostgresSchema.
type PostgresSchema struct {
	Id    float32 `json:"id"`
	Name  string  `json:"name"`
	Owner string  `json:"owner"`
}

// PostgresTable defines model for PostgresTable.
type PostgresTable struct {
	Bytes            float32                      `json:"bytes"`
	Columns          *[]PostgresColumn            `json:"columns,omitempty"`
	Comment          *string                      `json:"comment"`
	DeadRowsEstimate float32                      `json:"dead_rows_estimate"`
	Id               float32                      `json:"id"`
	LiveRowsEstimate float32                      `json:"live_rows_estimate"`
	Name             string                       `json:"name"`
	PrimaryKeys      []PrimaryKey                 `json:"primary_keys"`
	Relationships    []Relationship               `json:"relationships"`
	ReplicaIdentity  PostgresTableReplicaIdentity `json:"replica_identity"`
	RlsEnabled       bool                         `json:"rls_enabled"`
	RlsForced        bool                         `json:"rls_forced"`
	Schema           string                       `json:"schema"`
	Size             string                       `json:"size"`
}

// PostgresTableReplicaIdentity defines model for PostgresTable.ReplicaIdentity.
type PostgresTableReplicaIdentity string

// PostgresTablePrivileges defines model for PostgresTablePrivileges.
type PostgresTablePrivileges struct {
	Kind       string           `json:"kind"`
	Name       string           `json:"name"`
	Privileges []TablePrivilege `json:"privileges"`
	Schema     string           `json:"schema"`
}

// PostgresTrigger defines model for PostgresTrigger.
type PostgresTrigger struct {
	Activation     PostgresTriggerActivation  `json:"activation"`
	Condition      *string                    `json:"condition"`
	EnabledMode    PostgresTriggerEnabledMode `json:"enabled_mode"`
	Events         []string                   `json:"events"`
	FunctionArgs   []string                   `json:"function_args"`
	FunctionName   string                     `json:"function_name"`
	FunctionSchema string                     `json:"function_schema"`
	Id             float32                    `json:"id"`
	Name           string                     `json:"name"`
	Orientation    PostgresTriggerOrientation `json:"orientation"`
	Schema         string                     `json:"schema"`
	Table          string                     `json:"table"`
	TableId        float32                    `json:"table_id"`
}

// PostgresTriggerActivation defines model for PostgresTrigger.Activation.
type PostgresTriggerActivation string

// PostgresTriggerEnabledMode defines model for PostgresTrigger.EnabledMode.
type PostgresTriggerEnabledMode string

// PostgresTriggerOrientation defines model for PostgresTrigger.Orientation.
type PostgresTriggerOrientation string

// PostgresType defines model for PostgresType.
type PostgresType struct {
	Comment *string  `json:"comment"`
	Enums   []string `json:"enums"`
	Format  string   `json:"format"`
	Id      float32  `json:"id"`
	Name    string   `json:"name"`
	Schema  string   `json:"schema"`
}

// PostgresView defines model for PostgresView.
type PostgresView struct {
	Columns     *[]PostgresColumn `json:"columns,omitempty"`
	Comment     *string           `json:"comment"`
	Id          float32           `json:"id"`
	IsUpdatable bool              `json:"is_updatable"`
	Name        string            `json:"name"`
	Schema      string            `json:"schema"`
}

// PostgrestConfigResponse defines model for PostgrestConfigResponse.
type PostgrestConfigResponse struct {
	DbExtraSearchPath string `json:"db_extra_search_path"`
	DbSchema          string `json:"db_schema"`
	MaxRows           int    `json:"max_rows"`
}

// PrimaryKey defines model for PrimaryKey.
type PrimaryKey struct {
	Name      string  `json:"name"`
	Schema    string  `json:"schema"`
	TableId   float32 `json:"table_id"`
	TableName string  `json:"table_name"`
}

// ProjectAppConfigResponse defines model for ProjectAppConfigResponse.
type ProjectAppConfigResponse struct {
	DbSchema                   string `json:"db_schema"`
	Endpoint                   string `json:"endpoint"`
	RealtimeMultitenantEnabled bool   `json:"realtime_multitenant_enabled"`
}

// ProjectDetailResponse defines model for ProjectDetailResponse.
type ProjectDetailResponse struct {
	CloudProvider             string                      `json:"cloud_provider"`
	ConnectionString          string                      `json:"connectionString"`
	DbVersion                 *string                     `json:"dbVersion,omitempty"`
	DbHost                    string                      `json:"db_host"`
	Id                        float32                     `json:"id"`
	InsertedAt                string                      `json:"inserted_at"`
	IsBranchEnabled           bool                        `json:"is_branch_enabled"`
	KpsVersion                *string                     `json:"kpsVersion,omitempty"`
	LastDatabaseResizeAt      *string                     `json:"lastDatabaseResizeAt,omitempty"`
	MaxDatabasePreprovisionGb *float32                    `json:"maxDatabasePreprovisionGb,omitempty"`
	Name                      string                      `json:"name"`
	OrganizationId            float32                     `json:"organization_id"`
	ParentProjectRef          *string                     `json:"parent_project_ref,omitempty"`
	Ref                       string                      `json:"ref"`
	Region                    string                      `json:"region"`
	RestUrl                   string                      `json:"restUrl"`
	ServiceVersions           *ServiceVersions            `json:"serviceVersions,omitempty"`
	Status                    ProjectDetailResponseStatus `json:"status"`
	SubscriptionId            string                      `json:"subscription_id"`
	VolumeSizeGb              *float32                    `json:"volumeSizeGb,omitempty"`
}

// ProjectDetailResponseStatus defines model for ProjectDetailResponse.Status.
type ProjectDetailResponseStatus string

// ProjectInfo defines model for ProjectInfo.
type ProjectInfo struct {
	CloudProvider         string   `json:"cloud_provider"`
	Id                    float32  `json:"id"`
	InsertedAt            string   `json:"inserted_at"`
	IsBranchEnabled       bool     `json:"is_branch_enabled"`
	IsReadonlyModeEnabled *bool    `json:"is_readonly_mode_enabled,omitempty"`
	Name                  string   `json:"name"`
	OrganizationId        float32  `json:"organization_id"`
	PreviewBranchRefs     []string `json:"preview_branch_refs"`
	Ref                   string   `json:"ref"`
	Region                string   `json:"region"`
	Status                string   `json:"status"`
	SubscriptionId        string   `json:"subscription_id"`
}

// ProjectMetric defines model for ProjectMetric.
type ProjectMetric struct {
	Metric     string  `json:"metric"`
	ProjectRef string  `json:"project_ref"`
	Value      float32 `json:"value"`
}

// ProjectRefResponse defines model for ProjectRefResponse.
type ProjectRefResponse struct {
	Id   float32 `json:"id"`
	Name string  `json:"name"`
	Ref  string  `json:"ref"`
}

// ProjectServiceApiKeyResponse defines model for ProjectServiceApiKeyResponse.
type ProjectServiceApiKeyResponse struct {
	ApiKey string `json:"api_key"`
	Name   string `json:"name"`
	Tags   string `json:"tags"`
}

// ProjectSettingsResponse defines model for ProjectSettingsResponse.
type ProjectSettingsResponse struct {
	AppConfig      *ProjectAppConfigResponse       `json:"app_config,omitempty"`
	CloudProvider  string                          `json:"cloud_provider"`
	DbDnsName      string                          `json:"db_dns_name"`
	DbHost         string                          `json:"db_host"`
	DbName         string                          `json:"db_name"`
	DbPort         string                          `json:"db_port"`
	DbSsl          bool                            `json:"db_ssl"`
	DbUser         string                          `json:"db_user"`
	InsertedAt     string                          `json:"inserted_at"`
	JwtSecret      *string                         `json:"jwt_secret,omitempty"`
	Name           string                          `json:"name"`
	Ref            string                          `json:"ref"`
	Region         string                          `json:"region"`
	ServiceApiKeys *[]ProjectServiceApiKeyResponse `json:"service_api_keys,omitempty"`
	Status         string                          `json:"status"`
}

// PublicUrlOptions defines model for PublicUrlOptions.
type PublicUrlOptions struct {
	Download     *bool                          `json:"download,omitempty"`
	DownloadName *string                        `json:"downloadName,omitempty"`
	Transform    *StorageObjectTransformOptions `json:"transform,omitempty"`
}

// PublicUrlResponse defines model for PublicUrlResponse.
type PublicUrlResponse struct {
	PublicUrl string `json:"publicUrl"`
}

// Relationship defines model for Relationship.
type Relationship struct {
	ConstraintName    string  `json:"constraint_name"`
	Id                float32 `json:"id"`
	SourceColumnName  string  `json:"source_column_name"`
	SourceSchema      string  `json:"source_schema"`
	SourceTableName   string  `json:"source_table_name"`
	TargetColumnName  string  `json:"target_column_name"`
	TargetTableName   string  `json:"target_table_name"`
	TargetTableSchema string  `json:"target_table_schema"`
}

// ResizeBody defines model for ResizeBody.
type ResizeBody struct {
	VolumeSizeGb float32 `json:"volume_size_gb"`
}

// RestartServiceRequest defines model for RestartServiceRequest.
type RestartServiceRequest struct {
	Region               string                          `json:"region"`
	Services             []RestartServiceRequestServices `json:"services"`
	SourceNotificationId *string                         `json:"source_notification_id,omitempty"`
}

// RestartServiceRequestServices defines model for RestartServiceRequest.Services.
type RestartServiceRequestServices string

// RestartServicesBody defines model for RestartServicesBody.
type RestartServicesBody struct {
	RestartRequest RestartServiceRequest `json:"restartRequest"`
}

// RestoreLogicalBackupBody defines model for RestoreLogicalBackupBody.
type RestoreLogicalBackupBody struct {
	Id float32 `json:"id"`
}

// RestorePhysicalBackupBody defines model for RestorePhysicalBackupBody.
type RestorePhysicalBackupBody struct {
	Id                 float32 `json:"id"`
	RecoveryTimeTarget string  `json:"recovery_time_target"`
}

// RestoreProjectBody defines model for RestoreProjectBody.
type RestoreProjectBody struct {
	KpsEnabled *bool `json:"kps_enabled,omitempty"`
}

// RestoreProjectInfo defines model for RestoreProjectInfo.
type RestoreProjectInfo struct {
	BackUps        []BackupId `json:"back_ups"`
	CloudProvider  string     `json:"cloud_provider"`
	Id             float32    `json:"id"`
	OrganizationId float32    `json:"organization_id"`
	Region         string     `json:"region"`
	Status         string     `json:"status"`
	SubscriptionId string     `json:"subscription_id"`
}

// RevokeColumnPrivilegesBody defines model for RevokeColumnPrivilegesBody.
type RevokeColumnPrivilegesBody struct {
	ColumnId      string                                  `json:"column_id"`
	Grantee       string                                  `json:"grantee"`
	PrivilegeType RevokeColumnPrivilegesBodyPrivilegeType `json:"privilege_type"`
}

// RevokeColumnPrivilegesBodyPrivilegeType defines model for RevokeColumnPrivilegesBody.PrivilegeType.
type RevokeColumnPrivilegesBodyPrivilegeType string

// RevokeTablePrivilegesBody defines model for RevokeTablePrivilegesBody.
type RevokeTablePrivilegesBody struct {
	Grantee       string                                 `json:"grantee"`
	PrivilegeType RevokeTablePrivilegesBodyPrivilegeType `json:"privilege_type"`
	RelationId    float32                                `json:"relation_id"`
}

// RevokeTablePrivilegesBodyPrivilegeType defines model for RevokeTablePrivilegesBody.PrivilegeType.
type RevokeTablePrivilegesBodyPrivilegeType string

// Role defines model for Role.
type Role struct {
	Id   float32 `json:"id"`
	Name string  `json:"name"`
}

// RunQueryBody defines model for RunQueryBody.
type RunQueryBody struct {
	Query string `json:"query"`
}

// SearchColumnBody defines model for SearchColumnBody.
type SearchColumnBody struct {
	Name   string `json:"name"`
	Schema string `json:"schema"`
}

// SearchTableBody defines model for SearchTableBody.
type SearchTableBody struct {
	Name   string `json:"name"`
	Schema string `json:"schema"`
}

// SendInviteResponse defines model for SendInviteResponse.
type SendInviteResponse struct {
	InvitedAt    string  `json:"invited_at"`
	InvitedEmail string  `json:"invited_email"`
	RoleId       float32 `json:"role_id"`
}

// ServiceVersions defines model for ServiceVersions.
type ServiceVersions struct {
	Gotrue           string `json:"gotrue"`
	Postgrest        string `json:"postgrest"`
	SupabasePostgres string `json:"supabase-postgres"`
}

// SignedUrlOptions defines model for SignedUrlOptions.
type SignedUrlOptions struct {
	Download     *bool                          `json:"download,omitempty"`
	DownloadName *string                        `json:"downloadName,omitempty"`
	Transform    *StorageObjectTransformOptions `json:"transform,omitempty"`
}

// SignedUrlResponse defines model for SignedUrlResponse.
type SignedUrlResponse struct {
	SignedUrl string `json:"signedUrl"`
}

// SignedUrlsOptions defines model for SignedUrlsOptions.
type SignedUrlsOptions struct {
	Download     *bool   `json:"download,omitempty"`
	DownloadName *string `json:"downloadName,omitempty"`
}

// SignedUrlsResponse defines model for SignedUrlsResponse.
type SignedUrlsResponse struct {
	Error     *string `json:"error"`
	Path      *string `json:"path"`
	SignedUrl string  `json:"signedUrl"`
}

// StorageBucket defines model for StorageBucket.
type StorageBucket struct {
	CreatedAt string `json:"created_at"`
	Id        string `json:"id"`
	Name      string `json:"name"`
	Owner     string `json:"owner"`
	Public    bool   `json:"public"`
	UpdatedAt string `json:"updated_at"`
}

// StorageConfigResponse defines model for StorageConfigResponse.
type StorageConfigResponse struct {
	FileSizeLimit float32 `json:"fileSizeLimit"`
	IsFreeTier    bool    `json:"isFreeTier"`
}

// StorageObject defines model for StorageObject.
type StorageObject struct {
	BucketId       string                 `json:"bucket_id"`
	Buckets        StorageBucket          `json:"buckets"`
	CreatedAt      string                 `json:"created_at"`
	Id             string                 `json:"id"`
	LastAccessedAt string                 `json:"last_accessed_at"`
	Metadata       map[string]interface{} `json:"metadata"`
	Name           string                 `json:"name"`
	Owner          string                 `json:"owner"`
	UpdatedAt      string                 `json:"updated_at"`
}

// StorageObjectSearchOptions defines model for StorageObjectSearchOptions.
type StorageObjectSearchOptions struct {
	Limit  *float32             `json:"limit,omitempty"`
	Offset *float32             `json:"offset,omitempty"`
	Search *string              `json:"search,omitempty"`
	SortBy *StorageObjectSortBy `json:"sortBy,omitempty"`
}

// StorageObjectSortBy defines model for StorageObjectSortBy.
type StorageObjectSortBy struct {
	Column *string `json:"column,omitempty"`
	Order  *string `json:"order,omitempty"`
}

// StorageObjectTransformOptions defines model for StorageObjectTransformOptions.
type StorageObjectTransformOptions struct {
	Format  *StorageObjectTransformOptionsFormat `json:"format,omitempty"`
	Height  *float32                             `json:"height,omitempty"`
	Quality *float32                             `json:"quality,omitempty"`
	Resize  *StorageObjectTransformOptionsResize `json:"resize,omitempty"`
	Width   *float32                             `json:"width,omitempty"`
}

// StorageObjectTransformOptionsFormat defines model for StorageObjectTransformOptions.Format.
type StorageObjectTransformOptionsFormat string

// StorageObjectTransformOptionsResize defines model for StorageObjectTransformOptions.Resize.
type StorageObjectTransformOptionsResize string

// Table defines model for Table.
type Table struct {
	Id     float32 `json:"id"`
	Name   string  `json:"name"`
	Schema string  `json:"schema"`
}

// TablePrivilege defines model for TablePrivilege.
type TablePrivilege struct {
	Grantee       string                      `json:"grantee"`
	Grantor       string                      `json:"grantor"`
	IsGrantable   bool                        `json:"is_grantable"`
	PrivilegeType TablePrivilegePrivilegeType `json:"privilege_type"`
}

// TablePrivilegePrivilegeType defines model for TablePrivilege.PrivilegeType.
type TablePrivilegePrivilegeType string

// UpdateColumnBody defines model for UpdateColumnBody.
type UpdateColumnBody struct {
	Check              *string                             `json:"check,omitempty"`
	Comment            *string                             `json:"comment,omitempty"`
	DefaultValue       *map[string]interface{}             `json:"defaultValue,omitempty"`
	DefaultValueFormat *UpdateColumnBodyDefaultValueFormat `json:"defaultValueFormat,omitempty"`
	DropDefault        *bool                               `json:"dropDefault,omitempty"`
	Id                 *float32                            `json:"id,omitempty"`
	IdentityGeneration *UpdateColumnBodyIdentityGeneration `json:"identityGeneration,omitempty"`
	IsIdentity         *bool                               `json:"isIdentity,omitempty"`
	IsNullable         *bool                               `json:"isNullable,omitempty"`
	IsUnique           *bool                               `json:"isUnique,omitempty"`
	Name               *string                             `json:"name,omitempty"`
	Type               *string                             `json:"type,omitempty"`
}

// UpdateColumnBodyDefaultValueFormat defines model for UpdateColumnBody.DefaultValueFormat.
type UpdateColumnBodyDefaultValueFormat string

// UpdateColumnBodyIdentityGeneration defines model for UpdateColumnBody.IdentityGeneration.
type UpdateColumnBodyIdentityGeneration string

// UpdateContentParams defines model for UpdateContentParams.
type UpdateContentParams struct {
	Content     *map[string]interface{}        `json:"content,omitempty"`
	Description *string                        `json:"description,omitempty"`
	Id          *string                        `json:"id,omitempty"`
	Name        *string                        `json:"name,omitempty"`
	OwnerId     *float32                       `json:"owner_id,omitempty"`
	Type        *UpdateContentParamsType       `json:"type,omitempty"`
	Visibility  *UpdateContentParamsVisibility `json:"visibility,omitempty"`
}

// UpdateContentParamsType defines model for UpdateContentParams.Type.
type UpdateContentParamsType string

// UpdateContentParamsVisibility defines model for UpdateContentParams.Visibility.
type UpdateContentParamsVisibility string

// UpdateFunctionBody defines model for UpdateFunctionBody.
type UpdateFunctionBody struct {
	Args            *[]string                   `json:"args,omitempty"`
	Behavior        *UpdateFunctionBodyBehavior `json:"behavior,omitempty"`
	ConfigParams    *map[string]interface{}     `json:"config_params,omitempty"`
	Definition      *string                     `json:"definition,omitempty"`
	Id              *float32                    `json:"id,omitempty"`
	Language        *string                     `json:"language,omitempty"`
	Name            *string                     `json:"name,omitempty"`
	ReturnType      *string                     `json:"return_type,omitempty"`
	Schema          *string                     `json:"schema,omitempty"`
	SecurityDefiner *bool                       `json:"security_definer,omitempty"`
}

// UpdateFunctionBodyBehavior defines model for UpdateFunctionBody.Behavior.
type UpdateFunctionBodyBehavior string

// UpdateGoTrueConfigBody defines model for UpdateGoTrueConfigBody.
type UpdateGoTrueConfigBody struct {
	DISABLESIGNUP                                 *bool    `json:"DISABLE_SIGNUP,omitempty"`
	EXTERNALAPPLEADDITIONALCLIENTIDS              *string  `json:"EXTERNAL_APPLE_ADDITIONAL_CLIENT_IDS,omitempty"`
	EXTERNALAPPLECLIENTID                         *string  `json:"EXTERNAL_APPLE_CLIENT_ID,omitempty"`
	EXTERNALAPPLEENABLED                          *bool    `json:"EXTERNAL_APPLE_ENABLED,omitempty"`
	EXTERNALAPPLESECRET                           *string  `json:"EXTERNAL_APPLE_SECRET,omitempty"`
	EXTERNALAZURECLIENTID                         *string  `json:"EXTERNAL_AZURE_CLIENT_ID,omitempty"`
	EXTERNALAZUREENABLED                          *bool    `json:"EXTERNAL_AZURE_ENABLED,omitempty"`
	EXTERNALAZURESECRET                           *string  `json:"EXTERNAL_AZURE_SECRET,omitempty"`
	EXTERNALAZUREURL                              *string  `json:"EXTERNAL_AZURE_URL,omitempty"`
	EXTERNALBITBUCKETCLIENTID                     *string  `json:"EXTERNAL_BITBUCKET_CLIENT_ID,omitempty"`
	EXTERNALBITBUCKETENABLED                      *bool    `json:"EXTERNAL_BITBUCKET_ENABLED,omitempty"`
	EXTERNALBITBUCKETSECRET                       *string  `json:"EXTERNAL_BITBUCKET_SECRET,omitempty"`
	EXTERNALDISCORDCLIENTID                       *string  `json:"EXTERNAL_DISCORD_CLIENT_ID,omitempty"`
	EXTERNALDISCORDENABLED                        *bool    `json:"EXTERNAL_DISCORD_ENABLED,omitempty"`
	EXTERNALDISCORDSECRET                         *string  `json:"EXTERNAL_DISCORD_SECRET,omitempty"`
	EXTERNALEMAILENABLED                          *bool    `json:"EXTERNAL_EMAIL_ENABLED,omitempty"`
	EXTERNALFACEBOOKCLIENTID                      *string  `json:"EXTERNAL_FACEBOOK_CLIENT_ID,omitempty"`
	EXTERNALFACEBOOKENABLED                       *bool    `json:"EXTERNAL_FACEBOOK_ENABLED,omitempty"`
	EXTERNALFACEBOOKSECRET                        *string  `json:"EXTERNAL_FACEBOOK_SECRET,omitempty"`
	EXTERNALFIGMACLIENTID                         *string  `json:"EXTERNAL_FIGMA_CLIENT_ID,omitempty"`
	EXTERNALFIGMAENABLED                          *bool    `json:"EXTERNAL_FIGMA_ENABLED,omitempty"`
	EXTERNALFIGMASECRET                           *string  `json:"EXTERNAL_FIGMA_SECRET,omitempty"`
	EXTERNALGITHUBCLIENTID                        *string  `json:"EXTERNAL_GITHUB_CLIENT_ID,omitempty"`
	EXTERNALGITHUBENABLED                         *bool    `json:"EXTERNAL_GITHUB_ENABLED,omitempty"`
	EXTERNALGITHUBSECRET                          *string  `json:"EXTERNAL_GITHUB_SECRET,omitempty"`
	EXTERNALGITLABCLIENTID                        *string  `json:"EXTERNAL_GITLAB_CLIENT_ID,omitempty"`
	EXTERNALGITLABENABLED                         *bool    `json:"EXTERNAL_GITLAB_ENABLED,omitempty"`
	EXTERNALGITLABSECRET                          *string  `json:"EXTERNAL_GITLAB_SECRET,omitempty"`
	EXTERNALGITLABURL                             *string  `json:"EXTERNAL_GITLAB_URL,omitempty"`
	EXTERNALGOOGLEADDITIONALCLIENTIDS             *string  `json:"EXTERNAL_GOOGLE_ADDITIONAL_CLIENT_IDS,omitempty"`
	EXTERNALGOOGLECLIENTID                        *string  `json:"EXTERNAL_GOOGLE_CLIENT_ID,omitempty"`
	EXTERNALGOOGLEENABLED                         *bool    `json:"EXTERNAL_GOOGLE_ENABLED,omitempty"`
	EXTERNALGOOGLESECRET                          *string  `json:"EXTERNAL_GOOGLE_SECRET,omitempty"`
	EXTERNALKAKAOCLIENTID                         *string  `json:"EXTERNAL_KAKAO_CLIENT_ID,omitempty"`
	EXTERNALKAKAOENABLED                          *bool    `json:"EXTERNAL_KAKAO_ENABLED,omitempty"`
	EXTERNALKAKAOSECRET                           *string  `json:"EXTERNAL_KAKAO_SECRET,omitempty"`
	EXTERNALKEYCLOAKCLIENTID                      *string  `json:"EXTERNAL_KEYCLOAK_CLIENT_ID,omitempty"`
	EXTERNALKEYCLOAKENABLED                       *bool    `json:"EXTERNAL_KEYCLOAK_ENABLED,omitempty"`
	EXTERNALKEYCLOAKSECRET                        *string  `json:"EXTERNAL_KEYCLOAK_SECRET,omitempty"`
	EXTERNALKEYCLOAKURL                           *string  `json:"EXTERNAL_KEYCLOAK_URL,omitempty"`
	EXTERNALLINKEDINCLIENTID                      *string  `json:"EXTERNAL_LINKEDIN_CLIENT_ID,omitempty"`
	EXTERNALLINKEDINENABLED                       *bool    `json:"EXTERNAL_LINKEDIN_ENABLED,omitempty"`
	EXTERNALLINKEDINSECRET                        *string  `json:"EXTERNAL_LINKEDIN_SECRET,omitempty"`
	EXTERNALNOTIONCLIENTID                        *string  `json:"EXTERNAL_NOTION_CLIENT_ID,omitempty"`
	EXTERNALNOTIONENABLED                         *bool    `json:"EXTERNAL_NOTION_ENABLED,omitempty"`
	EXTERNALNOTIONSECRET                          *string  `json:"EXTERNAL_NOTION_SECRET,omitempty"`
	EXTERNALPHONEENABLED                          *bool    `json:"EXTERNAL_PHONE_ENABLED,omitempty"`
	EXTERNALSLACKCLIENTID                         *string  `json:"EXTERNAL_SLACK_CLIENT_ID,omitempty"`
	EXTERNALSLACKENABLED                          *bool    `json:"EXTERNAL_SLACK_ENABLED,omitempty"`
	EXTERNALSLACKSECRET                           *string  `json:"EXTERNAL_SLACK_SECRET,omitempty"`
	EXTERNALSPOTIFYCLIENTID                       *string  `json:"EXTERNAL_SPOTIFY_CLIENT_ID,omitempty"`
	EXTERNALSPOTIFYENABLED                        *bool    `json:"EXTERNAL_SPOTIFY_ENABLED,omitempty"`
	EXTERNALSPOTIFYSECRET                         *string  `json:"EXTERNAL_SPOTIFY_SECRET,omitempty"`
	EXTERNALTWITCHCLIENTID                        *string  `json:"EXTERNAL_TWITCH_CLIENT_ID,omitempty"`
	EXTERNALTWITCHENABLED                         *bool    `json:"EXTERNAL_TWITCH_ENABLED,omitempty"`
	EXTERNALTWITCHSECRET                          *string  `json:"EXTERNAL_TWITCH_SECRET,omitempty"`
	EXTERNALTWITTERCLIENTID                       *string  `json:"EXTERNAL_TWITTER_CLIENT_ID,omitempty"`
	EXTERNALTWITTERENABLED                        *bool    `json:"EXTERNAL_TWITTER_ENABLED,omitempty"`
	EXTERNALTWITTERSECRET                         *string  `json:"EXTERNAL_TWITTER_SECRET,omitempty"`
	EXTERNALWORKOSCLIENTID                        *string  `json:"EXTERNAL_WORKOS_CLIENT_ID,omitempty"`
	EXTERNALWORKOSENABLED                         *bool    `json:"EXTERNAL_WORKOS_ENABLED,omitempty"`
	EXTERNALWORKOSSECRET                          *string  `json:"EXTERNAL_WORKOS_SECRET,omitempty"`
	EXTERNALWORKOSURL                             *string  `json:"EXTERNAL_WORKOS_URL,omitempty"`
	EXTERNALZOOMCLIENTID                          *string  `json:"EXTERNAL_ZOOM_CLIENT_ID,omitempty"`
	EXTERNALZOOMENABLED                           *bool    `json:"EXTERNAL_ZOOM_ENABLED,omitempty"`
	EXTERNALZOOMSECRET                            *string  `json:"EXTERNAL_ZOOM_SECRET,omitempty"`
	JWTEXP                                        *float32 `json:"JWT_EXP,omitempty"`
	MAILERAUTOCONFIRM                             *bool    `json:"MAILER_AUTOCONFIRM,omitempty"`
	MAILEROTPEXP                                  *float32 `json:"MAILER_OTP_EXP,omitempty"`
	MAILERSECUREEMAILCHANGEENABLED                *bool    `json:"MAILER_SECURE_EMAIL_CHANGE_ENABLED,omitempty"`
	MAILERSUBJECTSCONFIRMATION                    *string  `json:"MAILER_SUBJECTS_CONFIRMATION,omitempty"`
	MAILERSUBJECTSEMAILCHANGE                     *string  `json:"MAILER_SUBJECTS_EMAIL_CHANGE,omitempty"`
	MAILERSUBJECTSINVITE                          *string  `json:"MAILER_SUBJECTS_INVITE,omitempty"`
	MAILERSUBJECTSMAGICLINK                       *string  `json:"MAILER_SUBJECTS_MAGIC_LINK,omitempty"`
	MAILERSUBJECTSRECOVERY                        *string  `json:"MAILER_SUBJECTS_RECOVERY,omitempty"`
	MAILERTEMPLATESCONFIRMATIONCONTENT            *string  `json:"MAILER_TEMPLATES_CONFIRMATION_CONTENT,omitempty"`
	MAILERTEMPLATESEMAILCHANGECONTENT             *string  `json:"MAILER_TEMPLATES_EMAIL_CHANGE_CONTENT,omitempty"`
	MAILERTEMPLATESINVITECONTENT                  *string  `json:"MAILER_TEMPLATES_INVITE_CONTENT,omitempty"`
	MAILERTEMPLATESMAGICLINKCONTENT               *string  `json:"MAILER_TEMPLATES_MAGIC_LINK_CONTENT,omitempty"`
	MAILERTEMPLATESRECOVERYCONTENT                *string  `json:"MAILER_TEMPLATES_RECOVERY_CONTENT,omitempty"`
	MFAMAXENROLLEDFACTORS                         *float32 `json:"MFA_MAX_ENROLLED_FACTORS,omitempty"`
	PASSWORDMINLENGTH                             *float32 `json:"PASSWORD_MIN_LENGTH,omitempty"`
	RATELIMITEMAILSENT                            *float32 `json:"RATE_LIMIT_EMAIL_SENT,omitempty"`
	RATELIMITSMSSENT                              *float32 `json:"RATE_LIMIT_SMS_SENT,omitempty"`
	REFRESHTOKENROTATIONENABLED                   *bool    `json:"REFRESH_TOKEN_ROTATION_ENABLED,omitempty"`
	SAMLENABLED                                   *bool    `json:"SAML_ENABLED,omitempty"`
	SECURITYCAPTCHAENABLED                        *bool    `json:"SECURITY_CAPTCHA_ENABLED,omitempty"`
	SECURITYCAPTCHAPROVIDER                       *string  `json:"SECURITY_CAPTCHA_PROVIDER,omitempty"`
	SECURITYCAPTCHASECRET                         *string  `json:"SECURITY_CAPTCHA_SECRET,omitempty"`
	SECURITYREFRESHTOKENREUSEINTERVAL             *float32 `json:"SECURITY_REFRESH_TOKEN_REUSE_INTERVAL,omitempty"`
	SECURITYUPDATEPASSWORDREQUIREREAUTHENTICATION *bool    `json:"SECURITY_UPDATE_PASSWORD_REQUIRE_REAUTHENTICATION,omitempty"`
	SITEURL                                       *string  `json:"SITE_URL,omitempty"`
	SMSAUTOCONFIRM                                *bool    `json:"SMS_AUTOCONFIRM,omitempty"`
	SMSMAXFREQUENCY                               *float32 `json:"SMS_MAX_FREQUENCY,omitempty"`
	SMSMESSAGEBIRDACCESSKEY                       *string  `json:"SMS_MESSAGEBIRD_ACCESS_KEY,omitempty"`
	SMSMESSAGEBIRDORIGINATOR                      *string  `json:"SMS_MESSAGEBIRD_ORIGINATOR,omitempty"`
	SMSOTPEXP                                     *float32 `json:"SMS_OTP_EXP,omitempty"`
	SMSOTPLENGTH                                  *float32 `json:"SMS_OTP_LENGTH,omitempty"`
	SMSPROVIDER                                   *string  `json:"SMS_PROVIDER,omitempty"`
	SMSTEMPLATE                                   *string  `json:"SMS_TEMPLATE,omitempty"`
	SMSTESTOTP                                    *string  `json:"SMS_TEST_OTP,omitempty"`
	SMSTESTOTPVALIDUNTIL                          *string  `json:"SMS_TEST_OTP_VALID_UNTIL,omitempty"`
	SMSTEXTLOCALAPIKEY                            *string  `json:"SMS_TEXTLOCAL_API_KEY,omitempty"`
	SMSTEXTLOCALSENDER                            *string  `json:"SMS_TEXTLOCAL_SENDER,omitempty"`
	SMSTWILIOACCOUNTSID                           *string  `json:"SMS_TWILIO_ACCOUNT_SID,omitempty"`
	SMSTWILIOAUTHTOKEN                            *string  `json:"SMS_TWILIO_AUTH_TOKEN,omitempty"`
	SMSTWILIOMESSAGESERVICESID                    *string  `json:"SMS_TWILIO_MESSAGE_SERVICE_SID,omitempty"`
	SMSTWILIOVERIFYACCOUNTSID                     *string  `json:"SMS_TWILIO_VERIFY_ACCOUNT_SID,omitempty"`
	SMSTWILIOVERIFYAUTHTOKEN                      *string  `json:"SMS_TWILIO_VERIFY_AUTH_TOKEN,omitempty"`
	SMSTWILIOVERIFYMESSAGESERVICESID              *string  `json:"SMS_TWILIO_VERIFY_MESSAGE_SERVICE_SID,omitempty"`
	SMSVONAGEAPIKEY                               *string  `json:"SMS_VONAGE_API_KEY,omitempty"`
	SMSVONAGEAPISECRET                            *string  `json:"SMS_VONAGE_API_SECRET,omitempty"`
	SMSVONAGEFROM                                 *string  `json:"SMS_VONAGE_FROM,omitempty"`
	SMTPADMINEMAIL                                *string  `json:"SMTP_ADMIN_EMAIL,omitempty"`
	SMTPHOST                                      *string  `json:"SMTP_HOST,omitempty"`
	SMTPMAXFREQUENCY                              *float32 `json:"SMTP_MAX_FREQUENCY,omitempty"`
	SMTPPASS                                      *string  `json:"SMTP_PASS"`
	SMTPPASSENCRYPTED                             *string  `json:"SMTP_PASS_ENCRYPTED"`
	SMTPPORT                                      *string  `json:"SMTP_PORT,omitempty"`
	SMTPSENDERNAME                                *string  `json:"SMTP_SENDER_NAME,omitempty"`
	SMTPUSER                                      *string  `json:"SMTP_USER,omitempty"`
	URIALLOWLIST                                  *string  `json:"URI_ALLOW_LIST,omitempty"`
}

// UpdateMemberBody defines model for UpdateMemberBody.
type UpdateMemberBody struct {
	RoleId float32 `json:"role_id"`
}

// UpdateNotificationsBodyV1 defines model for UpdateNotificationsBodyV1.
type UpdateNotificationsBodyV1 struct {
	Ids []string `json:"ids"`
}

// UpdateOrganizationBody defines model for UpdateOrganizationBody.
type UpdateOrganizationBody struct {
	BillingEmail string   `json:"billing_email"`
	Name         string   `json:"name"`
	OptInTags    []string `json:"opt_in_tags"`
}

// UpdatePasswordBody defines model for UpdatePasswordBody.
type UpdatePasswordBody struct {
	Password string `json:"password"`
}

// UpdatePgbouncerConfigBody defines model for UpdatePgbouncerConfigBody.
type UpdatePgbouncerConfigBody struct {
	DefaultPoolSize         *int                              `json:"default_pool_size,omitempty"`
	IgnoreStartupParameters string                            `json:"ignore_startup_parameters"`
	MaxClientConn           *int                              `json:"max_client_conn"`
	PgbouncerEnabled        bool                              `json:"pgbouncer_enabled"`
	PoolMode                UpdatePgbouncerConfigBodyPoolMode `json:"pool_mode"`
}

// UpdatePgbouncerConfigBodyPoolMode defines model for UpdatePgbouncerConfigBody.PoolMode.
type UpdatePgbouncerConfigBodyPoolMode string

// UpdatePolicyBody defines model for UpdatePolicyBody.
type UpdatePolicyBody struct {
	Check      *string   `json:"check,omitempty"`
	Definition *string   `json:"definition,omitempty"`
	Id         *float32  `json:"id,omitempty"`
	Name       *string   `json:"name,omitempty"`
	Roles      *[]string `json:"roles,omitempty"`
}

// UpdatePoolingConfigResponse defines model for UpdatePoolingConfigResponse.
type UpdatePoolingConfigResponse struct {
	DefaultPoolSize         *int                                       `json:"default_pool_size,omitempty"`
	IgnoreStartupParameters string                                     `json:"ignore_startup_parameters"`
	MaxClientConn           *int                                       `json:"max_client_conn"`
	PgbouncerEnabled        bool                                       `json:"pgbouncer_enabled"`
	PgbouncerStatus         UpdatePoolingConfigResponsePgbouncerStatus `json:"pgbouncer_status"`
	PoolMode                UpdatePoolingConfigResponsePoolMode        `json:"pool_mode"`
}

// UpdatePoolingConfigResponsePgbouncerStatus defines model for UpdatePoolingConfigResponse.PgbouncerStatus.
type UpdatePoolingConfigResponsePgbouncerStatus string

// UpdatePoolingConfigResponsePoolMode defines model for UpdatePoolingConfigResponse.PoolMode.
type UpdatePoolingConfigResponsePoolMode string

// UpdatePostgresConfigBody defines model for UpdatePostgresConfigBody.
type UpdatePostgresConfigBody struct {
	EffectiveCacheSize            *string                                         `json:"effective_cache_size,omitempty"`
	MaintenanceWorkMem            *string                                         `json:"maintenance_work_mem,omitempty"`
	MaxConnections                *int                                            `json:"max_connections,omitempty"`
	MaxParallelMaintenanceWorkers *int                                            `json:"max_parallel_maintenance_workers,omitempty"`
	MaxParallelWorkers            *int                                            `json:"max_parallel_workers,omitempty"`
	MaxParallelWorkersPerGather   *int                                            `json:"max_parallel_workers_per_gather,omitempty"`
	MaxWorkerProcesses            *int                                            `json:"max_worker_processes,omitempty"`
	SessionReplicationRole        *UpdatePostgresConfigBodySessionReplicationRole `json:"session_replication_role,omitempty"`
	SharedBuffers                 *string                                         `json:"shared_buffers,omitempty"`
	StatementTimeout              *string                                         `json:"statement_timeout,omitempty"`
	WorkMem                       *string                                         `json:"work_mem,omitempty"`
}

// UpdatePostgresConfigBodySessionReplicationRole defines model for UpdatePostgresConfigBody.SessionReplicationRole.
type UpdatePostgresConfigBodySessionReplicationRole string

// UpdatePostgrestConfigBody defines model for UpdatePostgrestConfigBody.
type UpdatePostgrestConfigBody struct {
	DbExtraSearchPath *string `json:"db_extra_search_path,omitempty"`
	DbSchema          *string `json:"db_schema,omitempty"`
	MaxRows           *int    `json:"max_rows,omitempty"`
}

// UpdateProjectBody defines model for UpdateProjectBody.
type UpdateProjectBody struct {
	Name string `json:"name"`
}

// UpdatePublicationBody defines model for UpdatePublicationBody.
type UpdatePublicationBody struct {
	Id              *float32  `json:"id,omitempty"`
	Name            *string   `json:"name,omitempty"`
	Owner           *string   `json:"owner,omitempty"`
	PublishDelete   *bool     `json:"publish_delete,omitempty"`
	PublishInsert   *bool     `json:"publish_insert,omitempty"`
	PublishTruncate *bool     `json:"publish_truncate,omitempty"`
	PublishUpdate   *bool     `json:"publish_update,omitempty"`
	Tables          *[]string `json:"tables"`
}

// UpdateRoleBody defines model for UpdateRoleBody.
type UpdateRoleBody struct {
	CanBypassRls      *bool                   `json:"can_bypass_rls,omitempty"`
	CanCreateDb       *bool                   `json:"can_create_db,omitempty"`
	CanCreateRole     *bool                   `json:"can_create_role,omitempty"`
	CanLogin          *bool                   `json:"can_login,omitempty"`
	Config            *map[string]interface{} `json:"config,omitempty"`
	ConnectionLimit   *float32                `json:"connection_limit,omitempty"`
	InheritRole       *bool                   `json:"inherit_role,omitempty"`
	IsReplicationRole *bool                   `json:"is_replication_role,omitempty"`
	IsSuperuser       *bool                   `json:"is_superuser,omitempty"`
	Name              *string                 `json:"name,omitempty"`
	Password          *string                 `json:"password,omitempty"`
	ValidUntil        *string                 `json:"valid_until,omitempty"`
}

// UpdateSchemaBody defines model for UpdateSchemaBody.
type UpdateSchemaBody struct {
	Name  *string `json:"name,omitempty"`
	Owner *string `json:"owner,omitempty"`
}

// UpdateSecretsConfigBody defines model for UpdateSecretsConfigBody.
type UpdateSecretsConfigBody struct {
	ChangeTrackingId string `json:"change_tracking_id"`
	JwtSecret        string `json:"jwt_secret"`
}

// UpdateSecretsResponse defines model for UpdateSecretsResponse.
type UpdateSecretsResponse struct {
	Message string `json:"message"`
}

// UpdateStorageBucketBody defines model for UpdateStorageBucketBody.
type UpdateStorageBucketBody struct {
	AllowedMimeTypes []string `json:"allowed_mime_types"`
	FileSizeLimit    float32  `json:"file_size_limit"`
	Public           bool     `json:"public"`
}

// UpdateStorageConfigBody defines model for UpdateStorageConfigBody.
type UpdateStorageConfigBody struct {
	FileSizeLimit float32 `json:"fileSizeLimit"`
}

// UpdateStorageConfigResponse defines model for UpdateStorageConfigResponse.
type UpdateStorageConfigResponse struct {
	FileSizeLimit float32 `json:"fileSizeLimit"`
}

// UpdateTableBody defines model for UpdateTableBody.
type UpdateTableBody struct {
	Comment              *string                         `json:"comment,omitempty"`
	Id                   *float32                        `json:"id,omitempty"`
	Name                 *string                         `json:"name,omitempty"`
	ReplicaIdentity      *UpdateTableBodyReplicaIdentity `json:"replica_identity,omitempty"`
	ReplicaIdentityIndex *string                         `json:"replica_identity_index,omitempty"`
	RlsEnabled           *bool                           `json:"rls_enabled,omitempty"`
	RlsForced            *bool                           `json:"rls_forced,omitempty"`
	Schema               *string                         `json:"schema,omitempty"`
}

// UpdateTableBodyReplicaIdentity defines model for UpdateTableBody.ReplicaIdentity.
type UpdateTableBodyReplicaIdentity string

// UpdateTriggerBody defines model for UpdateTriggerBody.
type UpdateTriggerBody struct {
	Activation     *UpdateTriggerBodyActivation  `json:"activation,omitempty"`
	EnabledMode    *UpdateTriggerBodyEnabledMode `json:"enabled_mode,omitempty"`
	Events         *[]UpdateTriggerBodyEvents    `json:"events,omitempty"`
	FunctionArgs   *[]string                     `json:"function_args,omitempty"`
	FunctionName   *string                       `json:"function_name,omitempty"`
	FunctionSchema *string                       `json:"function_schema,omitempty"`
	Id             *float32                      `json:"id,omitempty"`
	Name           *string                       `json:"name,omitempty"`
	Orientation    *UpdateTriggerBodyOrientation `json:"orientation,omitempty"`
	Schema         *string                       `json:"schema,omitempty"`
	Table          *string                       `json:"table,omitempty"`
	TableId        *float32                      `json:"table_id,omitempty"`
}

// UpdateTriggerBodyActivation defines model for UpdateTriggerBody.Activation.
type UpdateTriggerBodyActivation string

// UpdateTriggerBodyEnabledMode defines model for UpdateTriggerBody.EnabledMode.
type UpdateTriggerBodyEnabledMode string

// UpdateTriggerBodyEvents defines model for UpdateTriggerBody.Events.
type UpdateTriggerBodyEvents string

// UpdateTriggerBodyOrientation defines model for UpdateTriggerBody.Orientation.
type UpdateTriggerBodyOrientation string

// UpsertContentParams defines model for UpsertContentParams.
type UpsertContentParams struct {
	Content     *map[string]interface{}       `json:"content,omitempty"`
	Description string                        `json:"description"`
	Id          string                        `json:"id"`
	Name        string                        `json:"name"`
	OwnerId     *float32                      `json:"owner_id,omitempty"`
	ProjectId   float32                       `json:"project_id"`
	Type        UpsertContentParamsType       `json:"type"`
	Visibility  UpsertContentParamsVisibility `json:"visibility"`
}

// UpsertContentParamsType defines model for UpsertContentParams.Type.
type UpsertContentParamsType string

// UpsertContentParamsVisibility defines model for UpsertContentParams.Visibility.
type UpsertContentParamsVisibility string

// UsageStatus defines model for UsageStatus.
type UsageStatus struct {
	AvailableInPlan bool    `json:"available_in_plan"`
	Cost            float32 `json:"cost"`
	Limit           float32 `json:"limit"`
	Usage           float32 `json:"usage"`
}

// UsageStatusResponse defines model for UsageStatusResponse.
type UsageStatusResponse struct {
	DbEgress                UsageStatus `json:"db_egress"`
	DbSize                  UsageStatus `json:"db_size"`
	DiskVolumeSizeGb        float32     `json:"disk_volume_size_gb"`
	FuncCount               UsageStatus `json:"func_count"`
	FuncInvocations         UsageStatus `json:"func_invocations"`
	MonthlyActiveSsoUsers   UsageStatus `json:"monthly_active_sso_users"`
	MonthlyActiveUsers      UsageStatus `json:"monthly_active_users"`
	RealtimeMessageCount    UsageStatus `json:"realtime_message_count"`
	RealtimePeakConnection  UsageStatus `json:"realtime_peak_connection"`
	StorageEgress           UsageStatus `json:"storage_egress"`
	StorageImageRenderCount UsageStatus `json:"storage_image_render_count"`
	StorageSize             UsageStatus `json:"storage_size"`
}

// UserBody defines model for UserBody.
type UserBody struct {
	Aud                      *string                 `json:"aud,omitempty"`
	BannedUntil              *string                 `json:"banned_until,omitempty"`
	ConfirmationSentAt       *string                 `json:"confirmation_sent_at,omitempty"`
	ConfirmationToken        *string                 `json:"confirmation_token,omitempty"`
	ConfirmedAt              *string                 `json:"confirmed_at,omitempty"`
	CreatedAt                *string                 `json:"created_at,omitempty"`
	DeletedAt                *string                 `json:"deleted_at,omitempty"`
	Email                    *string                 `json:"email,omitempty"`
	EmailChange              *string                 `json:"email_change,omitempty"`
	EmailChangeConfirmStatus *float32                `json:"email_change_confirm_status,omitempty"`
	EmailChangeSentAt        *string                 `json:"email_change_sent_at,omitempty"`
	EmailChangeTokenCurrent  *string                 `json:"email_change_token_current,omitempty"`
	EmailChangeTokenNew      *string                 `json:"email_change_token_new,omitempty"`
	EmailConfirmedAt         *string                 `json:"email_confirmed_at,omitempty"`
	EncryptedPassword        *string                 `json:"encrypted_password,omitempty"`
	Id                       *string                 `json:"id,omitempty"`
	InstanceId               *string                 `json:"instance_id,omitempty"`
	InvitedAt                *string                 `json:"invited_at,omitempty"`
	IsSsoUser                *bool                   `json:"is_sso_user,omitempty"`
	IsSuperAdmin             *bool                   `json:"is_super_admin,omitempty"`
	LastSignInAt             *string                 `json:"last_sign_in_at,omitempty"`
	Phone                    *string                 `json:"phone,omitempty"`
	PhoneChange              *string                 `json:"phone_change,omitempty"`
	PhoneChangeSentAt        *string                 `json:"phone_change_sent_at,omitempty"`
	PhoneChangeToken         *string                 `json:"phone_change_token,omitempty"`
	PhoneConfirmedAt         *string                 `json:"phone_confirmed_at,omitempty"`
	RawAppMetaData           *map[string]interface{} `json:"raw_app_meta_data,omitempty"`
	RawUserMetaData          *map[string]interface{} `json:"raw_user_meta_data,omitempty"`
	ReauthenticationSentAt   *string                 `json:"reauthentication_sent_at,omitempty"`
	ReauthenticationToken    *string                 `json:"reauthentication_token,omitempty"`
	RecoverySentAt           *string                 `json:"recovery_sent_at,omitempty"`
	RecoveryToken            *string                 `json:"recovery_token,omitempty"`
	Role                     *string                 `json:"role,omitempty"`
	UpdatedAt                *string                 `json:"updated_at,omitempty"`
}

// UserContentObject defines model for UserContentObject.
type UserContentObject struct {
	Description   *string                `json:"description,omitempty"`
	Id            string                 `json:"id"`
	InsertedAt    string                 `json:"inserted_at"`
	LastUpdatedBy float32                `json:"last_updated_by"`
	Name          string                 `json:"name"`
	OwnerId       float32                `json:"owner_id"`
	ProjectId     float32                `json:"project_id"`
	Type          map[string]interface{} `json:"type"`
	UpdatedAt     string                 `json:"updated_at"`
	Visibility    map[string]interface{} `json:"visibility"`
}

// UsersResponse defines model for UsersResponse.
type UsersResponse struct {
	Total float32    `json:"total"`
	Users []UserBody `json:"users"`
}

// ValidateQueryBody defines model for ValidateQueryBody.
type ValidateQueryBody struct {
	Query string `json:"query"`
}

// ValidateQueryResponse defines model for ValidateQueryResponse.
type ValidateQueryResponse struct {
	Valid bool `json:"valid"`
}

// GetTemplateParamsTemplate defines parameters for GetTemplate.
type GetTemplateParamsTemplate string

// GetUsersParams defines parameters for GetUsers.
type GetUsersParams struct {
	Keywords string `form:"keywords" json:"keywords"`
	Limit    string `form:"limit" json:"limit"`
	Offset   string `form:"offset" json:"offset"`
	Verified string `form:"verified" json:"verified"`
}

// GetHookLogsParams defines parameters for GetHookLogs.
type GetHookLogsParams struct {
	Id                   float32 `form:"id" json:"id"`
	Limit                *string `form:"limit,omitempty" json:"limit,omitempty"`
	Offset               *string `form:"offset,omitempty" json:"offset,omitempty"`
	XConnectionEncrypted string  `json:"x-connection-encrypted"`
}

// GetNotificationsV2Params defines parameters for GetNotificationsV2.
type GetNotificationsV2Params struct {
	Archived *bool   `form:"archived,omitempty" json:"archived,omitempty"`
	Offset   float32 `form:"offset" json:"offset"`
	Limit    float32 `form:"limit" json:"limit"`
}

// UpdateNotificationsV2JSONBody defines parameters for UpdateNotificationsV2.
type UpdateNotificationsV2JSONBody = []string

// DeleteInvitedUserParams defines parameters for DeleteInvitedUser.
type DeleteInvitedUserParams struct {
	InvitedId float32 `form:"invited_id" json:"invited_id"`
}

// GetInviteParams defines parameters for GetInvite.
type GetInviteParams struct {
	Token string `form:"token" json:"token"`
}

// JoinOrganizationParams defines parameters for JoinOrganization.
type JoinOrganizationParams struct {
	Token string `form:"token" json:"token"`
}

// RevokeColumnPrivilegesJSONBody defines parameters for RevokeColumnPrivileges.
type RevokeColumnPrivilegesJSONBody = []RevokeColumnPrivilegesBody

// RevokeColumnPrivilegesParams defines parameters for RevokeColumnPrivileges.
type RevokeColumnPrivilegesParams struct {
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// GetColumnPrivilegesParams defines parameters for GetColumnPrivileges.
type GetColumnPrivilegesParams struct {
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// GrantColumnPrivilegesJSONBody defines parameters for GrantColumnPrivileges.
type GrantColumnPrivilegesJSONBody = []GrantColumnPrivilegesBody

// GrantColumnPrivilegesParams defines parameters for GrantColumnPrivileges.
type GrantColumnPrivilegesParams struct {
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// DeleteColumnParams defines parameters for DeleteColumn.
type DeleteColumnParams struct {
	// Id Column ID
	Id                   string  `form:"id" json:"id"`
	Cascade              *string `form:"cascade,omitempty" json:"cascade,omitempty"`
	XConnectionEncrypted string  `json:"x-connection-encrypted"`
}

// GetColumnsParams defines parameters for GetColumns.
type GetColumnsParams struct {
	IncludedSchemas      string `form:"included_schemas" json:"included_schemas"`
	ExcludedSchemas      string `form:"excluded_schemas" json:"excluded_schemas"`
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// UpdateColumnParams defines parameters for UpdateColumn.
type UpdateColumnParams struct {
	// Id Column ID
	Id                   string `form:"id" json:"id"`
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// CreateColumnParams defines parameters for CreateColumn.
type CreateColumnParams struct {
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// DeleteExtensionParams defines parameters for DeleteExtension.
type DeleteExtensionParams struct {
	// Id Extension ID
	Id                   string `form:"id" json:"id"`
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// GetExtensionsParams defines parameters for GetExtensions.
type GetExtensionsParams struct {
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// CreateExtensionParams defines parameters for CreateExtension.
type CreateExtensionParams struct {
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// GetForeignTablesParams defines parameters for GetForeignTables.
type GetForeignTablesParams struct {
	Id                   string `form:"id" json:"id"`
	Limit                string `form:"limit" json:"limit"`
	Offset               string `form:"offset" json:"offset"`
	IncludeColumns       string `form:"include_columns" json:"include_columns"`
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// DeleteFunctionParams defines parameters for DeleteFunction.
type DeleteFunctionParams struct {
	// Id Function ID
	Id                   float32 `form:"id" json:"id"`
	XConnectionEncrypted string  `json:"x-connection-encrypted"`
}

// GetFunctionsParams defines parameters for GetFunctions.
type GetFunctionsParams struct {
	IncludedSchemas      string `form:"included_schemas" json:"included_schemas"`
	ExcludedSchemas      string `form:"excluded_schemas" json:"excluded_schemas"`
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// UpdateFunctionParams defines parameters for UpdateFunction.
type UpdateFunctionParams struct {
	// Id Function ID
	Id                   float32 `form:"id" json:"id"`
	XConnectionEncrypted string  `json:"x-connection-encrypted"`
}

// CreateFunctionParams defines parameters for CreateFunction.
type CreateFunctionParams struct {
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// GetMaterializedViewsParams defines parameters for GetMaterializedViews.
type GetMaterializedViewsParams struct {
	Id                   string `form:"id" json:"id"`
	IncludedSchemas      string `form:"included_schemas" json:"included_schemas"`
	ExcludedSchemas      string `form:"excluded_schemas" json:"excluded_schemas"`
	Limit                string `form:"limit" json:"limit"`
	Offset               string `form:"offset" json:"offset"`
	IncludeColumns       string `form:"include_columns" json:"include_columns"`
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// DeletePolicyParams defines parameters for DeletePolicy.
type DeletePolicyParams struct {
	// Id Policy ID
	Id                   float32 `form:"id" json:"id"`
	XConnectionEncrypted string  `json:"x-connection-encrypted"`
}

// GetPoliciesParams defines parameters for GetPolicies.
type GetPoliciesParams struct {
	IncludedSchemas      string `form:"included_schemas" json:"included_schemas"`
	ExcludedSchemas      string `form:"excluded_schemas" json:"excluded_schemas"`
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// UpdatePolicyParams defines parameters for UpdatePolicy.
type UpdatePolicyParams struct {
	// Id Policy ID
	Id                   float32 `form:"id" json:"id"`
	XConnectionEncrypted string  `json:"x-connection-encrypted"`
}

// CreatePolicyParams defines parameters for CreatePolicy.
type CreatePolicyParams struct {
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// DeletePublicationParams defines parameters for DeletePublication.
type DeletePublicationParams struct {
	// Id Publication ID
	Id                   float32 `form:"id" json:"id"`
	XConnectionEncrypted string  `json:"x-connection-encrypted"`
}

// GetPublicationsParams defines parameters for GetPublications.
type GetPublicationsParams struct {
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// UpdatePublicationParams defines parameters for UpdatePublication.
type UpdatePublicationParams struct {
	// Id Publication ID
	Id                   float32 `form:"id" json:"id"`
	XConnectionEncrypted string  `json:"x-connection-encrypted"`
}

// CreatePublicationParams defines parameters for CreatePublication.
type CreatePublicationParams struct {
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// RunQueryParams defines parameters for RunQuery.
type RunQueryParams struct {
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// DeleteRoleParams defines parameters for DeleteRole.
type DeleteRoleParams struct {
	// Id Role ID
	Id                   string `form:"id" json:"id"`
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// GetRolesParams defines parameters for GetRoles.
type GetRolesParams struct {
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// UpdateRoleParams defines parameters for UpdateRole.
type UpdateRoleParams struct {
	// Id Role ID
	Id                   float32 `form:"id" json:"id"`
	XConnectionEncrypted string  `json:"x-connection-encrypted"`
}

// CreateRoleParams defines parameters for CreateRole.
type CreateRoleParams struct {
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// DeleteSchemaParams defines parameters for DeleteSchema.
type DeleteSchemaParams struct {
	// Id Schema ID
	Id                   float32 `form:"id" json:"id"`
	XConnectionEncrypted string  `json:"x-connection-encrypted"`
}

// GetSchemasParams defines parameters for GetSchemas.
type GetSchemasParams struct {
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// UpdateSchemaParams defines parameters for UpdateSchema.
type UpdateSchemaParams struct {
	// Id Schema ID
	Id                   float32 `form:"id" json:"id"`
	XConnectionEncrypted string  `json:"x-connection-encrypted"`
}

// CreateSchemaParams defines parameters for CreateSchema.
type CreateSchemaParams struct {
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// SearchColumnsParams defines parameters for SearchColumns.
type SearchColumnsParams struct {
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// SearchTablesParams defines parameters for SearchTables.
type SearchTablesParams struct {
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// RevokeTablePrivilegesJSONBody defines parameters for RevokeTablePrivileges.
type RevokeTablePrivilegesJSONBody = []RevokeTablePrivilegesBody

// RevokeTablePrivilegesParams defines parameters for RevokeTablePrivileges.
type RevokeTablePrivilegesParams struct {
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// GetTablePrivilegesParams defines parameters for GetTablePrivileges.
type GetTablePrivilegesParams struct {
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// GrantTablePrivilegesJSONBody defines parameters for GrantTablePrivileges.
type GrantTablePrivilegesJSONBody = []GrantTablePrivilegesBody

// GrantTablePrivilegesParams defines parameters for GrantTablePrivileges.
type GrantTablePrivilegesParams struct {
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// DeleteTableParams defines parameters for DeleteTable.
type DeleteTableParams struct {
	// Id Table ID
	Id                   float32 `form:"id" json:"id"`
	Cascade              bool    `form:"cascade" json:"cascade"`
	XConnectionEncrypted string  `json:"x-connection-encrypted"`
}

// GetTablesParams defines parameters for GetTables.
type GetTablesParams struct {
	// Id Table ID
	Id                   *string `form:"id,omitempty" json:"id,omitempty"`
	IncludeSystemSchemas string  `form:"include_system_schemas" json:"include_system_schemas"`
	IncludedSchemas      string  `form:"included_schemas" json:"included_schemas"`
	ExcludedSchemas      string  `form:"excluded_schemas" json:"excluded_schemas"`
	Limit                string  `form:"limit" json:"limit"`
	Offset               string  `form:"offset" json:"offset"`
	IncludeColumns       string  `form:"include_columns" json:"include_columns"`
	XConnectionEncrypted string  `json:"x-connection-encrypted"`
}

// UpdateTableParams defines parameters for UpdateTable.
type UpdateTableParams struct {
	// Id Table ID
	Id                   float32 `form:"id" json:"id"`
	XConnectionEncrypted string  `json:"x-connection-encrypted"`
}

// CreateTableParams defines parameters for CreateTable.
type CreateTableParams struct {
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// DeleteTriggerParams defines parameters for DeleteTrigger.
type DeleteTriggerParams struct {
	// Id Trigger ID
	Id                   float32 `form:"id" json:"id"`
	XConnectionEncrypted string  `json:"x-connection-encrypted"`
}

// GetTriggersParams defines parameters for GetTriggers.
type GetTriggersParams struct {
	IncludedSchemas      string `form:"included_schemas" json:"included_schemas"`
	ExcludedSchemas      string `form:"excluded_schemas" json:"excluded_schemas"`
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// UpdateTriggerParams defines parameters for UpdateTrigger.
type UpdateTriggerParams struct {
	// Id Trigger ID
	Id                   float32 `form:"id" json:"id"`
	XConnectionEncrypted string  `json:"x-connection-encrypted"`
}

// CreateTriggerParams defines parameters for CreateTrigger.
type CreateTriggerParams struct {
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// GetTypesParams defines parameters for GetTypes.
type GetTypesParams struct {
	IncludedSchemas      string `form:"included_schemas" json:"included_schemas"`
	ExcludedSchemas      string `form:"excluded_schemas" json:"excluded_schemas"`
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// GetViewsParams defines parameters for GetViews.
type GetViewsParams struct {
	Id                   string `form:"id" json:"id"`
	IncludeSystemSchemas string `form:"include_system_schemas" json:"include_system_schemas"`
	IncludedSchemas      string `form:"included_schemas" json:"included_schemas"`
	ExcludedSchemas      string `form:"excluded_schemas" json:"excluded_schemas"`
	Limit                string `form:"limit" json:"limit"`
	Offset               string `form:"offset" json:"offset"`
	IncludeColumns       string `form:"include_columns" json:"include_columns"`
	XConnectionEncrypted string `json:"x-connection-encrypted"`
}

// GetProjectsParams defines parameters for GetProjects.
type GetProjectsParams struct {
	IncludeReadonlyModeStatus bool `form:"include_readonly_mode_status" json:"include_readonly_mode_status"`
}

// GetFunctionStatusParams defines parameters for GetFunctionStatus.
type GetFunctionStatusParams struct {
	Interval   GetFunctionStatusParamsInterval `form:"interval" json:"interval"`
	FunctionId string                          `form:"function_id" json:"function_id"`
}

// GetFunctionStatusParamsInterval defines parameters for GetFunctionStatus.
type GetFunctionStatusParamsInterval string

// GetApiPathsParams defines parameters for GetApiPaths.
type GetApiPathsParams struct {
	Sql               string `form:"sql" json:"sql"`
	Project           string `form:"project" json:"project"`
	IsoTimestampStart string `form:"iso_timestamp_start" json:"iso_timestamp_start"`
	IsoTimestampEnd   string `form:"iso_timestamp_end" json:"iso_timestamp_end"`
	TimestampStart    string `form:"timestamp_start" json:"timestamp_start"`
	TimestampEnd      string `form:"timestamp_end" json:"timestamp_end"`
}

// GetApiCountsParams defines parameters for GetApiCounts.
type GetApiCountsParams struct {
	Interval GetApiCountsParamsInterval `form:"interval" json:"interval"`
}

// GetApiCountsParamsInterval defines parameters for GetApiCounts.
type GetApiCountsParamsInterval string

// ProjectGraphqlParams defines parameters for ProjectGraphql.
type ProjectGraphqlParams struct {
	XGraphqlAuthorization string `json:"x-graphql-authorization"`
}

// DeleteContentParams defines parameters for DeleteContent.
type DeleteContentParams struct {
	Id string `form:"id" json:"id"`
}

// GetDailyStatsParams defines parameters for GetDailyStats.
type GetDailyStatsParams struct {
	Attribute string `form:"attribute" json:"attribute"`
	Interval  string `form:"interval" json:"interval"`
	EndDate   string `form:"endDate" json:"endDate"`
	StartDate string `form:"startDate" json:"startDate"`
}

// GetUsageMetricsParams defines parameters for GetUsageMetrics.
type GetUsageMetricsParams struct {
	Attribute GetUsageMetricsParamsAttribute `form:"attribute" json:"attribute"`
	StartDate string                         `form:"startDate" json:"startDate"`
	EndDate   string                         `form:"endDate" json:"endDate"`
	Interval  *GetUsageMetricsParamsInterval `form:"interval,omitempty" json:"interval,omitempty"`
}

// GetUsageMetricsParamsAttribute defines parameters for GetUsageMetrics.
type GetUsageMetricsParamsAttribute string

// GetUsageMetricsParamsInterval defines parameters for GetUsageMetrics.
type GetUsageMetricsParamsInterval string

// GetInvoicesParams defines parameters for GetInvoices.
type GetInvoicesParams struct {
	Limit  *string `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *string `form:"offset,omitempty" json:"offset,omitempty"`
}

// UpdateGoTrueConfigJSONRequestBody defines body for UpdateGoTrueConfig for application/json ContentType.
type UpdateGoTrueConfigJSONRequestBody = UpdateGoTrueConfigBody

// SendInviteJSONRequestBody defines body for SendInvite for application/json ContentType.
type SendInviteJSONRequestBody = UserBody

// SendMagicLinkJSONRequestBody defines body for SendMagicLink for application/json ContentType.
type SendMagicLinkJSONRequestBody = UserBody

// SendOtpJSONRequestBody defines body for SendOtp for application/json ContentType.
type SendOtpJSONRequestBody = UserBody

// SendRecoverJSONRequestBody defines body for SendRecover for application/json ContentType.
type SendRecoverJSONRequestBody = UserBody

// DeleteUserJSONRequestBody defines body for DeleteUser for application/json ContentType.
type DeleteUserJSONRequestBody = UserBody

// DownloadBackupJSONRequestBody defines body for DownloadBackup for application/json ContentType.
type DownloadBackupJSONRequestBody = DownloadBackupBody

// RestorePointInTimeBackupJSONRequestBody defines body for RestorePointInTimeBackup for application/json ContentType.
type RestorePointInTimeBackupJSONRequestBody = PointInTimeRestoreBody

// RestoreBackupJSONRequestBody defines body for RestoreBackup for application/json ContentType.
type RestoreBackupJSONRequestBody = RestoreLogicalBackupBody

// RestorePhysicalBackupJSONRequestBody defines body for RestorePhysicalBackup for application/json ContentType.
type RestorePhysicalBackupJSONRequestBody = RestorePhysicalBackupBody

// DeleteNotificationsJSONRequestBody defines body for DeleteNotifications for application/json ContentType.
type DeleteNotificationsJSONRequestBody = UpdateNotificationsBodyV1

// UpdateNotificationsV2JSONRequestBody defines body for UpdateNotificationsV2 for application/json ContentType.
type UpdateNotificationsV2JSONRequestBody = UpdateNotificationsV2JSONBody

// CreateOrganizationWithTierJSONRequestBody defines body for CreateOrganizationWithTier for application/json ContentType.
type CreateOrganizationWithTierJSONRequestBody = CreateOrganizationBodyV2

// UpdateOrganizationJSONRequestBody defines body for UpdateOrganization for application/json ContentType.
type UpdateOrganizationJSONRequestBody = UpdateOrganizationBody

// InviteUserJSONRequestBody defines body for InviteUser for application/json ContentType.
type InviteUserJSONRequestBody = InviteUserBody

// UpdateMemberJSONRequestBody defines body for UpdateMember for application/json ContentType.
type UpdateMemberJSONRequestBody = UpdateMemberBody

// RevokeColumnPrivilegesJSONRequestBody defines body for RevokeColumnPrivileges for application/json ContentType.
type RevokeColumnPrivilegesJSONRequestBody = RevokeColumnPrivilegesJSONBody

// GrantColumnPrivilegesJSONRequestBody defines body for GrantColumnPrivileges for application/json ContentType.
type GrantColumnPrivilegesJSONRequestBody = GrantColumnPrivilegesJSONBody

// UpdateColumnJSONRequestBody defines body for UpdateColumn for application/json ContentType.
type UpdateColumnJSONRequestBody = UpdateColumnBody

// CreateColumnJSONRequestBody defines body for CreateColumn for application/json ContentType.
type CreateColumnJSONRequestBody = CreateColumnBody

// CreateExtensionJSONRequestBody defines body for CreateExtension for application/json ContentType.
type CreateExtensionJSONRequestBody = CreateExtensionBody

// UpdateFunctionJSONRequestBody defines body for UpdateFunction for application/json ContentType.
type UpdateFunctionJSONRequestBody = UpdateFunctionBody

// CreateFunctionJSONRequestBody defines body for CreateFunction for application/json ContentType.
type CreateFunctionJSONRequestBody = CreateFunctionBody

// UpdatePolicyJSONRequestBody defines body for UpdatePolicy for application/json ContentType.
type UpdatePolicyJSONRequestBody = UpdatePolicyBody

// CreatePolicyJSONRequestBody defines body for CreatePolicy for application/json ContentType.
type CreatePolicyJSONRequestBody = CreatePolicyBody

// UpdatePublicationJSONRequestBody defines body for UpdatePublication for application/json ContentType.
type UpdatePublicationJSONRequestBody = UpdatePublicationBody

// CreatePublicationJSONRequestBody defines body for CreatePublication for application/json ContentType.
type CreatePublicationJSONRequestBody = CreatePublicationBody

// RunQueryJSONRequestBody defines body for RunQuery for application/json ContentType.
type RunQueryJSONRequestBody = RunQueryBody

// FormatQueryJSONRequestBody defines body for FormatQuery for application/json ContentType.
type FormatQueryJSONRequestBody = FormatQueryBody

// ValidateQueryJSONRequestBody defines body for ValidateQuery for application/json ContentType.
type ValidateQueryJSONRequestBody = ValidateQueryBody

// UpdateRoleJSONRequestBody defines body for UpdateRole for application/json ContentType.
type UpdateRoleJSONRequestBody = UpdateRoleBody

// CreateRoleJSONRequestBody defines body for CreateRole for application/json ContentType.
type CreateRoleJSONRequestBody = CreateRoleBody

// UpdateSchemaJSONRequestBody defines body for UpdateSchema for application/json ContentType.
type UpdateSchemaJSONRequestBody = UpdateSchemaBody

// CreateSchemaJSONRequestBody defines body for CreateSchema for application/json ContentType.
type CreateSchemaJSONRequestBody = CreateSchemaBody

// SearchColumnsJSONRequestBody defines body for SearchColumns for application/json ContentType.
type SearchColumnsJSONRequestBody = SearchColumnBody

// SearchTablesJSONRequestBody defines body for SearchTables for application/json ContentType.
type SearchTablesJSONRequestBody = SearchTableBody

// RevokeTablePrivilegesJSONRequestBody defines body for RevokeTablePrivileges for application/json ContentType.
type RevokeTablePrivilegesJSONRequestBody = RevokeTablePrivilegesJSONBody

// GrantTablePrivilegesJSONRequestBody defines body for GrantTablePrivileges for application/json ContentType.
type GrantTablePrivilegesJSONRequestBody = GrantTablePrivilegesJSONBody

// UpdateTableJSONRequestBody defines body for UpdateTable for application/json ContentType.
type UpdateTableJSONRequestBody = UpdateTableBody

// CreateTableJSONRequestBody defines body for CreateTable for application/json ContentType.
type CreateTableJSONRequestBody = CreateTableBody

// UpdateTriggerJSONRequestBody defines body for UpdateTrigger for application/json ContentType.
type UpdateTriggerJSONRequestBody = UpdateTriggerBody

// CreateTriggerJSONRequestBody defines body for CreateTrigger for application/json ContentType.
type CreateTriggerJSONRequestBody = CreateTriggerBody

// CreateProjectJSONRequestBody defines body for CreateProject for application/json ContentType.
type CreateProjectJSONRequestBody = CreateProjectBody

// GetProjectsMetricsJSONRequestBody defines body for GetProjectsMetrics for application/json ContentType.
type GetProjectsMetricsJSONRequestBody = GetMetricsBody

// UpdateProjectJSONRequestBody defines body for UpdateProject for application/json ContentType.
type UpdateProjectJSONRequestBody = UpdateProjectBody

// ProjectGraphqlJSONRequestBody defines body for ProjectGraphql for application/json ContentType.
type ProjectGraphqlJSONRequestBody = Buffer

// UpdatePgbouncerConfigJSONRequestBody defines body for UpdatePgbouncerConfig for application/json ContentType.
type UpdatePgbouncerConfigJSONRequestBody = UpdatePgbouncerConfigBody

// UpdateConfigJSONRequestBody defines body for UpdateConfig for application/json ContentType.
type UpdateConfigJSONRequestBody = UpdatePostgresConfigBody

// UpdatePostgRESTConfigJSONRequestBody defines body for UpdatePostgRESTConfig for application/json ContentType.
type UpdatePostgRESTConfigJSONRequestBody = UpdatePostgrestConfigBody

// UpdateConfigJSONRequestBody defines body for UpdateConfig for application/json ContentType.
type UpdateConfigJSONRequestBody = UpdateSecretsConfigBody

// UpdateConfigJSONRequestBody defines body for UpdateConfig for application/json ContentType.
type UpdateConfigJSONRequestBody = UpdateStorageConfigBody

// UpdateContentJSONRequestBody defines body for UpdateContent for application/json ContentType.
type UpdateContentJSONRequestBody = UpdateContentParams

// CreateContentJSONRequestBody defines body for CreateContent for application/json ContentType.
type CreateContentJSONRequestBody = CreateContentParams

// UpdateWholeContentJSONRequestBody defines body for UpdateWholeContent for application/json ContentType.
type UpdateWholeContentJSONRequestBody = UpsertContentParams

// UpdatePasswordJSONRequestBody defines body for UpdatePassword for application/json ContentType.
type UpdatePasswordJSONRequestBody = UpdatePasswordBody

// ResizeDatabaseJSONRequestBody defines body for ResizeDatabase for application/json ContentType.
type ResizeDatabaseJSONRequestBody = ResizeBody

// RestartServicesJSONRequestBody defines body for RestartServices for application/json ContentType.
type RestartServicesJSONRequestBody = RestartServicesBody

// RestoreProjectJSONRequestBody defines body for RestoreProject for application/json ContentType.
type RestoreProjectJSONRequestBody = RestoreProjectBody

// CreateBucketJSONRequestBody defines body for CreateBucket for application/json ContentType.
type CreateBucketJSONRequestBody = CreateStorageBucketBody

// UpdateBucketJSONRequestBody defines body for UpdateBucket for application/json ContentType.
type UpdateBucketJSONRequestBody = UpdateStorageBucketBody

// DeleteObjectsJSONRequestBody defines body for DeleteObjects for application/json ContentType.
type DeleteObjectsJSONRequestBody = DeleteObjectsBody

// CopyObjectJSONRequestBody defines body for CopyObject for application/json ContentType.
type CopyObjectJSONRequestBody = CopyObjectBody

// DownloadJSONRequestBody defines body for Download for application/json ContentType.
type DownloadJSONRequestBody = DownloadObjectBody

// GetObjectsJSONRequestBody defines body for GetObjects for application/json ContentType.
type GetObjectsJSONRequestBody = GetObjectsBody

// MoveObjectJSONRequestBody defines body for MoveObject for application/json ContentType.
type MoveObjectJSONRequestBody = MoveObjectBody

// CreatePublicUrlJSONRequestBody defines body for CreatePublicUrl for application/json ContentType.
type CreatePublicUrlJSONRequestBody = GetPublicUrlBody

// CreateSignedUrlJSONRequestBody defines body for CreateSignedUrl for application/json ContentType.
type CreateSignedUrlJSONRequestBody = GetSignedUrlBody

// CreateSignedUrlsJSONRequestBody defines body for CreateSignedUrls for application/json ContentType.
type CreateSignedUrlsJSONRequestBody = GetSignedUrlsBody

// AsAnalyticsResponseError0 returns the union data inside the AnalyticsResponse_Error as a AnalyticsResponseError0
func (t AnalyticsResponse_Error) AsAnalyticsResponseError0() (AnalyticsResponseError0, error) {
	var body AnalyticsResponseError0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAnalyticsResponseError0 overwrites any union data inside the AnalyticsResponse_Error as the provided AnalyticsResponseError0
func (t *AnalyticsResponse_Error) FromAnalyticsResponseError0(v AnalyticsResponseError0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAnalyticsResponseError0 performs a merge with any union data inside the AnalyticsResponse_Error, using the provided AnalyticsResponseError0
func (t *AnalyticsResponse_Error) MergeAnalyticsResponseError0(v AnalyticsResponseError0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAnalyticsResponseError1 returns the union data inside the AnalyticsResponse_Error as a AnalyticsResponseError1
func (t AnalyticsResponse_Error) AsAnalyticsResponseError1() (AnalyticsResponseError1, error) {
	var body AnalyticsResponseError1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAnalyticsResponseError1 overwrites any union data inside the AnalyticsResponse_Error as the provided AnalyticsResponseError1
func (t *AnalyticsResponse_Error) FromAnalyticsResponseError1(v AnalyticsResponseError1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAnalyticsResponseError1 performs a merge with any union data inside the AnalyticsResponse_Error, using the provided AnalyticsResponseError1
func (t *AnalyticsResponse_Error) MergeAnalyticsResponseError1(v AnalyticsResponseError1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AnalyticsResponse_Error) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AnalyticsResponse_Error) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetGoTrueConfig request
	GetGoTrueConfig(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGoTrueConfigWithBody request with any body
	UpdateGoTrueConfigWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateGoTrueConfig(ctx context.Context, ref string, body UpdateGoTrueConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendInviteWithBody request with any body
	SendInviteWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendInvite(ctx context.Context, ref string, body SendInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendMagicLinkWithBody request with any body
	SendMagicLinkWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendMagicLink(ctx context.Context, ref string, body SendMagicLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendOtpWithBody request with any body
	SendOtpWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendOtp(ctx context.Context, ref string, body SendOtpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendRecoverWithBody request with any body
	SendRecoverWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendRecover(ctx context.Context, ref string, body SendRecoverJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTemplate request
	GetTemplate(ctx context.Context, ref string, template GetTemplateParamsTemplate, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserWithBody request with any body
	DeleteUserWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteUser(ctx context.Context, ref string, body DeleteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsers request
	GetUsers(ctx context.Context, ref string, params *GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFactors request
	DeleteFactors(ctx context.Context, ref string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBackups request
	GetBackups(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadBackupWithBody request with any body
	DownloadBackupWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DownloadBackup(ctx context.Context, ref string, body DownloadBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestorePointInTimeBackupWithBody request with any body
	RestorePointInTimeBackupWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RestorePointInTimeBackup(ctx context.Context, ref string, body RestorePointInTimeBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestoreBackupWithBody request with any body
	RestoreBackupWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RestoreBackup(ctx context.Context, ref string, body RestoreBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestorePhysicalBackupWithBody request with any body
	RestorePhysicalBackupWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RestorePhysicalBackup(ctx context.Context, ref string, body RestorePhysicalBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnableHooks request
	EnableHooks(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHookLogs request
	GetHookLogs(ctx context.Context, ref string, params *GetHookLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNotificationsWithBody request with any body
	DeleteNotificationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteNotifications(ctx context.Context, body DeleteNotificationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNotificationsV2 request
	GetNotificationsV2(ctx context.Context, params *GetNotificationsV2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateNotificationsV2WithBody request with any body
	UpdateNotificationsV2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateNotificationsV2(ctx context.Context, body UpdateNotificationsV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizations request
	GetOrganizations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrganizationWithTierWithBody request with any body
	CreateOrganizationWithTierWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrganizationWithTier(ctx context.Context, body CreateOrganizationWithTierJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOrganization request
	DeleteOrganization(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateOrganizationWithBody request with any body
	UpdateOrganizationWithBody(ctx context.Context, slug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateOrganization(ctx context.Context, slug string, body UpdateOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMembers request
	GetMembers(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInvitedUser request
	DeleteInvitedUser(ctx context.Context, slug string, params *DeleteInvitedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvitedUsers request
	GetInvitedUsers(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InviteUserWithBody request with any body
	InviteUserWithBody(ctx context.Context, slug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InviteUser(ctx context.Context, slug string, body InviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvite request
	GetInvite(ctx context.Context, slug string, params *GetInviteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JoinOrganization request
	JoinOrganization(ctx context.Context, slug string, params *JoinOrganizationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMember request
	DeleteMember(ctx context.Context, slug string, gotrueId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateMemberWithBody request with any body
	UpdateMemberWithBody(ctx context.Context, slug string, gotrueId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateMember(ctx context.Context, slug string, gotrueId string, body UpdateMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddMember request
	AddMember(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokeColumnPrivilegesWithBody request with any body
	RevokeColumnPrivilegesWithBody(ctx context.Context, ref string, params *RevokeColumnPrivilegesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevokeColumnPrivileges(ctx context.Context, ref string, params *RevokeColumnPrivilegesParams, body RevokeColumnPrivilegesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetColumnPrivileges request
	GetColumnPrivileges(ctx context.Context, ref string, params *GetColumnPrivilegesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GrantColumnPrivilegesWithBody request with any body
	GrantColumnPrivilegesWithBody(ctx context.Context, ref string, params *GrantColumnPrivilegesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GrantColumnPrivileges(ctx context.Context, ref string, params *GrantColumnPrivilegesParams, body GrantColumnPrivilegesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteColumn request
	DeleteColumn(ctx context.Context, ref string, params *DeleteColumnParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetColumns request
	GetColumns(ctx context.Context, ref string, params *GetColumnsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateColumnWithBody request with any body
	UpdateColumnWithBody(ctx context.Context, ref string, params *UpdateColumnParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateColumn(ctx context.Context, ref string, params *UpdateColumnParams, body UpdateColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateColumnWithBody request with any body
	CreateColumnWithBody(ctx context.Context, ref string, params *CreateColumnParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateColumn(ctx context.Context, ref string, params *CreateColumnParams, body CreateColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteExtension request
	DeleteExtension(ctx context.Context, ref string, params *DeleteExtensionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExtensions request
	GetExtensions(ctx context.Context, ref string, params *GetExtensionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateExtensionWithBody request with any body
	CreateExtensionWithBody(ctx context.Context, ref string, params *CreateExtensionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateExtension(ctx context.Context, ref string, params *CreateExtensionParams, body CreateExtensionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetForeignTables request
	GetForeignTables(ctx context.Context, ref string, params *GetForeignTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFunction request
	DeleteFunction(ctx context.Context, ref string, params *DeleteFunctionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFunctions request
	GetFunctions(ctx context.Context, ref string, params *GetFunctionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFunctionWithBody request with any body
	UpdateFunctionWithBody(ctx context.Context, ref string, params *UpdateFunctionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFunction(ctx context.Context, ref string, params *UpdateFunctionParams, body UpdateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFunctionWithBody request with any body
	CreateFunctionWithBody(ctx context.Context, ref string, params *CreateFunctionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFunction(ctx context.Context, ref string, params *CreateFunctionParams, body CreateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMaterializedViews request
	GetMaterializedViews(ctx context.Context, ref string, params *GetMaterializedViewsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePolicy request
	DeletePolicy(ctx context.Context, ref string, params *DeletePolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPolicies request
	GetPolicies(ctx context.Context, ref string, params *GetPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePolicyWithBody request with any body
	UpdatePolicyWithBody(ctx context.Context, ref string, params *UpdatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePolicy(ctx context.Context, ref string, params *UpdatePolicyParams, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePolicyWithBody request with any body
	CreatePolicyWithBody(ctx context.Context, ref string, params *CreatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePolicy(ctx context.Context, ref string, params *CreatePolicyParams, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePublication request
	DeletePublication(ctx context.Context, ref string, params *DeletePublicationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPublications request
	GetPublications(ctx context.Context, ref string, params *GetPublicationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePublicationWithBody request with any body
	UpdatePublicationWithBody(ctx context.Context, ref string, params *UpdatePublicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePublication(ctx context.Context, ref string, params *UpdatePublicationParams, body UpdatePublicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePublicationWithBody request with any body
	CreatePublicationWithBody(ctx context.Context, ref string, params *CreatePublicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePublication(ctx context.Context, ref string, params *CreatePublicationParams, body CreatePublicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunQueryWithBody request with any body
	RunQueryWithBody(ctx context.Context, ref string, params *RunQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunQuery(ctx context.Context, ref string, params *RunQueryParams, body RunQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FormatQueryWithBody request with any body
	FormatQueryWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FormatQuery(ctx context.Context, ref string, body FormatQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateQueryWithBody request with any body
	ValidateQueryWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidateQuery(ctx context.Context, ref string, body ValidateQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRole request
	DeleteRole(ctx context.Context, ref string, params *DeleteRoleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRoles request
	GetRoles(ctx context.Context, ref string, params *GetRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRoleWithBody request with any body
	UpdateRoleWithBody(ctx context.Context, ref string, params *UpdateRoleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRole(ctx context.Context, ref string, params *UpdateRoleParams, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRoleWithBody request with any body
	CreateRoleWithBody(ctx context.Context, ref string, params *CreateRoleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRole(ctx context.Context, ref string, params *CreateRoleParams, body CreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSchema request
	DeleteSchema(ctx context.Context, ref string, params *DeleteSchemaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchemas request
	GetSchemas(ctx context.Context, ref string, params *GetSchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSchemaWithBody request with any body
	UpdateSchemaWithBody(ctx context.Context, ref string, params *UpdateSchemaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSchema(ctx context.Context, ref string, params *UpdateSchemaParams, body UpdateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSchemaWithBody request with any body
	CreateSchemaWithBody(ctx context.Context, ref string, params *CreateSchemaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSchema(ctx context.Context, ref string, params *CreateSchemaParams, body CreateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchColumnsWithBody request with any body
	SearchColumnsWithBody(ctx context.Context, ref string, params *SearchColumnsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchColumns(ctx context.Context, ref string, params *SearchColumnsParams, body SearchColumnsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchTablesWithBody request with any body
	SearchTablesWithBody(ctx context.Context, ref string, params *SearchTablesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchTables(ctx context.Context, ref string, params *SearchTablesParams, body SearchTablesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokeTablePrivilegesWithBody request with any body
	RevokeTablePrivilegesWithBody(ctx context.Context, ref string, params *RevokeTablePrivilegesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevokeTablePrivileges(ctx context.Context, ref string, params *RevokeTablePrivilegesParams, body RevokeTablePrivilegesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTablePrivileges request
	GetTablePrivileges(ctx context.Context, ref string, params *GetTablePrivilegesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GrantTablePrivilegesWithBody request with any body
	GrantTablePrivilegesWithBody(ctx context.Context, ref string, params *GrantTablePrivilegesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GrantTablePrivileges(ctx context.Context, ref string, params *GrantTablePrivilegesParams, body GrantTablePrivilegesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTable request
	DeleteTable(ctx context.Context, ref string, params *DeleteTableParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTables request
	GetTables(ctx context.Context, ref string, params *GetTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTableWithBody request with any body
	UpdateTableWithBody(ctx context.Context, ref string, params *UpdateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTable(ctx context.Context, ref string, params *UpdateTableParams, body UpdateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTableWithBody request with any body
	CreateTableWithBody(ctx context.Context, ref string, params *CreateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTable(ctx context.Context, ref string, params *CreateTableParams, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTrigger request
	DeleteTrigger(ctx context.Context, ref string, params *DeleteTriggerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTriggers request
	GetTriggers(ctx context.Context, ref string, params *GetTriggersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTriggerWithBody request with any body
	UpdateTriggerWithBody(ctx context.Context, ref string, params *UpdateTriggerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTrigger(ctx context.Context, ref string, params *UpdateTriggerParams, body UpdateTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTriggerWithBody request with any body
	CreateTriggerWithBody(ctx context.Context, ref string, params *CreateTriggerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTrigger(ctx context.Context, ref string, params *CreateTriggerParams, body CreateTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTypes request
	GetTypes(ctx context.Context, ref string, params *GetTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetViews request
	GetViews(ctx context.Context, ref string, params *GetViewsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjects request
	GetProjects(ctx context.Context, params *GetProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProjectWithBody request with any body
	CreateProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProject(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjectsMetricsWithBody request with any body
	GetProjectsMetricsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetProjectsMetrics(ctx context.Context, body GetProjectsMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProject request
	DeleteProject(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProject request
	GetProject(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProjectWithBody request with any body
	UpdateProjectWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProject(ctx context.Context, ref string, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFunctionStatus request
	GetFunctionStatus(ctx context.Context, ref string, params *GetFunctionStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApiPaths request
	GetApiPaths(ctx context.Context, ref string, params *GetApiPathsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApiCounts request
	GetApiCounts(ctx context.Context, ref string, params *GetApiCountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectGraphqlWithBody request with any body
	ProjectGraphqlWithBody(ctx context.Context, ref string, params *ProjectGraphqlParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProjectGraphql(ctx context.Context, ref string, params *ProjectGraphqlParams, body ProjectGraphqlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectOpenApi request
	ProjectOpenApi(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPgbouncerConfig request
	GetPgbouncerConfig(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePgbouncerConfigWithBody request with any body
	UpdatePgbouncerConfigWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePgbouncerConfig(ctx context.Context, ref string, body UpdatePgbouncerConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfig request
	GetConfig(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateConfigWithBody request with any body
	UpdateConfigWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateConfig(ctx context.Context, ref string, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPostgRESTConfig request
	GetPostgRESTConfig(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePostgRESTConfigWithBody request with any body
	UpdatePostgRESTConfigWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePostgRESTConfig(ctx context.Context, ref string, body UpdatePostgRESTConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateConfigWithBody request with any body
	UpdateConfigWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateConfig(ctx context.Context, ref string, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStorageConfig request
	GetStorageConfig(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateConfigWithBody request with any body
	UpdateConfigWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateConfig(ctx context.Context, ref string, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteContent request
	DeleteContent(ctx context.Context, ref string, params *DeleteContentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjectContent request
	GetProjectContent(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateContentWithBody request with any body
	UpdateContentWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateContent(ctx context.Context, ref string, body UpdateContentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateContentWithBody request with any body
	CreateContentWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateContent(ctx context.Context, ref string, body CreateContentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWholeContentWithBody request with any body
	UpdateWholeContentWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateWholeContent(ctx context.Context, ref string, body UpdateWholeContentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDailyStats request
	GetDailyStats(ctx context.Context, ref string, params *GetDailyStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePasswordWithBody request with any body
	UpdatePasswordWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePassword(ctx context.Context, ref string, body UpdatePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsageMetrics request
	GetUsageMetrics(ctx context.Context, ref string, params *GetUsageMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvoices request
	GetInvoices(ctx context.Context, ref string, params *GetInvoicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvoiceCount request
	GetInvoiceCount(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectHealthCheck request
	ProjectHealthCheck(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PauseProject request
	PauseProject(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResizeDatabaseWithBody request with any body
	ResizeDatabaseWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResizeDatabase(ctx context.Context, ref string, body ResizeDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestartProject request
	RestartProject(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestartServicesWithBody request with any body
	RestartServicesWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RestartServices(ctx context.Context, ref string, body RestartServicesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestoreProjectWithBody request with any body
	RestoreProjectWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RestoreProject(ctx context.Context, ref string, body RestoreProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjectApi request
	GetProjectApi(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjectStatus request
	GetProjectStatus(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsageStatusConfig request
	GetUsageStatusConfig(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStatus request
	GetStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBuckets request
	GetBuckets(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBucketWithBody request with any body
	CreateBucketWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBucket(ctx context.Context, ref string, body CreateBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBucket request
	DeleteBucket(ctx context.Context, ref string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBucket request
	GetBucket(ctx context.Context, ref string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBucketWithBody request with any body
	UpdateBucketWithBody(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBucket(ctx context.Context, ref string, id string, body UpdateBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EmptyBucket request
	EmptyBucket(ctx context.Context, ref string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteObjectsWithBody request with any body
	DeleteObjectsWithBody(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteObjects(ctx context.Context, ref string, id string, body DeleteObjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CopyObjectWithBody request with any body
	CopyObjectWithBody(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CopyObject(ctx context.Context, ref string, id string, body CopyObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadWithBody request with any body
	DownloadWithBody(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Download(ctx context.Context, ref string, id string, body DownloadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetObjectsWithBody request with any body
	GetObjectsWithBody(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetObjects(ctx context.Context, ref string, id string, body GetObjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MoveObjectWithBody request with any body
	MoveObjectWithBody(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MoveObject(ctx context.Context, ref string, id string, body MoveObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePublicUrlWithBody request with any body
	CreatePublicUrlWithBody(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePublicUrl(ctx context.Context, ref string, id string, body CreatePublicUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSignedUrlWithBody request with any body
	CreateSignedUrlWithBody(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSignedUrl(ctx context.Context, ref string, id string, body CreateSignedUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSignedUrlsWithBody request with any body
	CreateSignedUrlsWithBody(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSignedUrls(ctx context.Context, ref string, id string, body CreateSignedUrlsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetGoTrueConfig(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGoTrueConfigRequest(c.Server, ref)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGoTrueConfigWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGoTrueConfigRequestWithBody(c.Server, ref, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGoTrueConfig(ctx context.Context, ref string, body UpdateGoTrueConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGoTrueConfigRequest(c.Server, ref, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendInviteWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendInviteRequestWithBody(c.Server, ref, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendInvite(ctx context.Context, ref string, body SendInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendInviteRequest(c.Server, ref, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendMagicLinkWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendMagicLinkRequestWithBody(c.Server, ref, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendMagicLink(ctx context.Context, ref string, body SendMagicLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendMagicLinkRequest(c.Server, ref, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendOtpWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendOtpRequestWithBody(c.Server, ref, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendOtp(ctx context.Context, ref string, body SendOtpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendOtpRequest(c.Server, ref, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendRecoverWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendRecoverRequestWithBody(c.Server, ref, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendRecover(ctx context.Context, ref string, body SendRecoverJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendRecoverRequest(c.Server, ref, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTemplate(ctx context.Context, ref string, template GetTemplateParamsTemplate, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTemplateRequest(c.Server, ref, template)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequestWithBody(c.Server, ref, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, ref string, body DeleteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, ref, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsers(ctx context.Context, ref string, params *GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFactors(ctx context.Context, ref string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFactorsRequest(c.Server, ref, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBackups(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBackupsRequest(c.Server, ref)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadBackupWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadBackupRequestWithBody(c.Server, ref, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadBackup(ctx context.Context, ref string, body DownloadBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadBackupRequest(c.Server, ref, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestorePointInTimeBackupWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestorePointInTimeBackupRequestWithBody(c.Server, ref, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestorePointInTimeBackup(ctx context.Context, ref string, body RestorePointInTimeBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestorePointInTimeBackupRequest(c.Server, ref, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreBackupWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreBackupRequestWithBody(c.Server, ref, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreBackup(ctx context.Context, ref string, body RestoreBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreBackupRequest(c.Server, ref, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestorePhysicalBackupWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestorePhysicalBackupRequestWithBody(c.Server, ref, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestorePhysicalBackup(ctx context.Context, ref string, body RestorePhysicalBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestorePhysicalBackupRequest(c.Server, ref, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableHooks(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableHooksRequest(c.Server, ref)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHookLogs(ctx context.Context, ref string, params *GetHookLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHookLogsRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNotificationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNotificationsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNotifications(ctx context.Context, body DeleteNotificationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNotificationsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNotificationsV2(ctx context.Context, params *GetNotificationsV2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNotificationsV2Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNotificationsV2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNotificationsV2RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNotificationsV2(ctx context.Context, body UpdateNotificationsV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNotificationsV2Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrganizationWithTierWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrganizationWithTierRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrganizationWithTier(ctx context.Context, body CreateOrganizationWithTierJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrganizationWithTierRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOrganization(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOrganizationRequest(c.Server, slug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrganizationWithBody(ctx context.Context, slug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrganizationRequestWithBody(c.Server, slug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrganization(ctx context.Context, slug string, body UpdateOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrganizationRequest(c.Server, slug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMembers(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMembersRequest(c.Server, slug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInvitedUser(ctx context.Context, slug string, params *DeleteInvitedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInvitedUserRequest(c.Server, slug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvitedUsers(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvitedUsersRequest(c.Server, slug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteUserWithBody(ctx context.Context, slug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteUserRequestWithBody(c.Server, slug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteUser(ctx context.Context, slug string, body InviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteUserRequest(c.Server, slug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvite(ctx context.Context, slug string, params *GetInviteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInviteRequest(c.Server, slug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JoinOrganization(ctx context.Context, slug string, params *JoinOrganizationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJoinOrganizationRequest(c.Server, slug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMember(ctx context.Context, slug string, gotrueId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMemberRequest(c.Server, slug, gotrueId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMemberWithBody(ctx context.Context, slug string, gotrueId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMemberRequestWithBody(c.Server, slug, gotrueId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMember(ctx context.Context, slug string, gotrueId string, body UpdateMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMemberRequest(c.Server, slug, gotrueId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddMember(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddMemberRequest(c.Server, slug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokeColumnPrivilegesWithBody(ctx context.Context, ref string, params *RevokeColumnPrivilegesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeColumnPrivilegesRequestWithBody(c.Server, ref, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokeColumnPrivileges(ctx context.Context, ref string, params *RevokeColumnPrivilegesParams, body RevokeColumnPrivilegesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeColumnPrivilegesRequest(c.Server, ref, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetColumnPrivileges(ctx context.Context, ref string, params *GetColumnPrivilegesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetColumnPrivilegesRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GrantColumnPrivilegesWithBody(ctx context.Context, ref string, params *GrantColumnPrivilegesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGrantColumnPrivilegesRequestWithBody(c.Server, ref, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GrantColumnPrivileges(ctx context.Context, ref string, params *GrantColumnPrivilegesParams, body GrantColumnPrivilegesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGrantColumnPrivilegesRequest(c.Server, ref, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteColumn(ctx context.Context, ref string, params *DeleteColumnParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteColumnRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetColumns(ctx context.Context, ref string, params *GetColumnsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetColumnsRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateColumnWithBody(ctx context.Context, ref string, params *UpdateColumnParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateColumnRequestWithBody(c.Server, ref, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateColumn(ctx context.Context, ref string, params *UpdateColumnParams, body UpdateColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateColumnRequest(c.Server, ref, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateColumnWithBody(ctx context.Context, ref string, params *CreateColumnParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateColumnRequestWithBody(c.Server, ref, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateColumn(ctx context.Context, ref string, params *CreateColumnParams, body CreateColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateColumnRequest(c.Server, ref, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteExtension(ctx context.Context, ref string, params *DeleteExtensionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteExtensionRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExtensions(ctx context.Context, ref string, params *GetExtensionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExtensionsRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateExtensionWithBody(ctx context.Context, ref string, params *CreateExtensionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateExtensionRequestWithBody(c.Server, ref, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateExtension(ctx context.Context, ref string, params *CreateExtensionParams, body CreateExtensionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateExtensionRequest(c.Server, ref, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetForeignTables(ctx context.Context, ref string, params *GetForeignTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetForeignTablesRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFunction(ctx context.Context, ref string, params *DeleteFunctionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFunctionRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFunctions(ctx context.Context, ref string, params *GetFunctionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFunctionsRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFunctionWithBody(ctx context.Context, ref string, params *UpdateFunctionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFunctionRequestWithBody(c.Server, ref, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFunction(ctx context.Context, ref string, params *UpdateFunctionParams, body UpdateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFunctionRequest(c.Server, ref, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFunctionWithBody(ctx context.Context, ref string, params *CreateFunctionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFunctionRequestWithBody(c.Server, ref, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFunction(ctx context.Context, ref string, params *CreateFunctionParams, body CreateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFunctionRequest(c.Server, ref, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMaterializedViews(ctx context.Context, ref string, params *GetMaterializedViewsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMaterializedViewsRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePolicy(ctx context.Context, ref string, params *DeletePolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePolicyRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPolicies(ctx context.Context, ref string, params *GetPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPoliciesRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePolicyWithBody(ctx context.Context, ref string, params *UpdatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePolicyRequestWithBody(c.Server, ref, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePolicy(ctx context.Context, ref string, params *UpdatePolicyParams, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePolicyRequest(c.Server, ref, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePolicyWithBody(ctx context.Context, ref string, params *CreatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePolicyRequestWithBody(c.Server, ref, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePolicy(ctx context.Context, ref string, params *CreatePolicyParams, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePolicyRequest(c.Server, ref, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePublication(ctx context.Context, ref string, params *DeletePublicationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePublicationRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPublications(ctx context.Context, ref string, params *GetPublicationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPublicationsRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePublicationWithBody(ctx context.Context, ref string, params *UpdatePublicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePublicationRequestWithBody(c.Server, ref, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePublication(ctx context.Context, ref string, params *UpdatePublicationParams, body UpdatePublicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePublicationRequest(c.Server, ref, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePublicationWithBody(ctx context.Context, ref string, params *CreatePublicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePublicationRequestWithBody(c.Server, ref, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePublication(ctx context.Context, ref string, params *CreatePublicationParams, body CreatePublicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePublicationRequest(c.Server, ref, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunQueryWithBody(ctx context.Context, ref string, params *RunQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunQueryRequestWithBody(c.Server, ref, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunQuery(ctx context.Context, ref string, params *RunQueryParams, body RunQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunQueryRequest(c.Server, ref, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FormatQueryWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFormatQueryRequestWithBody(c.Server, ref, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FormatQuery(ctx context.Context, ref string, body FormatQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFormatQueryRequest(c.Server, ref, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateQueryWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateQueryRequestWithBody(c.Server, ref, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateQuery(ctx context.Context, ref string, body ValidateQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateQueryRequest(c.Server, ref, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRole(ctx context.Context, ref string, params *DeleteRoleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRoleRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRoles(ctx context.Context, ref string, params *GetRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRolesRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRoleWithBody(ctx context.Context, ref string, params *UpdateRoleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoleRequestWithBody(c.Server, ref, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRole(ctx context.Context, ref string, params *UpdateRoleParams, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoleRequest(c.Server, ref, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRoleWithBody(ctx context.Context, ref string, params *CreateRoleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRoleRequestWithBody(c.Server, ref, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRole(ctx context.Context, ref string, params *CreateRoleParams, body CreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRoleRequest(c.Server, ref, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSchema(ctx context.Context, ref string, params *DeleteSchemaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSchemaRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchemas(ctx context.Context, ref string, params *GetSchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchemasRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSchemaWithBody(ctx context.Context, ref string, params *UpdateSchemaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSchemaRequestWithBody(c.Server, ref, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSchema(ctx context.Context, ref string, params *UpdateSchemaParams, body UpdateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSchemaRequest(c.Server, ref, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSchemaWithBody(ctx context.Context, ref string, params *CreateSchemaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSchemaRequestWithBody(c.Server, ref, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSchema(ctx context.Context, ref string, params *CreateSchemaParams, body CreateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSchemaRequest(c.Server, ref, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchColumnsWithBody(ctx context.Context, ref string, params *SearchColumnsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchColumnsRequestWithBody(c.Server, ref, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchColumns(ctx context.Context, ref string, params *SearchColumnsParams, body SearchColumnsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchColumnsRequest(c.Server, ref, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchTablesWithBody(ctx context.Context, ref string, params *SearchTablesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchTablesRequestWithBody(c.Server, ref, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchTables(ctx context.Context, ref string, params *SearchTablesParams, body SearchTablesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchTablesRequest(c.Server, ref, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokeTablePrivilegesWithBody(ctx context.Context, ref string, params *RevokeTablePrivilegesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeTablePrivilegesRequestWithBody(c.Server, ref, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokeTablePrivileges(ctx context.Context, ref string, params *RevokeTablePrivilegesParams, body RevokeTablePrivilegesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeTablePrivilegesRequest(c.Server, ref, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTablePrivileges(ctx context.Context, ref string, params *GetTablePrivilegesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTablePrivilegesRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GrantTablePrivilegesWithBody(ctx context.Context, ref string, params *GrantTablePrivilegesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGrantTablePrivilegesRequestWithBody(c.Server, ref, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GrantTablePrivileges(ctx context.Context, ref string, params *GrantTablePrivilegesParams, body GrantTablePrivilegesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGrantTablePrivilegesRequest(c.Server, ref, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTable(ctx context.Context, ref string, params *DeleteTableParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTableRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTables(ctx context.Context, ref string, params *GetTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTablesRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTableWithBody(ctx context.Context, ref string, params *UpdateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTableRequestWithBody(c.Server, ref, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTable(ctx context.Context, ref string, params *UpdateTableParams, body UpdateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTableRequest(c.Server, ref, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTableWithBody(ctx context.Context, ref string, params *CreateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTableRequestWithBody(c.Server, ref, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTable(ctx context.Context, ref string, params *CreateTableParams, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTableRequest(c.Server, ref, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTrigger(ctx context.Context, ref string, params *DeleteTriggerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTriggerRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTriggers(ctx context.Context, ref string, params *GetTriggersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTriggersRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTriggerWithBody(ctx context.Context, ref string, params *UpdateTriggerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTriggerRequestWithBody(c.Server, ref, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTrigger(ctx context.Context, ref string, params *UpdateTriggerParams, body UpdateTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTriggerRequest(c.Server, ref, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTriggerWithBody(ctx context.Context, ref string, params *CreateTriggerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTriggerRequestWithBody(c.Server, ref, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTrigger(ctx context.Context, ref string, params *CreateTriggerParams, body CreateTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTriggerRequest(c.Server, ref, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTypes(ctx context.Context, ref string, params *GetTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTypesRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetViews(ctx context.Context, ref string, params *GetViewsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetViewsRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjects(ctx context.Context, params *GetProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProject(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectsMetricsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectsMetricsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectsMetrics(ctx context.Context, body GetProjectsMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectsMetricsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProject(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectRequest(c.Server, ref)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProject(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectRequest(c.Server, ref)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectRequestWithBody(c.Server, ref, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProject(ctx context.Context, ref string, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectRequest(c.Server, ref, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFunctionStatus(ctx context.Context, ref string, params *GetFunctionStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFunctionStatusRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApiPaths(ctx context.Context, ref string, params *GetApiPathsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApiPathsRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApiCounts(ctx context.Context, ref string, params *GetApiCountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApiCountsRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectGraphqlWithBody(ctx context.Context, ref string, params *ProjectGraphqlParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectGraphqlRequestWithBody(c.Server, ref, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectGraphql(ctx context.Context, ref string, params *ProjectGraphqlParams, body ProjectGraphqlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectGraphqlRequest(c.Server, ref, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectOpenApi(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectOpenApiRequest(c.Server, ref)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPgbouncerConfig(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPgbouncerConfigRequest(c.Server, ref)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePgbouncerConfigWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePgbouncerConfigRequestWithBody(c.Server, ref, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePgbouncerConfig(ctx context.Context, ref string, body UpdatePgbouncerConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePgbouncerConfigRequest(c.Server, ref, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfig(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigRequest(c.Server, ref)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConfigWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConfigRequestWithBody(c.Server, ref, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConfig(ctx context.Context, ref string, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConfigRequest(c.Server, ref, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPostgRESTConfig(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPostgRESTConfigRequest(c.Server, ref)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePostgRESTConfigWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePostgRESTConfigRequestWithBody(c.Server, ref, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePostgRESTConfig(ctx context.Context, ref string, body UpdatePostgRESTConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePostgRESTConfigRequest(c.Server, ref, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConfigWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConfigRequestWithBody(c.Server, ref, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConfig(ctx context.Context, ref string, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConfigRequest(c.Server, ref, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStorageConfig(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStorageConfigRequest(c.Server, ref)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConfigWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConfigRequestWithBody(c.Server, ref, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConfig(ctx context.Context, ref string, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConfigRequest(c.Server, ref, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteContent(ctx context.Context, ref string, params *DeleteContentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteContentRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectContent(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectContentRequest(c.Server, ref)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateContentWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateContentRequestWithBody(c.Server, ref, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateContent(ctx context.Context, ref string, body UpdateContentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateContentRequest(c.Server, ref, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateContentWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateContentRequestWithBody(c.Server, ref, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateContent(ctx context.Context, ref string, body CreateContentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateContentRequest(c.Server, ref, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWholeContentWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWholeContentRequestWithBody(c.Server, ref, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWholeContent(ctx context.Context, ref string, body UpdateWholeContentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWholeContentRequest(c.Server, ref, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDailyStats(ctx context.Context, ref string, params *GetDailyStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDailyStatsRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePasswordWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePasswordRequestWithBody(c.Server, ref, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePassword(ctx context.Context, ref string, body UpdatePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePasswordRequest(c.Server, ref, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsageMetrics(ctx context.Context, ref string, params *GetUsageMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsageMetricsRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvoices(ctx context.Context, ref string, params *GetInvoicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvoicesRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvoiceCount(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvoiceCountRequest(c.Server, ref)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectHealthCheck(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectHealthCheckRequest(c.Server, ref)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PauseProject(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPauseProjectRequest(c.Server, ref)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResizeDatabaseWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResizeDatabaseRequestWithBody(c.Server, ref, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResizeDatabase(ctx context.Context, ref string, body ResizeDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResizeDatabaseRequest(c.Server, ref, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestartProject(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestartProjectRequest(c.Server, ref)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestartServicesWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestartServicesRequestWithBody(c.Server, ref, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestartServices(ctx context.Context, ref string, body RestartServicesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestartServicesRequest(c.Server, ref, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreProjectWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreProjectRequestWithBody(c.Server, ref, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreProject(ctx context.Context, ref string, body RestoreProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreProjectRequest(c.Server, ref, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectApi(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectApiRequest(c.Server, ref)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectStatus(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectStatusRequest(c.Server, ref)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsageStatusConfig(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsageStatusConfigRequest(c.Server, ref)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBuckets(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBucketsRequest(c.Server, ref)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBucketWithBody(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBucketRequestWithBody(c.Server, ref, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBucket(ctx context.Context, ref string, body CreateBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBucketRequest(c.Server, ref, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBucket(ctx context.Context, ref string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBucketRequest(c.Server, ref, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBucket(ctx context.Context, ref string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBucketRequest(c.Server, ref, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBucketWithBody(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBucketRequestWithBody(c.Server, ref, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBucket(ctx context.Context, ref string, id string, body UpdateBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBucketRequest(c.Server, ref, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmptyBucket(ctx context.Context, ref string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmptyBucketRequest(c.Server, ref, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteObjectsWithBody(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteObjectsRequestWithBody(c.Server, ref, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteObjects(ctx context.Context, ref string, id string, body DeleteObjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteObjectsRequest(c.Server, ref, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CopyObjectWithBody(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCopyObjectRequestWithBody(c.Server, ref, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CopyObject(ctx context.Context, ref string, id string, body CopyObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCopyObjectRequest(c.Server, ref, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadWithBody(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadRequestWithBody(c.Server, ref, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Download(ctx context.Context, ref string, id string, body DownloadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadRequest(c.Server, ref, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetObjectsWithBody(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetObjectsRequestWithBody(c.Server, ref, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetObjects(ctx context.Context, ref string, id string, body GetObjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetObjectsRequest(c.Server, ref, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MoveObjectWithBody(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMoveObjectRequestWithBody(c.Server, ref, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MoveObject(ctx context.Context, ref string, id string, body MoveObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMoveObjectRequest(c.Server, ref, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePublicUrlWithBody(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePublicUrlRequestWithBody(c.Server, ref, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePublicUrl(ctx context.Context, ref string, id string, body CreatePublicUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePublicUrlRequest(c.Server, ref, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSignedUrlWithBody(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSignedUrlRequestWithBody(c.Server, ref, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSignedUrl(ctx context.Context, ref string, id string, body CreateSignedUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSignedUrlRequest(c.Server, ref, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSignedUrlsWithBody(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSignedUrlsRequestWithBody(c.Server, ref, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSignedUrls(ctx context.Context, ref string, id string, body CreateSignedUrlsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSignedUrlsRequest(c.Server, ref, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetGoTrueConfigRequest generates requests for GetGoTrueConfig
func NewGetGoTrueConfigRequest(server string, ref string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/auth/%s/config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateGoTrueConfigRequest calls the generic UpdateGoTrueConfig builder with application/json body
func NewUpdateGoTrueConfigRequest(server string, ref string, body UpdateGoTrueConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateGoTrueConfigRequestWithBody(server, ref, "application/json", bodyReader)
}

// NewUpdateGoTrueConfigRequestWithBody generates requests for UpdateGoTrueConfig with any type of body
func NewUpdateGoTrueConfigRequestWithBody(server string, ref string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/auth/%s/config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSendInviteRequest calls the generic SendInvite builder with application/json body
func NewSendInviteRequest(server string, ref string, body SendInviteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendInviteRequestWithBody(server, ref, "application/json", bodyReader)
}

// NewSendInviteRequestWithBody generates requests for SendInvite with any type of body
func NewSendInviteRequestWithBody(server string, ref string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/auth/%s/invite", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSendMagicLinkRequest calls the generic SendMagicLink builder with application/json body
func NewSendMagicLinkRequest(server string, ref string, body SendMagicLinkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendMagicLinkRequestWithBody(server, ref, "application/json", bodyReader)
}

// NewSendMagicLinkRequestWithBody generates requests for SendMagicLink with any type of body
func NewSendMagicLinkRequestWithBody(server string, ref string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/auth/%s/magiclink", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSendOtpRequest calls the generic SendOtp builder with application/json body
func NewSendOtpRequest(server string, ref string, body SendOtpJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendOtpRequestWithBody(server, ref, "application/json", bodyReader)
}

// NewSendOtpRequestWithBody generates requests for SendOtp with any type of body
func NewSendOtpRequestWithBody(server string, ref string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/auth/%s/otp", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSendRecoverRequest calls the generic SendRecover builder with application/json body
func NewSendRecoverRequest(server string, ref string, body SendRecoverJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendRecoverRequestWithBody(server, ref, "application/json", bodyReader)
}

// NewSendRecoverRequestWithBody generates requests for SendRecover with any type of body
func NewSendRecoverRequestWithBody(server string, ref string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/auth/%s/recover", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTemplateRequest generates requests for GetTemplate
func NewGetTemplateRequest(server string, ref string, template GetTemplateParamsTemplate) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "template", runtime.ParamLocationPath, template)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/auth/%s/templates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteUserRequest calls the generic DeleteUser builder with application/json body
func NewDeleteUserRequest(server string, ref string, body DeleteUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteUserRequestWithBody(server, ref, "application/json", bodyReader)
}

// NewDeleteUserRequestWithBody generates requests for DeleteUser with any type of body
func NewDeleteUserRequestWithBody(server string, ref string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/auth/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUsersRequest generates requests for GetUsers
func NewGetUsersRequest(server string, ref string, params *GetUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/auth/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keywords", runtime.ParamLocationQuery, params.Keywords); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "verified", runtime.ParamLocationQuery, params.Verified); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteFactorsRequest generates requests for DeleteFactors
func NewDeleteFactorsRequest(server string, ref string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/auth/%s/users/%s/factors", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBackupsRequest generates requests for GetBackups
func NewGetBackupsRequest(server string, ref string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/database/%s/backups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadBackupRequest calls the generic DownloadBackup builder with application/json body
func NewDownloadBackupRequest(server string, ref string, body DownloadBackupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDownloadBackupRequestWithBody(server, ref, "application/json", bodyReader)
}

// NewDownloadBackupRequestWithBody generates requests for DownloadBackup with any type of body
func NewDownloadBackupRequestWithBody(server string, ref string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/database/%s/backups/download", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRestorePointInTimeBackupRequest calls the generic RestorePointInTimeBackup builder with application/json body
func NewRestorePointInTimeBackupRequest(server string, ref string, body RestorePointInTimeBackupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRestorePointInTimeBackupRequestWithBody(server, ref, "application/json", bodyReader)
}

// NewRestorePointInTimeBackupRequestWithBody generates requests for RestorePointInTimeBackup with any type of body
func NewRestorePointInTimeBackupRequestWithBody(server string, ref string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/database/%s/backups/pitr", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRestoreBackupRequest calls the generic RestoreBackup builder with application/json body
func NewRestoreBackupRequest(server string, ref string, body RestoreBackupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRestoreBackupRequestWithBody(server, ref, "application/json", bodyReader)
}

// NewRestoreBackupRequestWithBody generates requests for RestoreBackup with any type of body
func NewRestoreBackupRequestWithBody(server string, ref string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/database/%s/backups/restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRestorePhysicalBackupRequest calls the generic RestorePhysicalBackup builder with application/json body
func NewRestorePhysicalBackupRequest(server string, ref string, body RestorePhysicalBackupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRestorePhysicalBackupRequestWithBody(server, ref, "application/json", bodyReader)
}

// NewRestorePhysicalBackupRequestWithBody generates requests for RestorePhysicalBackup with any type of body
func NewRestorePhysicalBackupRequestWithBody(server string, ref string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/database/%s/backups/restore-physical", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEnableHooksRequest generates requests for EnableHooks
func NewEnableHooksRequest(server string, ref string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/database/%s/hook-enable", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHookLogsRequest generates requests for GetHookLogs
func NewGetHookLogsRequest(server string, ref string, params *GetHookLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/database/%s/hook-logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewDeleteNotificationsRequest calls the generic DeleteNotifications builder with application/json body
func NewDeleteNotificationsRequest(server string, body DeleteNotificationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteNotificationsRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteNotificationsRequestWithBody generates requests for DeleteNotifications with any type of body
func NewDeleteNotificationsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/notifications")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNotificationsV2Request generates requests for GetNotificationsV2
func NewGetNotificationsV2Request(server string, params *GetNotificationsV2Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/notifications")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Archived != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "archived", runtime.ParamLocationQuery, *params.Archived); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateNotificationsV2Request calls the generic UpdateNotificationsV2 builder with application/json body
func NewUpdateNotificationsV2Request(server string, body UpdateNotificationsV2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateNotificationsV2RequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateNotificationsV2RequestWithBody generates requests for UpdateNotificationsV2 with any type of body
func NewUpdateNotificationsV2RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/notifications")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOrganizationsRequest generates requests for GetOrganizations
func NewGetOrganizationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/organizations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOrganizationWithTierRequest calls the generic CreateOrganizationWithTier builder with application/json body
func NewCreateOrganizationWithTierRequest(server string, body CreateOrganizationWithTierJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrganizationWithTierRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateOrganizationWithTierRequestWithBody generates requests for CreateOrganizationWithTier with any type of body
func NewCreateOrganizationWithTierRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/organizations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOrganizationRequest generates requests for DeleteOrganization
func NewDeleteOrganizationRequest(server string, slug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "slug", runtime.ParamLocationPath, slug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/organizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOrganizationRequest calls the generic UpdateOrganization builder with application/json body
func NewUpdateOrganizationRequest(server string, slug string, body UpdateOrganizationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOrganizationRequestWithBody(server, slug, "application/json", bodyReader)
}

// NewUpdateOrganizationRequestWithBody generates requests for UpdateOrganization with any type of body
func NewUpdateOrganizationRequestWithBody(server string, slug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "slug", runtime.ParamLocationPath, slug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/organizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMembersRequest generates requests for GetMembers
func NewGetMembersRequest(server string, slug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "slug", runtime.ParamLocationPath, slug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/organizations/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteInvitedUserRequest generates requests for DeleteInvitedUser
func NewDeleteInvitedUserRequest(server string, slug string, params *DeleteInvitedUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "slug", runtime.ParamLocationPath, slug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/organizations/%s/members/invite", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "invited_id", runtime.ParamLocationQuery, params.InvitedId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvitedUsersRequest generates requests for GetInvitedUsers
func NewGetInvitedUsersRequest(server string, slug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "slug", runtime.ParamLocationPath, slug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/organizations/%s/members/invite", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInviteUserRequest calls the generic InviteUser builder with application/json body
func NewInviteUserRequest(server string, slug string, body InviteUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInviteUserRequestWithBody(server, slug, "application/json", bodyReader)
}

// NewInviteUserRequestWithBody generates requests for InviteUser with any type of body
func NewInviteUserRequestWithBody(server string, slug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "slug", runtime.ParamLocationPath, slug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/organizations/%s/members/invite", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetInviteRequest generates requests for GetInvite
func NewGetInviteRequest(server string, slug string, params *GetInviteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "slug", runtime.ParamLocationPath, slug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/organizations/%s/members/join", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, params.Token); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewJoinOrganizationRequest generates requests for JoinOrganization
func NewJoinOrganizationRequest(server string, slug string, params *JoinOrganizationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "slug", runtime.ParamLocationPath, slug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/organizations/%s/members/join", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, params.Token); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteMemberRequest generates requests for DeleteMember
func NewDeleteMemberRequest(server string, slug string, gotrueId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "slug", runtime.ParamLocationPath, slug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "gotrue_id", runtime.ParamLocationPath, gotrueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/organizations/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateMemberRequest calls the generic UpdateMember builder with application/json body
func NewUpdateMemberRequest(server string, slug string, gotrueId string, body UpdateMemberJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMemberRequestWithBody(server, slug, gotrueId, "application/json", bodyReader)
}

// NewUpdateMemberRequestWithBody generates requests for UpdateMember with any type of body
func NewUpdateMemberRequestWithBody(server string, slug string, gotrueId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "slug", runtime.ParamLocationPath, slug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "gotrue_id", runtime.ParamLocationPath, gotrueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/organizations/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddMemberRequest generates requests for AddMember
func NewAddMemberRequest(server string, slug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "slug", runtime.ParamLocationPath, slug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/organizations/%s/roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevokeColumnPrivilegesRequest calls the generic RevokeColumnPrivileges builder with application/json body
func NewRevokeColumnPrivilegesRequest(server string, ref string, params *RevokeColumnPrivilegesParams, body RevokeColumnPrivilegesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevokeColumnPrivilegesRequestWithBody(server, ref, params, "application/json", bodyReader)
}

// NewRevokeColumnPrivilegesRequestWithBody generates requests for RevokeColumnPrivileges with any type of body
func NewRevokeColumnPrivilegesRequestWithBody(server string, ref string, params *RevokeColumnPrivilegesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/column-privileges", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewGetColumnPrivilegesRequest generates requests for GetColumnPrivileges
func NewGetColumnPrivilegesRequest(server string, ref string, params *GetColumnPrivilegesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/column-privileges", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewGrantColumnPrivilegesRequest calls the generic GrantColumnPrivileges builder with application/json body
func NewGrantColumnPrivilegesRequest(server string, ref string, params *GrantColumnPrivilegesParams, body GrantColumnPrivilegesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGrantColumnPrivilegesRequestWithBody(server, ref, params, "application/json", bodyReader)
}

// NewGrantColumnPrivilegesRequestWithBody generates requests for GrantColumnPrivileges with any type of body
func NewGrantColumnPrivilegesRequestWithBody(server string, ref string, params *GrantColumnPrivilegesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/column-privileges", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewDeleteColumnRequest generates requests for DeleteColumn
func NewDeleteColumnRequest(server string, ref string, params *DeleteColumnParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/columns", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Cascade != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cascade", runtime.ParamLocationQuery, *params.Cascade); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewGetColumnsRequest generates requests for GetColumns
func NewGetColumnsRequest(server string, ref string, params *GetColumnsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/columns", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "included_schemas", runtime.ParamLocationQuery, params.IncludedSchemas); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excluded_schemas", runtime.ParamLocationQuery, params.ExcludedSchemas); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewUpdateColumnRequest calls the generic UpdateColumn builder with application/json body
func NewUpdateColumnRequest(server string, ref string, params *UpdateColumnParams, body UpdateColumnJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateColumnRequestWithBody(server, ref, params, "application/json", bodyReader)
}

// NewUpdateColumnRequestWithBody generates requests for UpdateColumn with any type of body
func NewUpdateColumnRequestWithBody(server string, ref string, params *UpdateColumnParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/columns", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewCreateColumnRequest calls the generic CreateColumn builder with application/json body
func NewCreateColumnRequest(server string, ref string, params *CreateColumnParams, body CreateColumnJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateColumnRequestWithBody(server, ref, params, "application/json", bodyReader)
}

// NewCreateColumnRequestWithBody generates requests for CreateColumn with any type of body
func NewCreateColumnRequestWithBody(server string, ref string, params *CreateColumnParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/columns", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewDeleteExtensionRequest generates requests for DeleteExtension
func NewDeleteExtensionRequest(server string, ref string, params *DeleteExtensionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/extensions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewGetExtensionsRequest generates requests for GetExtensions
func NewGetExtensionsRequest(server string, ref string, params *GetExtensionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/extensions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewCreateExtensionRequest calls the generic CreateExtension builder with application/json body
func NewCreateExtensionRequest(server string, ref string, params *CreateExtensionParams, body CreateExtensionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateExtensionRequestWithBody(server, ref, params, "application/json", bodyReader)
}

// NewCreateExtensionRequestWithBody generates requests for CreateExtension with any type of body
func NewCreateExtensionRequestWithBody(server string, ref string, params *CreateExtensionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/extensions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewGetForeignTablesRequest generates requests for GetForeignTables
func NewGetForeignTablesRequest(server string, ref string, params *GetForeignTablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/foreign-tables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_columns", runtime.ParamLocationQuery, params.IncludeColumns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewDeleteFunctionRequest generates requests for DeleteFunction
func NewDeleteFunctionRequest(server string, ref string, params *DeleteFunctionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/functions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewGetFunctionsRequest generates requests for GetFunctions
func NewGetFunctionsRequest(server string, ref string, params *GetFunctionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/functions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "included_schemas", runtime.ParamLocationQuery, params.IncludedSchemas); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excluded_schemas", runtime.ParamLocationQuery, params.ExcludedSchemas); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewUpdateFunctionRequest calls the generic UpdateFunction builder with application/json body
func NewUpdateFunctionRequest(server string, ref string, params *UpdateFunctionParams, body UpdateFunctionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFunctionRequestWithBody(server, ref, params, "application/json", bodyReader)
}

// NewUpdateFunctionRequestWithBody generates requests for UpdateFunction with any type of body
func NewUpdateFunctionRequestWithBody(server string, ref string, params *UpdateFunctionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/functions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewCreateFunctionRequest calls the generic CreateFunction builder with application/json body
func NewCreateFunctionRequest(server string, ref string, params *CreateFunctionParams, body CreateFunctionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFunctionRequestWithBody(server, ref, params, "application/json", bodyReader)
}

// NewCreateFunctionRequestWithBody generates requests for CreateFunction with any type of body
func NewCreateFunctionRequestWithBody(server string, ref string, params *CreateFunctionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/functions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewGetMaterializedViewsRequest generates requests for GetMaterializedViews
func NewGetMaterializedViewsRequest(server string, ref string, params *GetMaterializedViewsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/materialized-views", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "included_schemas", runtime.ParamLocationQuery, params.IncludedSchemas); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excluded_schemas", runtime.ParamLocationQuery, params.ExcludedSchemas); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_columns", runtime.ParamLocationQuery, params.IncludeColumns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewDeletePolicyRequest generates requests for DeletePolicy
func NewDeletePolicyRequest(server string, ref string, params *DeletePolicyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/policies", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewGetPoliciesRequest generates requests for GetPolicies
func NewGetPoliciesRequest(server string, ref string, params *GetPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/policies", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "included_schemas", runtime.ParamLocationQuery, params.IncludedSchemas); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excluded_schemas", runtime.ParamLocationQuery, params.ExcludedSchemas); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewUpdatePolicyRequest calls the generic UpdatePolicy builder with application/json body
func NewUpdatePolicyRequest(server string, ref string, params *UpdatePolicyParams, body UpdatePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePolicyRequestWithBody(server, ref, params, "application/json", bodyReader)
}

// NewUpdatePolicyRequestWithBody generates requests for UpdatePolicy with any type of body
func NewUpdatePolicyRequestWithBody(server string, ref string, params *UpdatePolicyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/policies", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewCreatePolicyRequest calls the generic CreatePolicy builder with application/json body
func NewCreatePolicyRequest(server string, ref string, params *CreatePolicyParams, body CreatePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePolicyRequestWithBody(server, ref, params, "application/json", bodyReader)
}

// NewCreatePolicyRequestWithBody generates requests for CreatePolicy with any type of body
func NewCreatePolicyRequestWithBody(server string, ref string, params *CreatePolicyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/policies", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewDeletePublicationRequest generates requests for DeletePublication
func NewDeletePublicationRequest(server string, ref string, params *DeletePublicationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/publications", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewGetPublicationsRequest generates requests for GetPublications
func NewGetPublicationsRequest(server string, ref string, params *GetPublicationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/publications", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewUpdatePublicationRequest calls the generic UpdatePublication builder with application/json body
func NewUpdatePublicationRequest(server string, ref string, params *UpdatePublicationParams, body UpdatePublicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePublicationRequestWithBody(server, ref, params, "application/json", bodyReader)
}

// NewUpdatePublicationRequestWithBody generates requests for UpdatePublication with any type of body
func NewUpdatePublicationRequestWithBody(server string, ref string, params *UpdatePublicationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/publications", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewCreatePublicationRequest calls the generic CreatePublication builder with application/json body
func NewCreatePublicationRequest(server string, ref string, params *CreatePublicationParams, body CreatePublicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePublicationRequestWithBody(server, ref, params, "application/json", bodyReader)
}

// NewCreatePublicationRequestWithBody generates requests for CreatePublication with any type of body
func NewCreatePublicationRequestWithBody(server string, ref string, params *CreatePublicationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/publications", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewRunQueryRequest calls the generic RunQuery builder with application/json body
func NewRunQueryRequest(server string, ref string, params *RunQueryParams, body RunQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunQueryRequestWithBody(server, ref, params, "application/json", bodyReader)
}

// NewRunQueryRequestWithBody generates requests for RunQuery with any type of body
func NewRunQueryRequestWithBody(server string, ref string, params *RunQueryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/query", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewFormatQueryRequest calls the generic FormatQuery builder with application/json body
func NewFormatQueryRequest(server string, ref string, body FormatQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFormatQueryRequestWithBody(server, ref, "application/json", bodyReader)
}

// NewFormatQueryRequestWithBody generates requests for FormatQuery with any type of body
func NewFormatQueryRequestWithBody(server string, ref string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/query/format", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewValidateQueryRequest calls the generic ValidateQuery builder with application/json body
func NewValidateQueryRequest(server string, ref string, body ValidateQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateQueryRequestWithBody(server, ref, "application/json", bodyReader)
}

// NewValidateQueryRequestWithBody generates requests for ValidateQuery with any type of body
func NewValidateQueryRequestWithBody(server string, ref string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/query/validate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRoleRequest generates requests for DeleteRole
func NewDeleteRoleRequest(server string, ref string, params *DeleteRoleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewGetRolesRequest generates requests for GetRoles
func NewGetRolesRequest(server string, ref string, params *GetRolesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewUpdateRoleRequest calls the generic UpdateRole builder with application/json body
func NewUpdateRoleRequest(server string, ref string, params *UpdateRoleParams, body UpdateRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRoleRequestWithBody(server, ref, params, "application/json", bodyReader)
}

// NewUpdateRoleRequestWithBody generates requests for UpdateRole with any type of body
func NewUpdateRoleRequestWithBody(server string, ref string, params *UpdateRoleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewCreateRoleRequest calls the generic CreateRole builder with application/json body
func NewCreateRoleRequest(server string, ref string, params *CreateRoleParams, body CreateRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRoleRequestWithBody(server, ref, params, "application/json", bodyReader)
}

// NewCreateRoleRequestWithBody generates requests for CreateRole with any type of body
func NewCreateRoleRequestWithBody(server string, ref string, params *CreateRoleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewDeleteSchemaRequest generates requests for DeleteSchema
func NewDeleteSchemaRequest(server string, ref string, params *DeleteSchemaParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/schemas", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewGetSchemasRequest generates requests for GetSchemas
func NewGetSchemasRequest(server string, ref string, params *GetSchemasParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/schemas", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewUpdateSchemaRequest calls the generic UpdateSchema builder with application/json body
func NewUpdateSchemaRequest(server string, ref string, params *UpdateSchemaParams, body UpdateSchemaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSchemaRequestWithBody(server, ref, params, "application/json", bodyReader)
}

// NewUpdateSchemaRequestWithBody generates requests for UpdateSchema with any type of body
func NewUpdateSchemaRequestWithBody(server string, ref string, params *UpdateSchemaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/schemas", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewCreateSchemaRequest calls the generic CreateSchema builder with application/json body
func NewCreateSchemaRequest(server string, ref string, params *CreateSchemaParams, body CreateSchemaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSchemaRequestWithBody(server, ref, params, "application/json", bodyReader)
}

// NewCreateSchemaRequestWithBody generates requests for CreateSchema with any type of body
func NewCreateSchemaRequestWithBody(server string, ref string, params *CreateSchemaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/schemas", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewSearchColumnsRequest calls the generic SearchColumns builder with application/json body
func NewSearchColumnsRequest(server string, ref string, params *SearchColumnsParams, body SearchColumnsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchColumnsRequestWithBody(server, ref, params, "application/json", bodyReader)
}

// NewSearchColumnsRequestWithBody generates requests for SearchColumns with any type of body
func NewSearchColumnsRequestWithBody(server string, ref string, params *SearchColumnsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/search/columns", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewSearchTablesRequest calls the generic SearchTables builder with application/json body
func NewSearchTablesRequest(server string, ref string, params *SearchTablesParams, body SearchTablesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchTablesRequestWithBody(server, ref, params, "application/json", bodyReader)
}

// NewSearchTablesRequestWithBody generates requests for SearchTables with any type of body
func NewSearchTablesRequestWithBody(server string, ref string, params *SearchTablesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/search/tables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewRevokeTablePrivilegesRequest calls the generic RevokeTablePrivileges builder with application/json body
func NewRevokeTablePrivilegesRequest(server string, ref string, params *RevokeTablePrivilegesParams, body RevokeTablePrivilegesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevokeTablePrivilegesRequestWithBody(server, ref, params, "application/json", bodyReader)
}

// NewRevokeTablePrivilegesRequestWithBody generates requests for RevokeTablePrivileges with any type of body
func NewRevokeTablePrivilegesRequestWithBody(server string, ref string, params *RevokeTablePrivilegesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/table-privileges", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewGetTablePrivilegesRequest generates requests for GetTablePrivileges
func NewGetTablePrivilegesRequest(server string, ref string, params *GetTablePrivilegesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/table-privileges", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewGrantTablePrivilegesRequest calls the generic GrantTablePrivileges builder with application/json body
func NewGrantTablePrivilegesRequest(server string, ref string, params *GrantTablePrivilegesParams, body GrantTablePrivilegesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGrantTablePrivilegesRequestWithBody(server, ref, params, "application/json", bodyReader)
}

// NewGrantTablePrivilegesRequestWithBody generates requests for GrantTablePrivileges with any type of body
func NewGrantTablePrivilegesRequestWithBody(server string, ref string, params *GrantTablePrivilegesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/table-privileges", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewDeleteTableRequest generates requests for DeleteTable
func NewDeleteTableRequest(server string, ref string, params *DeleteTableParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/tables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cascade", runtime.ParamLocationQuery, params.Cascade); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewGetTablesRequest generates requests for GetTables
func NewGetTablesRequest(server string, ref string, params *GetTablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/tables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_system_schemas", runtime.ParamLocationQuery, params.IncludeSystemSchemas); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "included_schemas", runtime.ParamLocationQuery, params.IncludedSchemas); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excluded_schemas", runtime.ParamLocationQuery, params.ExcludedSchemas); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_columns", runtime.ParamLocationQuery, params.IncludeColumns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewUpdateTableRequest calls the generic UpdateTable builder with application/json body
func NewUpdateTableRequest(server string, ref string, params *UpdateTableParams, body UpdateTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTableRequestWithBody(server, ref, params, "application/json", bodyReader)
}

// NewUpdateTableRequestWithBody generates requests for UpdateTable with any type of body
func NewUpdateTableRequestWithBody(server string, ref string, params *UpdateTableParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/tables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewCreateTableRequest calls the generic CreateTable builder with application/json body
func NewCreateTableRequest(server string, ref string, params *CreateTableParams, body CreateTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTableRequestWithBody(server, ref, params, "application/json", bodyReader)
}

// NewCreateTableRequestWithBody generates requests for CreateTable with any type of body
func NewCreateTableRequestWithBody(server string, ref string, params *CreateTableParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/tables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewDeleteTriggerRequest generates requests for DeleteTrigger
func NewDeleteTriggerRequest(server string, ref string, params *DeleteTriggerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/triggers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewGetTriggersRequest generates requests for GetTriggers
func NewGetTriggersRequest(server string, ref string, params *GetTriggersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/triggers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "included_schemas", runtime.ParamLocationQuery, params.IncludedSchemas); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excluded_schemas", runtime.ParamLocationQuery, params.ExcludedSchemas); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewUpdateTriggerRequest calls the generic UpdateTrigger builder with application/json body
func NewUpdateTriggerRequest(server string, ref string, params *UpdateTriggerParams, body UpdateTriggerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTriggerRequestWithBody(server, ref, params, "application/json", bodyReader)
}

// NewUpdateTriggerRequestWithBody generates requests for UpdateTrigger with any type of body
func NewUpdateTriggerRequestWithBody(server string, ref string, params *UpdateTriggerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/triggers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewCreateTriggerRequest calls the generic CreateTrigger builder with application/json body
func NewCreateTriggerRequest(server string, ref string, params *CreateTriggerParams, body CreateTriggerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTriggerRequestWithBody(server, ref, params, "application/json", bodyReader)
}

// NewCreateTriggerRequestWithBody generates requests for CreateTrigger with any type of body
func NewCreateTriggerRequestWithBody(server string, ref string, params *CreateTriggerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/triggers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewGetTypesRequest generates requests for GetTypes
func NewGetTypesRequest(server string, ref string, params *GetTypesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/types", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "included_schemas", runtime.ParamLocationQuery, params.IncludedSchemas); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excluded_schemas", runtime.ParamLocationQuery, params.ExcludedSchemas); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewGetViewsRequest generates requests for GetViews
func NewGetViewsRequest(server string, ref string, params *GetViewsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/pg-meta/%s/views", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_system_schemas", runtime.ParamLocationQuery, params.IncludeSystemSchemas); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "included_schemas", runtime.ParamLocationQuery, params.IncludedSchemas); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excluded_schemas", runtime.ParamLocationQuery, params.ExcludedSchemas); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_columns", runtime.ParamLocationQuery, params.IncludeColumns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, params.XConnectionEncrypted)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-connection-encrypted", headerParam0)

	}

	return req, nil
}

// NewGetProjectsRequest generates requests for GetProjects
func NewGetProjectsRequest(server string, params *GetProjectsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_readonly_mode_status", runtime.ParamLocationQuery, params.IncludeReadonlyModeStatus); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProjectRequest calls the generic CreateProject builder with application/json body
func NewCreateProjectRequest(server string, body CreateProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateProjectRequestWithBody generates requests for CreateProject with any type of body
func NewCreateProjectRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProjectsMetricsRequest calls the generic GetProjectsMetrics builder with application/json body
func NewGetProjectsMetricsRequest(server string, body GetProjectsMetricsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetProjectsMetricsRequestWithBody(server, "application/json", bodyReader)
}

// NewGetProjectsMetricsRequestWithBody generates requests for GetProjectsMetrics with any type of body
func NewGetProjectsMetricsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProjectRequest generates requests for DeleteProject
func NewDeleteProjectRequest(server string, ref string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectRequest generates requests for GetProject
func NewGetProjectRequest(server string, ref string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProjectRequest calls the generic UpdateProject builder with application/json body
func NewUpdateProjectRequest(server string, ref string, body UpdateProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProjectRequestWithBody(server, ref, "application/json", bodyReader)
}

// NewUpdateProjectRequestWithBody generates requests for UpdateProject with any type of body
func NewUpdateProjectRequestWithBody(server string, ref string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFunctionStatusRequest generates requests for GetFunctionStatus
func NewGetFunctionStatusRequest(server string, ref string, params *GetFunctionStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/analytics/endpoints/functions.inv-stats", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "interval", runtime.ParamLocationQuery, params.Interval); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "function_id", runtime.ParamLocationQuery, params.FunctionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetApiPathsRequest generates requests for GetApiPaths
func NewGetApiPathsRequest(server string, ref string, params *GetApiPathsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/analytics/endpoints/logs.all", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sql", runtime.ParamLocationQuery, params.Sql); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project", runtime.ParamLocationQuery, params.Project); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "iso_timestamp_start", runtime.ParamLocationQuery, params.IsoTimestampStart); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "iso_timestamp_end", runtime.ParamLocationQuery, params.IsoTimestampEnd); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp_start", runtime.ParamLocationQuery, params.TimestampStart); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp_end", runtime.ParamLocationQuery, params.TimestampEnd); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetApiCountsRequest generates requests for GetApiCounts
func NewGetApiCountsRequest(server string, ref string, params *GetApiCountsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/analytics/endpoints/usage.api-counts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "interval", runtime.ParamLocationQuery, params.Interval); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectGraphqlRequest calls the generic ProjectGraphql builder with application/json body
func NewProjectGraphqlRequest(server string, ref string, params *ProjectGraphqlParams, body ProjectGraphqlJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProjectGraphqlRequestWithBody(server, ref, params, "application/json", bodyReader)
}

// NewProjectGraphqlRequestWithBody generates requests for ProjectGraphql with any type of body
func NewProjectGraphqlRequestWithBody(server string, ref string, params *ProjectGraphqlParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/api/graphql", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-graphql-authorization", runtime.ParamLocationHeader, params.XGraphqlAuthorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-graphql-authorization", headerParam0)

	}

	return req, nil
}

// NewProjectOpenApiRequest generates requests for ProjectOpenApi
func NewProjectOpenApiRequest(server string, ref string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/api/rest", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPgbouncerConfigRequest generates requests for GetPgbouncerConfig
func NewGetPgbouncerConfigRequest(server string, ref string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/config/pgbouncer", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePgbouncerConfigRequest calls the generic UpdatePgbouncerConfig builder with application/json body
func NewUpdatePgbouncerConfigRequest(server string, ref string, body UpdatePgbouncerConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePgbouncerConfigRequestWithBody(server, ref, "application/json", bodyReader)
}

// NewUpdatePgbouncerConfigRequestWithBody generates requests for UpdatePgbouncerConfig with any type of body
func NewUpdatePgbouncerConfigRequestWithBody(server string, ref string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/config/pgbouncer", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetConfigRequest generates requests for GetConfig
func NewGetConfigRequest(server string, ref string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/config/postgres", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateConfigRequest calls the generic UpdateConfig builder with application/json body
func NewUpdateConfigRequest(server string, ref string, body UpdateConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateConfigRequestWithBody(server, ref, "application/json", bodyReader)
}

// NewUpdateConfigRequestWithBody generates requests for UpdateConfig with any type of body
func NewUpdateConfigRequestWithBody(server string, ref string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/config/postgres", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPostgRESTConfigRequest generates requests for GetPostgRESTConfig
func NewGetPostgRESTConfigRequest(server string, ref string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/config/postgrest", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePostgRESTConfigRequest calls the generic UpdatePostgRESTConfig builder with application/json body
func NewUpdatePostgRESTConfigRequest(server string, ref string, body UpdatePostgRESTConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePostgRESTConfigRequestWithBody(server, ref, "application/json", bodyReader)
}

// NewUpdatePostgRESTConfigRequestWithBody generates requests for UpdatePostgRESTConfig with any type of body
func NewUpdatePostgRESTConfigRequestWithBody(server string, ref string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/config/postgrest", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateConfigRequest calls the generic UpdateConfig builder with application/json body
func NewUpdateConfigRequest(server string, ref string, body UpdateConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateConfigRequestWithBody(server, ref, "application/json", bodyReader)
}

// NewUpdateConfigRequestWithBody generates requests for UpdateConfig with any type of body
func NewUpdateConfigRequestWithBody(server string, ref string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/config/secrets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStorageConfigRequest generates requests for GetStorageConfig
func NewGetStorageConfigRequest(server string, ref string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/config/storage", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateConfigRequest calls the generic UpdateConfig builder with application/json body
func NewUpdateConfigRequest(server string, ref string, body UpdateConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateConfigRequestWithBody(server, ref, "application/json", bodyReader)
}

// NewUpdateConfigRequestWithBody generates requests for UpdateConfig with any type of body
func NewUpdateConfigRequestWithBody(server string, ref string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/config/storage", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteContentRequest generates requests for DeleteContent
func NewDeleteContentRequest(server string, ref string, params *DeleteContentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/content", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectContentRequest generates requests for GetProjectContent
func NewGetProjectContentRequest(server string, ref string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/content", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateContentRequest calls the generic UpdateContent builder with application/json body
func NewUpdateContentRequest(server string, ref string, body UpdateContentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateContentRequestWithBody(server, ref, "application/json", bodyReader)
}

// NewUpdateContentRequestWithBody generates requests for UpdateContent with any type of body
func NewUpdateContentRequestWithBody(server string, ref string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/content", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateContentRequest calls the generic CreateContent builder with application/json body
func NewCreateContentRequest(server string, ref string, body CreateContentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateContentRequestWithBody(server, ref, "application/json", bodyReader)
}

// NewCreateContentRequestWithBody generates requests for CreateContent with any type of body
func NewCreateContentRequestWithBody(server string, ref string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/content", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateWholeContentRequest calls the generic UpdateWholeContent builder with application/json body
func NewUpdateWholeContentRequest(server string, ref string, body UpdateWholeContentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateWholeContentRequestWithBody(server, ref, "application/json", bodyReader)
}

// NewUpdateWholeContentRequestWithBody generates requests for UpdateWholeContent with any type of body
func NewUpdateWholeContentRequestWithBody(server string, ref string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/content", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDailyStatsRequest generates requests for GetDailyStats
func NewGetDailyStatsRequest(server string, ref string, params *GetDailyStatsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/daily-stats", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "attribute", runtime.ParamLocationQuery, params.Attribute); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "interval", runtime.ParamLocationQuery, params.Interval); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, params.EndDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, params.StartDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePasswordRequest calls the generic UpdatePassword builder with application/json body
func NewUpdatePasswordRequest(server string, ref string, body UpdatePasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePasswordRequestWithBody(server, ref, "application/json", bodyReader)
}

// NewUpdatePasswordRequestWithBody generates requests for UpdatePassword with any type of body
func NewUpdatePasswordRequestWithBody(server string, ref string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/db-password", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUsageMetricsRequest generates requests for GetUsageMetrics
func NewGetUsageMetricsRequest(server string, ref string, params *GetUsageMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/infra-monitoring", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "attribute", runtime.ParamLocationQuery, params.Attribute); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, params.StartDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, params.EndDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Interval != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "interval", runtime.ParamLocationQuery, *params.Interval); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvoicesRequest generates requests for GetInvoices
func NewGetInvoicesRequest(server string, ref string, params *GetInvoicesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/invoices", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvoiceCountRequest generates requests for GetInvoiceCount
func NewGetInvoiceCountRequest(server string, ref string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/invoices", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectHealthCheckRequest generates requests for ProjectHealthCheck
func NewProjectHealthCheckRequest(server string, ref string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/live", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPauseProjectRequest generates requests for PauseProject
func NewPauseProjectRequest(server string, ref string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/pause", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResizeDatabaseRequest calls the generic ResizeDatabase builder with application/json body
func NewResizeDatabaseRequest(server string, ref string, body ResizeDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResizeDatabaseRequestWithBody(server, ref, "application/json", bodyReader)
}

// NewResizeDatabaseRequestWithBody generates requests for ResizeDatabase with any type of body
func NewResizeDatabaseRequestWithBody(server string, ref string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/resize", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRestartProjectRequest generates requests for RestartProject
func NewRestartProjectRequest(server string, ref string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/restart", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestartServicesRequest calls the generic RestartServices builder with application/json body
func NewRestartServicesRequest(server string, ref string, body RestartServicesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRestartServicesRequestWithBody(server, ref, "application/json", bodyReader)
}

// NewRestartServicesRequestWithBody generates requests for RestartServices with any type of body
func NewRestartServicesRequestWithBody(server string, ref string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/restart-services", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRestoreProjectRequest calls the generic RestoreProject builder with application/json body
func NewRestoreProjectRequest(server string, ref string, body RestoreProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRestoreProjectRequestWithBody(server, ref, "application/json", bodyReader)
}

// NewRestoreProjectRequestWithBody generates requests for RestoreProject with any type of body
func NewRestoreProjectRequestWithBody(server string, ref string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProjectApiRequest generates requests for GetProjectApi
func NewGetProjectApiRequest(server string, ref string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectStatusRequest generates requests for GetProjectStatus
func NewGetProjectStatusRequest(server string, ref string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsageStatusConfigRequest generates requests for GetUsageStatusConfig
func NewGetUsageStatusConfigRequest(server string, ref string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/projects/%s/usage", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatusRequest generates requests for GetStatus
func NewGetStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBucketsRequest generates requests for GetBuckets
func NewGetBucketsRequest(server string, ref string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/storage/%s/buckets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBucketRequest calls the generic CreateBucket builder with application/json body
func NewCreateBucketRequest(server string, ref string, body CreateBucketJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBucketRequestWithBody(server, ref, "application/json", bodyReader)
}

// NewCreateBucketRequestWithBody generates requests for CreateBucket with any type of body
func NewCreateBucketRequestWithBody(server string, ref string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/storage/%s/buckets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBucketRequest generates requests for DeleteBucket
func NewDeleteBucketRequest(server string, ref string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/storage/%s/buckets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBucketRequest generates requests for GetBucket
func NewGetBucketRequest(server string, ref string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/storage/%s/buckets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateBucketRequest calls the generic UpdateBucket builder with application/json body
func NewUpdateBucketRequest(server string, ref string, id string, body UpdateBucketJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBucketRequestWithBody(server, ref, id, "application/json", bodyReader)
}

// NewUpdateBucketRequestWithBody generates requests for UpdateBucket with any type of body
func NewUpdateBucketRequestWithBody(server string, ref string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/storage/%s/buckets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEmptyBucketRequest generates requests for EmptyBucket
func NewEmptyBucketRequest(server string, ref string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/storage/%s/buckets/%s/empty", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteObjectsRequest calls the generic DeleteObjects builder with application/json body
func NewDeleteObjectsRequest(server string, ref string, id string, body DeleteObjectsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteObjectsRequestWithBody(server, ref, id, "application/json", bodyReader)
}

// NewDeleteObjectsRequestWithBody generates requests for DeleteObjects with any type of body
func NewDeleteObjectsRequestWithBody(server string, ref string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/storage/%s/buckets/%s/objects", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCopyObjectRequest calls the generic CopyObject builder with application/json body
func NewCopyObjectRequest(server string, ref string, id string, body CopyObjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCopyObjectRequestWithBody(server, ref, id, "application/json", bodyReader)
}

// NewCopyObjectRequestWithBody generates requests for CopyObject with any type of body
func NewCopyObjectRequestWithBody(server string, ref string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/storage/%s/buckets/%s/objects/copy", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDownloadRequest calls the generic Download builder with application/json body
func NewDownloadRequest(server string, ref string, id string, body DownloadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDownloadRequestWithBody(server, ref, id, "application/json", bodyReader)
}

// NewDownloadRequestWithBody generates requests for Download with any type of body
func NewDownloadRequestWithBody(server string, ref string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/storage/%s/buckets/%s/objects/download", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetObjectsRequest calls the generic GetObjects builder with application/json body
func NewGetObjectsRequest(server string, ref string, id string, body GetObjectsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetObjectsRequestWithBody(server, ref, id, "application/json", bodyReader)
}

// NewGetObjectsRequestWithBody generates requests for GetObjects with any type of body
func NewGetObjectsRequestWithBody(server string, ref string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/storage/%s/buckets/%s/objects/list", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMoveObjectRequest calls the generic MoveObject builder with application/json body
func NewMoveObjectRequest(server string, ref string, id string, body MoveObjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMoveObjectRequestWithBody(server, ref, id, "application/json", bodyReader)
}

// NewMoveObjectRequestWithBody generates requests for MoveObject with any type of body
func NewMoveObjectRequestWithBody(server string, ref string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/storage/%s/buckets/%s/objects/move", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePublicUrlRequest calls the generic CreatePublicUrl builder with application/json body
func NewCreatePublicUrlRequest(server string, ref string, id string, body CreatePublicUrlJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePublicUrlRequestWithBody(server, ref, id, "application/json", bodyReader)
}

// NewCreatePublicUrlRequestWithBody generates requests for CreatePublicUrl with any type of body
func NewCreatePublicUrlRequestWithBody(server string, ref string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/storage/%s/buckets/%s/objects/public-url", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateSignedUrlRequest calls the generic CreateSignedUrl builder with application/json body
func NewCreateSignedUrlRequest(server string, ref string, id string, body CreateSignedUrlJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSignedUrlRequestWithBody(server, ref, id, "application/json", bodyReader)
}

// NewCreateSignedUrlRequestWithBody generates requests for CreateSignedUrl with any type of body
func NewCreateSignedUrlRequestWithBody(server string, ref string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/storage/%s/buckets/%s/objects/sign", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateSignedUrlsRequest calls the generic CreateSignedUrls builder with application/json body
func NewCreateSignedUrlsRequest(server string, ref string, id string, body CreateSignedUrlsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSignedUrlsRequestWithBody(server, ref, id, "application/json", bodyReader)
}

// NewCreateSignedUrlsRequestWithBody generates requests for CreateSignedUrls with any type of body
func NewCreateSignedUrlsRequestWithBody(server string, ref string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/storage/%s/buckets/%s/objects/sign-multi", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetGoTrueConfigWithResponse request
	GetGoTrueConfigWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*GetGoTrueConfigResponse, error)

	// UpdateGoTrueConfigWithBodyWithResponse request with any body
	UpdateGoTrueConfigWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGoTrueConfigResponse, error)

	UpdateGoTrueConfigWithResponse(ctx context.Context, ref string, body UpdateGoTrueConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGoTrueConfigResponse, error)

	// SendInviteWithBodyWithResponse request with any body
	SendInviteWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendInviteResponse, error)

	SendInviteWithResponse(ctx context.Context, ref string, body SendInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*SendInviteResponse, error)

	// SendMagicLinkWithBodyWithResponse request with any body
	SendMagicLinkWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendMagicLinkResponse, error)

	SendMagicLinkWithResponse(ctx context.Context, ref string, body SendMagicLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*SendMagicLinkResponse, error)

	// SendOtpWithBodyWithResponse request with any body
	SendOtpWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendOtpResponse, error)

	SendOtpWithResponse(ctx context.Context, ref string, body SendOtpJSONRequestBody, reqEditors ...RequestEditorFn) (*SendOtpResponse, error)

	// SendRecoverWithBodyWithResponse request with any body
	SendRecoverWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendRecoverResponse, error)

	SendRecoverWithResponse(ctx context.Context, ref string, body SendRecoverJSONRequestBody, reqEditors ...RequestEditorFn) (*SendRecoverResponse, error)

	// GetTemplateWithResponse request
	GetTemplateWithResponse(ctx context.Context, ref string, template GetTemplateParamsTemplate, reqEditors ...RequestEditorFn) (*GetTemplateResponse, error)

	// DeleteUserWithBodyWithResponse request with any body
	DeleteUserWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	DeleteUserWithResponse(ctx context.Context, ref string, body DeleteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// GetUsersWithResponse request
	GetUsersWithResponse(ctx context.Context, ref string, params *GetUsersParams, reqEditors ...RequestEditorFn) (*GetUsersResponse, error)

	// DeleteFactorsWithResponse request
	DeleteFactorsWithResponse(ctx context.Context, ref string, id string, reqEditors ...RequestEditorFn) (*DeleteFactorsResponse, error)

	// GetBackupsWithResponse request
	GetBackupsWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*GetBackupsResponse, error)

	// DownloadBackupWithBodyWithResponse request with any body
	DownloadBackupWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DownloadBackupResponse, error)

	DownloadBackupWithResponse(ctx context.Context, ref string, body DownloadBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*DownloadBackupResponse, error)

	// RestorePointInTimeBackupWithBodyWithResponse request with any body
	RestorePointInTimeBackupWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestorePointInTimeBackupResponse, error)

	RestorePointInTimeBackupWithResponse(ctx context.Context, ref string, body RestorePointInTimeBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*RestorePointInTimeBackupResponse, error)

	// RestoreBackupWithBodyWithResponse request with any body
	RestoreBackupWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestoreBackupResponse, error)

	RestoreBackupWithResponse(ctx context.Context, ref string, body RestoreBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*RestoreBackupResponse, error)

	// RestorePhysicalBackupWithBodyWithResponse request with any body
	RestorePhysicalBackupWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestorePhysicalBackupResponse, error)

	RestorePhysicalBackupWithResponse(ctx context.Context, ref string, body RestorePhysicalBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*RestorePhysicalBackupResponse, error)

	// EnableHooksWithResponse request
	EnableHooksWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*EnableHooksResponse, error)

	// GetHookLogsWithResponse request
	GetHookLogsWithResponse(ctx context.Context, ref string, params *GetHookLogsParams, reqEditors ...RequestEditorFn) (*GetHookLogsResponse, error)

	// DeleteNotificationsWithBodyWithResponse request with any body
	DeleteNotificationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteNotificationsResponse, error)

	DeleteNotificationsWithResponse(ctx context.Context, body DeleteNotificationsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteNotificationsResponse, error)

	// GetNotificationsV2WithResponse request
	GetNotificationsV2WithResponse(ctx context.Context, params *GetNotificationsV2Params, reqEditors ...RequestEditorFn) (*GetNotificationsV2Response, error)

	// UpdateNotificationsV2WithBodyWithResponse request with any body
	UpdateNotificationsV2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNotificationsV2Response, error)

	UpdateNotificationsV2WithResponse(ctx context.Context, body UpdateNotificationsV2JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNotificationsV2Response, error)

	// GetOrganizationsWithResponse request
	GetOrganizationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOrganizationsResponse, error)

	// CreateOrganizationWithTierWithBodyWithResponse request with any body
	CreateOrganizationWithTierWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrganizationWithTierResponse, error)

	CreateOrganizationWithTierWithResponse(ctx context.Context, body CreateOrganizationWithTierJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrganizationWithTierResponse, error)

	// DeleteOrganizationWithResponse request
	DeleteOrganizationWithResponse(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*DeleteOrganizationResponse, error)

	// UpdateOrganizationWithBodyWithResponse request with any body
	UpdateOrganizationWithBodyWithResponse(ctx context.Context, slug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrganizationResponse, error)

	UpdateOrganizationWithResponse(ctx context.Context, slug string, body UpdateOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrganizationResponse, error)

	// GetMembersWithResponse request
	GetMembersWithResponse(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*GetMembersResponse, error)

	// DeleteInvitedUserWithResponse request
	DeleteInvitedUserWithResponse(ctx context.Context, slug string, params *DeleteInvitedUserParams, reqEditors ...RequestEditorFn) (*DeleteInvitedUserResponse, error)

	// GetInvitedUsersWithResponse request
	GetInvitedUsersWithResponse(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*GetInvitedUsersResponse, error)

	// InviteUserWithBodyWithResponse request with any body
	InviteUserWithBodyWithResponse(ctx context.Context, slug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteUserResponse, error)

	InviteUserWithResponse(ctx context.Context, slug string, body InviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteUserResponse, error)

	// GetInviteWithResponse request
	GetInviteWithResponse(ctx context.Context, slug string, params *GetInviteParams, reqEditors ...RequestEditorFn) (*GetInviteResponse, error)

	// JoinOrganizationWithResponse request
	JoinOrganizationWithResponse(ctx context.Context, slug string, params *JoinOrganizationParams, reqEditors ...RequestEditorFn) (*JoinOrganizationResponse, error)

	// DeleteMemberWithResponse request
	DeleteMemberWithResponse(ctx context.Context, slug string, gotrueId string, reqEditors ...RequestEditorFn) (*DeleteMemberResponse, error)

	// UpdateMemberWithBodyWithResponse request with any body
	UpdateMemberWithBodyWithResponse(ctx context.Context, slug string, gotrueId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMemberResponse, error)

	UpdateMemberWithResponse(ctx context.Context, slug string, gotrueId string, body UpdateMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMemberResponse, error)

	// AddMemberWithResponse request
	AddMemberWithResponse(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*AddMemberResponse, error)

	// RevokeColumnPrivilegesWithBodyWithResponse request with any body
	RevokeColumnPrivilegesWithBodyWithResponse(ctx context.Context, ref string, params *RevokeColumnPrivilegesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevokeColumnPrivilegesResponse, error)

	RevokeColumnPrivilegesWithResponse(ctx context.Context, ref string, params *RevokeColumnPrivilegesParams, body RevokeColumnPrivilegesJSONRequestBody, reqEditors ...RequestEditorFn) (*RevokeColumnPrivilegesResponse, error)

	// GetColumnPrivilegesWithResponse request
	GetColumnPrivilegesWithResponse(ctx context.Context, ref string, params *GetColumnPrivilegesParams, reqEditors ...RequestEditorFn) (*GetColumnPrivilegesResponse, error)

	// GrantColumnPrivilegesWithBodyWithResponse request with any body
	GrantColumnPrivilegesWithBodyWithResponse(ctx context.Context, ref string, params *GrantColumnPrivilegesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GrantColumnPrivilegesResponse, error)

	GrantColumnPrivilegesWithResponse(ctx context.Context, ref string, params *GrantColumnPrivilegesParams, body GrantColumnPrivilegesJSONRequestBody, reqEditors ...RequestEditorFn) (*GrantColumnPrivilegesResponse, error)

	// DeleteColumnWithResponse request
	DeleteColumnWithResponse(ctx context.Context, ref string, params *DeleteColumnParams, reqEditors ...RequestEditorFn) (*DeleteColumnResponse, error)

	// GetColumnsWithResponse request
	GetColumnsWithResponse(ctx context.Context, ref string, params *GetColumnsParams, reqEditors ...RequestEditorFn) (*GetColumnsResponse, error)

	// UpdateColumnWithBodyWithResponse request with any body
	UpdateColumnWithBodyWithResponse(ctx context.Context, ref string, params *UpdateColumnParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateColumnResponse, error)

	UpdateColumnWithResponse(ctx context.Context, ref string, params *UpdateColumnParams, body UpdateColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateColumnResponse, error)

	// CreateColumnWithBodyWithResponse request with any body
	CreateColumnWithBodyWithResponse(ctx context.Context, ref string, params *CreateColumnParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateColumnResponse, error)

	CreateColumnWithResponse(ctx context.Context, ref string, params *CreateColumnParams, body CreateColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateColumnResponse, error)

	// DeleteExtensionWithResponse request
	DeleteExtensionWithResponse(ctx context.Context, ref string, params *DeleteExtensionParams, reqEditors ...RequestEditorFn) (*DeleteExtensionResponse, error)

	// GetExtensionsWithResponse request
	GetExtensionsWithResponse(ctx context.Context, ref string, params *GetExtensionsParams, reqEditors ...RequestEditorFn) (*GetExtensionsResponse, error)

	// CreateExtensionWithBodyWithResponse request with any body
	CreateExtensionWithBodyWithResponse(ctx context.Context, ref string, params *CreateExtensionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateExtensionResponse, error)

	CreateExtensionWithResponse(ctx context.Context, ref string, params *CreateExtensionParams, body CreateExtensionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateExtensionResponse, error)

	// GetForeignTablesWithResponse request
	GetForeignTablesWithResponse(ctx context.Context, ref string, params *GetForeignTablesParams, reqEditors ...RequestEditorFn) (*GetForeignTablesResponse, error)

	// DeleteFunctionWithResponse request
	DeleteFunctionWithResponse(ctx context.Context, ref string, params *DeleteFunctionParams, reqEditors ...RequestEditorFn) (*DeleteFunctionResponse, error)

	// GetFunctionsWithResponse request
	GetFunctionsWithResponse(ctx context.Context, ref string, params *GetFunctionsParams, reqEditors ...RequestEditorFn) (*GetFunctionsResponse, error)

	// UpdateFunctionWithBodyWithResponse request with any body
	UpdateFunctionWithBodyWithResponse(ctx context.Context, ref string, params *UpdateFunctionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFunctionResponse, error)

	UpdateFunctionWithResponse(ctx context.Context, ref string, params *UpdateFunctionParams, body UpdateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFunctionResponse, error)

	// CreateFunctionWithBodyWithResponse request with any body
	CreateFunctionWithBodyWithResponse(ctx context.Context, ref string, params *CreateFunctionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFunctionResponse, error)

	CreateFunctionWithResponse(ctx context.Context, ref string, params *CreateFunctionParams, body CreateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFunctionResponse, error)

	// GetMaterializedViewsWithResponse request
	GetMaterializedViewsWithResponse(ctx context.Context, ref string, params *GetMaterializedViewsParams, reqEditors ...RequestEditorFn) (*GetMaterializedViewsResponse, error)

	// DeletePolicyWithResponse request
	DeletePolicyWithResponse(ctx context.Context, ref string, params *DeletePolicyParams, reqEditors ...RequestEditorFn) (*DeletePolicyResponse, error)

	// GetPoliciesWithResponse request
	GetPoliciesWithResponse(ctx context.Context, ref string, params *GetPoliciesParams, reqEditors ...RequestEditorFn) (*GetPoliciesResponse, error)

	// UpdatePolicyWithBodyWithResponse request with any body
	UpdatePolicyWithBodyWithResponse(ctx context.Context, ref string, params *UpdatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error)

	UpdatePolicyWithResponse(ctx context.Context, ref string, params *UpdatePolicyParams, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error)

	// CreatePolicyWithBodyWithResponse request with any body
	CreatePolicyWithBodyWithResponse(ctx context.Context, ref string, params *CreatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error)

	CreatePolicyWithResponse(ctx context.Context, ref string, params *CreatePolicyParams, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error)

	// DeletePublicationWithResponse request
	DeletePublicationWithResponse(ctx context.Context, ref string, params *DeletePublicationParams, reqEditors ...RequestEditorFn) (*DeletePublicationResponse, error)

	// GetPublicationsWithResponse request
	GetPublicationsWithResponse(ctx context.Context, ref string, params *GetPublicationsParams, reqEditors ...RequestEditorFn) (*GetPublicationsResponse, error)

	// UpdatePublicationWithBodyWithResponse request with any body
	UpdatePublicationWithBodyWithResponse(ctx context.Context, ref string, params *UpdatePublicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePublicationResponse, error)

	UpdatePublicationWithResponse(ctx context.Context, ref string, params *UpdatePublicationParams, body UpdatePublicationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePublicationResponse, error)

	// CreatePublicationWithBodyWithResponse request with any body
	CreatePublicationWithBodyWithResponse(ctx context.Context, ref string, params *CreatePublicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePublicationResponse, error)

	CreatePublicationWithResponse(ctx context.Context, ref string, params *CreatePublicationParams, body CreatePublicationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePublicationResponse, error)

	// RunQueryWithBodyWithResponse request with any body
	RunQueryWithBodyWithResponse(ctx context.Context, ref string, params *RunQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunQueryResponse, error)

	RunQueryWithResponse(ctx context.Context, ref string, params *RunQueryParams, body RunQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*RunQueryResponse, error)

	// FormatQueryWithBodyWithResponse request with any body
	FormatQueryWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FormatQueryResponse, error)

	FormatQueryWithResponse(ctx context.Context, ref string, body FormatQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*FormatQueryResponse, error)

	// ValidateQueryWithBodyWithResponse request with any body
	ValidateQueryWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateQueryResponse, error)

	ValidateQueryWithResponse(ctx context.Context, ref string, body ValidateQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateQueryResponse, error)

	// DeleteRoleWithResponse request
	DeleteRoleWithResponse(ctx context.Context, ref string, params *DeleteRoleParams, reqEditors ...RequestEditorFn) (*DeleteRoleResponse, error)

	// GetRolesWithResponse request
	GetRolesWithResponse(ctx context.Context, ref string, params *GetRolesParams, reqEditors ...RequestEditorFn) (*GetRolesResponse, error)

	// UpdateRoleWithBodyWithResponse request with any body
	UpdateRoleWithBodyWithResponse(ctx context.Context, ref string, params *UpdateRoleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error)

	UpdateRoleWithResponse(ctx context.Context, ref string, params *UpdateRoleParams, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error)

	// CreateRoleWithBodyWithResponse request with any body
	CreateRoleWithBodyWithResponse(ctx context.Context, ref string, params *CreateRoleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error)

	CreateRoleWithResponse(ctx context.Context, ref string, params *CreateRoleParams, body CreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error)

	// DeleteSchemaWithResponse request
	DeleteSchemaWithResponse(ctx context.Context, ref string, params *DeleteSchemaParams, reqEditors ...RequestEditorFn) (*DeleteSchemaResponse, error)

	// GetSchemasWithResponse request
	GetSchemasWithResponse(ctx context.Context, ref string, params *GetSchemasParams, reqEditors ...RequestEditorFn) (*GetSchemasResponse, error)

	// UpdateSchemaWithBodyWithResponse request with any body
	UpdateSchemaWithBodyWithResponse(ctx context.Context, ref string, params *UpdateSchemaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSchemaResponse, error)

	UpdateSchemaWithResponse(ctx context.Context, ref string, params *UpdateSchemaParams, body UpdateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSchemaResponse, error)

	// CreateSchemaWithBodyWithResponse request with any body
	CreateSchemaWithBodyWithResponse(ctx context.Context, ref string, params *CreateSchemaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSchemaResponse, error)

	CreateSchemaWithResponse(ctx context.Context, ref string, params *CreateSchemaParams, body CreateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSchemaResponse, error)

	// SearchColumnsWithBodyWithResponse request with any body
	SearchColumnsWithBodyWithResponse(ctx context.Context, ref string, params *SearchColumnsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchColumnsResponse, error)

	SearchColumnsWithResponse(ctx context.Context, ref string, params *SearchColumnsParams, body SearchColumnsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchColumnsResponse, error)

	// SearchTablesWithBodyWithResponse request with any body
	SearchTablesWithBodyWithResponse(ctx context.Context, ref string, params *SearchTablesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchTablesResponse, error)

	SearchTablesWithResponse(ctx context.Context, ref string, params *SearchTablesParams, body SearchTablesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchTablesResponse, error)

	// RevokeTablePrivilegesWithBodyWithResponse request with any body
	RevokeTablePrivilegesWithBodyWithResponse(ctx context.Context, ref string, params *RevokeTablePrivilegesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevokeTablePrivilegesResponse, error)

	RevokeTablePrivilegesWithResponse(ctx context.Context, ref string, params *RevokeTablePrivilegesParams, body RevokeTablePrivilegesJSONRequestBody, reqEditors ...RequestEditorFn) (*RevokeTablePrivilegesResponse, error)

	// GetTablePrivilegesWithResponse request
	GetTablePrivilegesWithResponse(ctx context.Context, ref string, params *GetTablePrivilegesParams, reqEditors ...RequestEditorFn) (*GetTablePrivilegesResponse, error)

	// GrantTablePrivilegesWithBodyWithResponse request with any body
	GrantTablePrivilegesWithBodyWithResponse(ctx context.Context, ref string, params *GrantTablePrivilegesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GrantTablePrivilegesResponse, error)

	GrantTablePrivilegesWithResponse(ctx context.Context, ref string, params *GrantTablePrivilegesParams, body GrantTablePrivilegesJSONRequestBody, reqEditors ...RequestEditorFn) (*GrantTablePrivilegesResponse, error)

	// DeleteTableWithResponse request
	DeleteTableWithResponse(ctx context.Context, ref string, params *DeleteTableParams, reqEditors ...RequestEditorFn) (*DeleteTableResponse, error)

	// GetTablesWithResponse request
	GetTablesWithResponse(ctx context.Context, ref string, params *GetTablesParams, reqEditors ...RequestEditorFn) (*GetTablesResponse, error)

	// UpdateTableWithBodyWithResponse request with any body
	UpdateTableWithBodyWithResponse(ctx context.Context, ref string, params *UpdateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTableResponse, error)

	UpdateTableWithResponse(ctx context.Context, ref string, params *UpdateTableParams, body UpdateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTableResponse, error)

	// CreateTableWithBodyWithResponse request with any body
	CreateTableWithBodyWithResponse(ctx context.Context, ref string, params *CreateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTableResponse, error)

	CreateTableWithResponse(ctx context.Context, ref string, params *CreateTableParams, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTableResponse, error)

	// DeleteTriggerWithResponse request
	DeleteTriggerWithResponse(ctx context.Context, ref string, params *DeleteTriggerParams, reqEditors ...RequestEditorFn) (*DeleteTriggerResponse, error)

	// GetTriggersWithResponse request
	GetTriggersWithResponse(ctx context.Context, ref string, params *GetTriggersParams, reqEditors ...RequestEditorFn) (*GetTriggersResponse, error)

	// UpdateTriggerWithBodyWithResponse request with any body
	UpdateTriggerWithBodyWithResponse(ctx context.Context, ref string, params *UpdateTriggerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTriggerResponse, error)

	UpdateTriggerWithResponse(ctx context.Context, ref string, params *UpdateTriggerParams, body UpdateTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTriggerResponse, error)

	// CreateTriggerWithBodyWithResponse request with any body
	CreateTriggerWithBodyWithResponse(ctx context.Context, ref string, params *CreateTriggerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTriggerResponse, error)

	CreateTriggerWithResponse(ctx context.Context, ref string, params *CreateTriggerParams, body CreateTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTriggerResponse, error)

	// GetTypesWithResponse request
	GetTypesWithResponse(ctx context.Context, ref string, params *GetTypesParams, reqEditors ...RequestEditorFn) (*GetTypesResponse, error)

	// GetViewsWithResponse request
	GetViewsWithResponse(ctx context.Context, ref string, params *GetViewsParams, reqEditors ...RequestEditorFn) (*GetViewsResponse, error)

	// GetProjectsWithResponse request
	GetProjectsWithResponse(ctx context.Context, params *GetProjectsParams, reqEditors ...RequestEditorFn) (*GetProjectsResponse, error)

	// CreateProjectWithBodyWithResponse request with any body
	CreateProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error)

	CreateProjectWithResponse(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error)

	// GetProjectsMetricsWithBodyWithResponse request with any body
	GetProjectsMetricsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetProjectsMetricsResponse, error)

	GetProjectsMetricsWithResponse(ctx context.Context, body GetProjectsMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetProjectsMetricsResponse, error)

	// DeleteProjectWithResponse request
	DeleteProjectWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*DeleteProjectResponse, error)

	// GetProjectWithResponse request
	GetProjectWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*GetProjectResponse, error)

	// UpdateProjectWithBodyWithResponse request with any body
	UpdateProjectWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error)

	UpdateProjectWithResponse(ctx context.Context, ref string, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error)

	// GetFunctionStatusWithResponse request
	GetFunctionStatusWithResponse(ctx context.Context, ref string, params *GetFunctionStatusParams, reqEditors ...RequestEditorFn) (*GetFunctionStatusResponse, error)

	// GetApiPathsWithResponse request
	GetApiPathsWithResponse(ctx context.Context, ref string, params *GetApiPathsParams, reqEditors ...RequestEditorFn) (*GetApiPathsResponse, error)

	// GetApiCountsWithResponse request
	GetApiCountsWithResponse(ctx context.Context, ref string, params *GetApiCountsParams, reqEditors ...RequestEditorFn) (*GetApiCountsResponse, error)

	// ProjectGraphqlWithBodyWithResponse request with any body
	ProjectGraphqlWithBodyWithResponse(ctx context.Context, ref string, params *ProjectGraphqlParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectGraphqlResponse, error)

	ProjectGraphqlWithResponse(ctx context.Context, ref string, params *ProjectGraphqlParams, body ProjectGraphqlJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectGraphqlResponse, error)

	// ProjectOpenApiWithResponse request
	ProjectOpenApiWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*ProjectOpenApiResponse, error)

	// GetPgbouncerConfigWithResponse request
	GetPgbouncerConfigWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*GetPgbouncerConfigResponse, error)

	// UpdatePgbouncerConfigWithBodyWithResponse request with any body
	UpdatePgbouncerConfigWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePgbouncerConfigResponse, error)

	UpdatePgbouncerConfigWithResponse(ctx context.Context, ref string, body UpdatePgbouncerConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePgbouncerConfigResponse, error)

	// GetConfigWithResponse request
	GetConfigWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*GetConfigResponse, error)

	// UpdateConfigWithBodyWithResponse request with any body
	UpdateConfigWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error)

	UpdateConfigWithResponse(ctx context.Context, ref string, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error)

	// GetPostgRESTConfigWithResponse request
	GetPostgRESTConfigWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*GetPostgRESTConfigResponse, error)

	// UpdatePostgRESTConfigWithBodyWithResponse request with any body
	UpdatePostgRESTConfigWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePostgRESTConfigResponse, error)

	UpdatePostgRESTConfigWithResponse(ctx context.Context, ref string, body UpdatePostgRESTConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePostgRESTConfigResponse, error)

	// UpdateConfigWithBodyWithResponse request with any body
	UpdateConfigWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error)

	UpdateConfigWithResponse(ctx context.Context, ref string, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error)

	// GetStorageConfigWithResponse request
	GetStorageConfigWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*GetStorageConfigResponse, error)

	// UpdateConfigWithBodyWithResponse request with any body
	UpdateConfigWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error)

	UpdateConfigWithResponse(ctx context.Context, ref string, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error)

	// DeleteContentWithResponse request
	DeleteContentWithResponse(ctx context.Context, ref string, params *DeleteContentParams, reqEditors ...RequestEditorFn) (*DeleteContentResponse, error)

	// GetProjectContentWithResponse request
	GetProjectContentWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*GetProjectContentResponse, error)

	// UpdateContentWithBodyWithResponse request with any body
	UpdateContentWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateContentResponse, error)

	UpdateContentWithResponse(ctx context.Context, ref string, body UpdateContentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateContentResponse, error)

	// CreateContentWithBodyWithResponse request with any body
	CreateContentWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateContentResponse, error)

	CreateContentWithResponse(ctx context.Context, ref string, body CreateContentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateContentResponse, error)

	// UpdateWholeContentWithBodyWithResponse request with any body
	UpdateWholeContentWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWholeContentResponse, error)

	UpdateWholeContentWithResponse(ctx context.Context, ref string, body UpdateWholeContentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWholeContentResponse, error)

	// GetDailyStatsWithResponse request
	GetDailyStatsWithResponse(ctx context.Context, ref string, params *GetDailyStatsParams, reqEditors ...RequestEditorFn) (*GetDailyStatsResponse, error)

	// UpdatePasswordWithBodyWithResponse request with any body
	UpdatePasswordWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePasswordResponse, error)

	UpdatePasswordWithResponse(ctx context.Context, ref string, body UpdatePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePasswordResponse, error)

	// GetUsageMetricsWithResponse request
	GetUsageMetricsWithResponse(ctx context.Context, ref string, params *GetUsageMetricsParams, reqEditors ...RequestEditorFn) (*GetUsageMetricsResponse, error)

	// GetInvoicesWithResponse request
	GetInvoicesWithResponse(ctx context.Context, ref string, params *GetInvoicesParams, reqEditors ...RequestEditorFn) (*GetInvoicesResponse, error)

	// GetInvoiceCountWithResponse request
	GetInvoiceCountWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*GetInvoiceCountResponse, error)

	// ProjectHealthCheckWithResponse request
	ProjectHealthCheckWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*ProjectHealthCheckResponse, error)

	// PauseProjectWithResponse request
	PauseProjectWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*PauseProjectResponse, error)

	// ResizeDatabaseWithBodyWithResponse request with any body
	ResizeDatabaseWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResizeDatabaseResponse, error)

	ResizeDatabaseWithResponse(ctx context.Context, ref string, body ResizeDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*ResizeDatabaseResponse, error)

	// RestartProjectWithResponse request
	RestartProjectWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*RestartProjectResponse, error)

	// RestartServicesWithBodyWithResponse request with any body
	RestartServicesWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestartServicesResponse, error)

	RestartServicesWithResponse(ctx context.Context, ref string, body RestartServicesJSONRequestBody, reqEditors ...RequestEditorFn) (*RestartServicesResponse, error)

	// RestoreProjectWithBodyWithResponse request with any body
	RestoreProjectWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestoreProjectResponse, error)

	RestoreProjectWithResponse(ctx context.Context, ref string, body RestoreProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*RestoreProjectResponse, error)

	// GetProjectApiWithResponse request
	GetProjectApiWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*GetProjectApiResponse, error)

	// GetProjectStatusWithResponse request
	GetProjectStatusWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*GetProjectStatusResponse, error)

	// GetUsageStatusConfigWithResponse request
	GetUsageStatusConfigWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*GetUsageStatusConfigResponse, error)

	// GetStatusWithResponse request
	GetStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatusResponse, error)

	// GetBucketsWithResponse request
	GetBucketsWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*GetBucketsResponse, error)

	// CreateBucketWithBodyWithResponse request with any body
	CreateBucketWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBucketResponse, error)

	CreateBucketWithResponse(ctx context.Context, ref string, body CreateBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBucketResponse, error)

	// DeleteBucketWithResponse request
	DeleteBucketWithResponse(ctx context.Context, ref string, id string, reqEditors ...RequestEditorFn) (*DeleteBucketResponse, error)

	// GetBucketWithResponse request
	GetBucketWithResponse(ctx context.Context, ref string, id string, reqEditors ...RequestEditorFn) (*GetBucketResponse, error)

	// UpdateBucketWithBodyWithResponse request with any body
	UpdateBucketWithBodyWithResponse(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBucketResponse, error)

	UpdateBucketWithResponse(ctx context.Context, ref string, id string, body UpdateBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBucketResponse, error)

	// EmptyBucketWithResponse request
	EmptyBucketWithResponse(ctx context.Context, ref string, id string, reqEditors ...RequestEditorFn) (*EmptyBucketResponse, error)

	// DeleteObjectsWithBodyWithResponse request with any body
	DeleteObjectsWithBodyWithResponse(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteObjectsResponse, error)

	DeleteObjectsWithResponse(ctx context.Context, ref string, id string, body DeleteObjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteObjectsResponse, error)

	// CopyObjectWithBodyWithResponse request with any body
	CopyObjectWithBodyWithResponse(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CopyObjectResponse, error)

	CopyObjectWithResponse(ctx context.Context, ref string, id string, body CopyObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CopyObjectResponse, error)

	// DownloadWithBodyWithResponse request with any body
	DownloadWithBodyWithResponse(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DownloadResponse, error)

	DownloadWithResponse(ctx context.Context, ref string, id string, body DownloadJSONRequestBody, reqEditors ...RequestEditorFn) (*DownloadResponse, error)

	// GetObjectsWithBodyWithResponse request with any body
	GetObjectsWithBodyWithResponse(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetObjectsResponse, error)

	GetObjectsWithResponse(ctx context.Context, ref string, id string, body GetObjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetObjectsResponse, error)

	// MoveObjectWithBodyWithResponse request with any body
	MoveObjectWithBodyWithResponse(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MoveObjectResponse, error)

	MoveObjectWithResponse(ctx context.Context, ref string, id string, body MoveObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*MoveObjectResponse, error)

	// CreatePublicUrlWithBodyWithResponse request with any body
	CreatePublicUrlWithBodyWithResponse(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePublicUrlResponse, error)

	CreatePublicUrlWithResponse(ctx context.Context, ref string, id string, body CreatePublicUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePublicUrlResponse, error)

	// CreateSignedUrlWithBodyWithResponse request with any body
	CreateSignedUrlWithBodyWithResponse(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSignedUrlResponse, error)

	CreateSignedUrlWithResponse(ctx context.Context, ref string, id string, body CreateSignedUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSignedUrlResponse, error)

	// CreateSignedUrlsWithBodyWithResponse request with any body
	CreateSignedUrlsWithBodyWithResponse(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSignedUrlsResponse, error)

	CreateSignedUrlsWithResponse(ctx context.Context, ref string, id string, body CreateSignedUrlsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSignedUrlsResponse, error)
}

type GetGoTrueConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetGoTrueConfigResponse
}

// Status returns HTTPResponse.Status
func (r GetGoTrueConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGoTrueConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGoTrueConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GoTrueConfig
}

// Status returns HTTPResponse.Status
func (r UpdateGoTrueConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGoTrueConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendInviteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r SendInviteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendInviteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendMagicLinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r SendMagicLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendMagicLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendOtpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r SendOtpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendOtpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendRecoverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r SendRecoverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendRecoverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UsersResponse
}

// Status returns HTTPResponse.Status
func (r GetUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFactorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r DeleteFactorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFactorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBackupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackupsResponse
}

// Status returns HTTPResponse.Status
func (r GetBackupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBackupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadBackupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DownloadBackupResponse
}

// Status returns HTTPResponse.Status
func (r DownloadBackupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadBackupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestorePointInTimeBackupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RestorePointInTimeBackupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestorePointInTimeBackupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreBackupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RestoreBackupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreBackupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestorePhysicalBackupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RestorePhysicalBackupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestorePhysicalBackupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnableHooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EnableHooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnableHooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHookLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r GetHookLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHookLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNotificationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]NotificationResponseV1
}

// Status returns HTTPResponse.Status
func (r DeleteNotificationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNotificationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNotificationsV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]NotificationResponseV2
}

// Status returns HTTPResponse.Status
func (r GetNotificationsV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNotificationsV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateNotificationsV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]NotificationResponseV2
}

// Status returns HTTPResponse.Status
func (r UpdateNotificationsV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNotificationsV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OrganizationResponse
}

// Status returns HTTPResponse.Status
func (r GetOrganizationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrganizationWithTierResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *OrganizationResponse
}

// Status returns HTTPResponse.Status
func (r CreateOrganizationWithTierResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrganizationWithTierResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrganizationSlugResponse
}

// Status returns HTTPResponse.Status
func (r UpdateOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Member
}

// Status returns HTTPResponse.Status
func (r GetMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInvitedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteInvitedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInvitedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvitedUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Invite
}

// Status returns HTTPResponse.Status
func (r GetInvitedUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvitedUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InviteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SendInviteResponse
}

// Status returns HTTPResponse.Status
func (r InviteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InviteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInviteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InviteResponse
}

// Status returns HTTPResponse.Status
func (r GetInviteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInviteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JoinOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *JoinResponse
}

// Status returns HTTPResponse.Status
func (r JoinOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JoinOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Role
}

// Status returns HTTPResponse.Status
func (r AddMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokeColumnPrivilegesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PostgresColumnPrivileges
}

// Status returns HTTPResponse.Status
func (r RevokeColumnPrivilegesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokeColumnPrivilegesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetColumnPrivilegesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PostgresColumnPrivileges
}

// Status returns HTTPResponse.Status
func (r GetColumnPrivilegesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetColumnPrivilegesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GrantColumnPrivilegesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *[]PostgresColumnPrivileges
}

// Status returns HTTPResponse.Status
func (r GrantColumnPrivilegesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GrantColumnPrivilegesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteColumnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostgresColumn
}

// Status returns HTTPResponse.Status
func (r DeleteColumnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteColumnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetColumnsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PostgresColumn
}

// Status returns HTTPResponse.Status
func (r GetColumnsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetColumnsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateColumnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostgresColumn
}

// Status returns HTTPResponse.Status
func (r UpdateColumnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateColumnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateColumnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PostgresColumn
}

// Status returns HTTPResponse.Status
func (r CreateColumnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateColumnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteExtensionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostgresExtension
}

// Status returns HTTPResponse.Status
func (r DeleteExtensionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteExtensionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExtensionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PostgresExtension
}

// Status returns HTTPResponse.Status
func (r GetExtensionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExtensionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateExtensionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PostgresExtension
}

// Status returns HTTPResponse.Status
func (r CreateExtensionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateExtensionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetForeignTablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PostgresForeignTable
}

// Status returns HTTPResponse.Status
func (r GetForeignTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetForeignTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFunctionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostgresFunction
}

// Status returns HTTPResponse.Status
func (r DeleteFunctionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFunctionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFunctionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PostgresFunction
}

// Status returns HTTPResponse.Status
func (r GetFunctionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFunctionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFunctionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostgresFunction
}

// Status returns HTTPResponse.Status
func (r UpdateFunctionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFunctionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFunctionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PostgresFunction
}

// Status returns HTTPResponse.Status
func (r CreateFunctionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFunctionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMaterializedViewsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PostgresMaterializedView
}

// Status returns HTTPResponse.Status
func (r GetMaterializedViewsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMaterializedViewsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostgresPolicy
}

// Status returns HTTPResponse.Status
func (r DeletePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PostgresPolicy
}

// Status returns HTTPResponse.Status
func (r GetPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostgresPolicy
}

// Status returns HTTPResponse.Status
func (r UpdatePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PostgresPolicy
}

// Status returns HTTPResponse.Status
func (r CreatePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePublicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostgresPublication
}

// Status returns HTTPResponse.Status
func (r DeletePublicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePublicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPublicationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PostgresPublication
}

// Status returns HTTPResponse.Status
func (r GetPublicationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPublicationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePublicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostgresPublication
}

// Status returns HTTPResponse.Status
func (r UpdatePublicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePublicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePublicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PostgresPublication
}

// Status returns HTTPResponse.Status
func (r CreatePublicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePublicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r RunQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FormatQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *string
}

// Status returns HTTPResponse.Status
func (r FormatQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FormatQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ValidateQueryResponse
}

// Status returns HTTPResponse.Status
func (r ValidateQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostgresRole
}

// Status returns HTTPResponse.Status
func (r DeleteRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PostgresRole
}

// Status returns HTTPResponse.Status
func (r GetRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostgresRole
}

// Status returns HTTPResponse.Status
func (r UpdateRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PostgresRole
}

// Status returns HTTPResponse.Status
func (r CreateRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostgresSchema
}

// Status returns HTTPResponse.Status
func (r DeleteSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchemasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PostgresSchema
}

// Status returns HTTPResponse.Status
func (r GetSchemasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchemasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostgresSchema
}

// Status returns HTTPResponse.Status
func (r UpdateSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PostgresSchema
}

// Status returns HTTPResponse.Status
func (r CreateSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchColumnsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *[]Column
}

// Status returns HTTPResponse.Status
func (r SearchColumnsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchColumnsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchTablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *[]Table
}

// Status returns HTTPResponse.Status
func (r SearchTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokeTablePrivilegesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PostgresTablePrivileges
}

// Status returns HTTPResponse.Status
func (r RevokeTablePrivilegesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokeTablePrivilegesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTablePrivilegesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PostgresTablePrivileges
}

// Status returns HTTPResponse.Status
func (r GetTablePrivilegesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTablePrivilegesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GrantTablePrivilegesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *[]PostgresTablePrivileges
}

// Status returns HTTPResponse.Status
func (r GrantTablePrivilegesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GrantTablePrivilegesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostgresTable
}

// Status returns HTTPResponse.Status
func (r DeleteTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PostgresTable
}

// Status returns HTTPResponse.Status
func (r GetTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostgresTable
}

// Status returns HTTPResponse.Status
func (r UpdateTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PostgresTable
}

// Status returns HTTPResponse.Status
func (r CreateTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostgresTrigger
}

// Status returns HTTPResponse.Status
func (r DeleteTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTriggersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PostgresTrigger
}

// Status returns HTTPResponse.Status
func (r GetTriggersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTriggersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostgresTrigger
}

// Status returns HTTPResponse.Status
func (r UpdateTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PostgresTrigger
}

// Status returns HTTPResponse.Status
func (r CreateTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PostgresType
}

// Status returns HTTPResponse.Status
func (r GetTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetViewsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PostgresView
}

// Status returns HTTPResponse.Status
func (r GetViewsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetViewsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ProjectInfo
}

// Status returns HTTPResponse.Status
func (r GetProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateProjectResponse
}

// Status returns HTTPResponse.Status
func (r CreateProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectsMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetMetricsResponse
}

// Status returns HTTPResponse.Status
func (r GetProjectsMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectsMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectRefResponse
}

// Status returns HTTPResponse.Status
func (r DeleteProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectDetailResponse
}

// Status returns HTTPResponse.Status
func (r GetProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectRefResponse
}

// Status returns HTTPResponse.Status
func (r UpdateProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFunctionStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AnalyticsResponse
}

// Status returns HTTPResponse.Status
func (r GetFunctionStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFunctionStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApiPathsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AnalyticsResponse
}

// Status returns HTTPResponse.Status
func (r GetApiPathsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApiPathsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApiCountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AnalyticsResponse
}

// Status returns HTTPResponse.Status
func (r GetApiCountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApiCountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectGraphqlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r ProjectGraphqlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectGraphqlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectOpenApiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r ProjectOpenApiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectOpenApiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPgbouncerConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PgbouncerConfigResponse
}

// Status returns HTTPResponse.Status
func (r GetPgbouncerConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPgbouncerConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePgbouncerConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdatePoolingConfigResponse
}

// Status returns HTTPResponse.Status
func (r UpdatePgbouncerConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePgbouncerConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostgresConfigResponse
}

// Status returns HTTPResponse.Status
func (r GetConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostgresConfigResponse
}

// Status returns HTTPResponse.Status
func (r UpdateConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPostgRESTConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostgrestConfigResponse
}

// Status returns HTTPResponse.Status
func (r GetPostgRESTConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPostgRESTConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePostgRESTConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostgrestConfigResponse
}

// Status returns HTTPResponse.Status
func (r UpdatePostgRESTConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePostgRESTConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateSecretsResponse
}

// Status returns HTTPResponse.Status
func (r UpdateConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStorageConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StorageConfigResponse
}

// Status returns HTTPResponse.Status
func (r GetStorageConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStorageConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateStorageConfigResponse
}

// Status returns HTTPResponse.Status
func (r UpdateConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteContentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserContentObject
}

// Status returns HTTPResponse.Status
func (r DeleteContentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteContentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectContentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetUserContentResponse
}

// Status returns HTTPResponse.Status
func (r GetProjectContentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectContentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateContentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]UserContentObject
}

// Status returns HTTPResponse.Status
func (r UpdateContentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateContentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateContentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *[]UserContentObject
}

// Status returns HTTPResponse.Status
func (r CreateContentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateContentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateWholeContentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserContentObject
}

// Status returns HTTPResponse.Status
func (r UpdateWholeContentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWholeContentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDailyStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r GetDailyStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDailyStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdatePasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsageMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r GetUsageMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsageMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvoicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r GetInvoicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvoicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvoiceCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetInvoiceCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvoiceCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectHealthCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ProjectHealthCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectHealthCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PauseProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PauseProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PauseProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResizeDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ResizeDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResizeDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestartProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RestartProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestartProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestartServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RestartServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestartServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RestoreProjectInfo
}

// Status returns HTTPResponse.Status
func (r RestoreProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectApiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectSettingsResponse
}

// Status returns HTTPResponse.Status
func (r GetProjectApiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectApiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetProjectStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsageStatusConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UsageStatusResponse
}

// Status returns HTTPResponse.Status
func (r GetUsageStatusConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsageStatusConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBucketsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]StorageBucket
}

// Status returns HTTPResponse.Status
func (r GetBucketsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBucketsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBucketResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *string
}

// Status returns HTTPResponse.Status
func (r CreateBucketResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBucketResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBucketResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteBucketResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBucketResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBucketResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StorageBucket
}

// Status returns HTTPResponse.Status
func (r GetBucketResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBucketResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBucketResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateBucketResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBucketResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EmptyBucketResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EmptyBucketResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EmptyBucketResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteObjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteObjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteObjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CopyObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CopyObjectResponse
}

// Status returns HTTPResponse.Status
func (r CopyObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CopyObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DownloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetObjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *[]StorageObject
}

// Status returns HTTPResponse.Status
func (r GetObjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetObjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MoveObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MoveObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MoveObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePublicUrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PublicUrlResponse
}

// Status returns HTTPResponse.Status
func (r CreatePublicUrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePublicUrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSignedUrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SignedUrlResponse
}

// Status returns HTTPResponse.Status
func (r CreateSignedUrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSignedUrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSignedUrlsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *[]SignedUrlsResponse
}

// Status returns HTTPResponse.Status
func (r CreateSignedUrlsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSignedUrlsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetGoTrueConfigWithResponse request returning *GetGoTrueConfigResponse
func (c *ClientWithResponses) GetGoTrueConfigWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*GetGoTrueConfigResponse, error) {
	rsp, err := c.GetGoTrueConfig(ctx, ref, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGoTrueConfigResponse(rsp)
}

// UpdateGoTrueConfigWithBodyWithResponse request with arbitrary body returning *UpdateGoTrueConfigResponse
func (c *ClientWithResponses) UpdateGoTrueConfigWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGoTrueConfigResponse, error) {
	rsp, err := c.UpdateGoTrueConfigWithBody(ctx, ref, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGoTrueConfigResponse(rsp)
}

func (c *ClientWithResponses) UpdateGoTrueConfigWithResponse(ctx context.Context, ref string, body UpdateGoTrueConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGoTrueConfigResponse, error) {
	rsp, err := c.UpdateGoTrueConfig(ctx, ref, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGoTrueConfigResponse(rsp)
}

// SendInviteWithBodyWithResponse request with arbitrary body returning *SendInviteResponse
func (c *ClientWithResponses) SendInviteWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendInviteResponse, error) {
	rsp, err := c.SendInviteWithBody(ctx, ref, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendInviteResponse(rsp)
}

func (c *ClientWithResponses) SendInviteWithResponse(ctx context.Context, ref string, body SendInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*SendInviteResponse, error) {
	rsp, err := c.SendInvite(ctx, ref, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendInviteResponse(rsp)
}

// SendMagicLinkWithBodyWithResponse request with arbitrary body returning *SendMagicLinkResponse
func (c *ClientWithResponses) SendMagicLinkWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendMagicLinkResponse, error) {
	rsp, err := c.SendMagicLinkWithBody(ctx, ref, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendMagicLinkResponse(rsp)
}

func (c *ClientWithResponses) SendMagicLinkWithResponse(ctx context.Context, ref string, body SendMagicLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*SendMagicLinkResponse, error) {
	rsp, err := c.SendMagicLink(ctx, ref, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendMagicLinkResponse(rsp)
}

// SendOtpWithBodyWithResponse request with arbitrary body returning *SendOtpResponse
func (c *ClientWithResponses) SendOtpWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendOtpResponse, error) {
	rsp, err := c.SendOtpWithBody(ctx, ref, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendOtpResponse(rsp)
}

func (c *ClientWithResponses) SendOtpWithResponse(ctx context.Context, ref string, body SendOtpJSONRequestBody, reqEditors ...RequestEditorFn) (*SendOtpResponse, error) {
	rsp, err := c.SendOtp(ctx, ref, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendOtpResponse(rsp)
}

// SendRecoverWithBodyWithResponse request with arbitrary body returning *SendRecoverResponse
func (c *ClientWithResponses) SendRecoverWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendRecoverResponse, error) {
	rsp, err := c.SendRecoverWithBody(ctx, ref, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendRecoverResponse(rsp)
}

func (c *ClientWithResponses) SendRecoverWithResponse(ctx context.Context, ref string, body SendRecoverJSONRequestBody, reqEditors ...RequestEditorFn) (*SendRecoverResponse, error) {
	rsp, err := c.SendRecover(ctx, ref, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendRecoverResponse(rsp)
}

// GetTemplateWithResponse request returning *GetTemplateResponse
func (c *ClientWithResponses) GetTemplateWithResponse(ctx context.Context, ref string, template GetTemplateParamsTemplate, reqEditors ...RequestEditorFn) (*GetTemplateResponse, error) {
	rsp, err := c.GetTemplate(ctx, ref, template, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTemplateResponse(rsp)
}

// DeleteUserWithBodyWithResponse request with arbitrary body returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUserWithBody(ctx, ref, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, ref string, body DeleteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, ref, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// GetUsersWithResponse request returning *GetUsersResponse
func (c *ClientWithResponses) GetUsersWithResponse(ctx context.Context, ref string, params *GetUsersParams, reqEditors ...RequestEditorFn) (*GetUsersResponse, error) {
	rsp, err := c.GetUsers(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersResponse(rsp)
}

// DeleteFactorsWithResponse request returning *DeleteFactorsResponse
func (c *ClientWithResponses) DeleteFactorsWithResponse(ctx context.Context, ref string, id string, reqEditors ...RequestEditorFn) (*DeleteFactorsResponse, error) {
	rsp, err := c.DeleteFactors(ctx, ref, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFactorsResponse(rsp)
}

// GetBackupsWithResponse request returning *GetBackupsResponse
func (c *ClientWithResponses) GetBackupsWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*GetBackupsResponse, error) {
	rsp, err := c.GetBackups(ctx, ref, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBackupsResponse(rsp)
}

// DownloadBackupWithBodyWithResponse request with arbitrary body returning *DownloadBackupResponse
func (c *ClientWithResponses) DownloadBackupWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DownloadBackupResponse, error) {
	rsp, err := c.DownloadBackupWithBody(ctx, ref, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadBackupResponse(rsp)
}

func (c *ClientWithResponses) DownloadBackupWithResponse(ctx context.Context, ref string, body DownloadBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*DownloadBackupResponse, error) {
	rsp, err := c.DownloadBackup(ctx, ref, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadBackupResponse(rsp)
}

// RestorePointInTimeBackupWithBodyWithResponse request with arbitrary body returning *RestorePointInTimeBackupResponse
func (c *ClientWithResponses) RestorePointInTimeBackupWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestorePointInTimeBackupResponse, error) {
	rsp, err := c.RestorePointInTimeBackupWithBody(ctx, ref, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestorePointInTimeBackupResponse(rsp)
}

func (c *ClientWithResponses) RestorePointInTimeBackupWithResponse(ctx context.Context, ref string, body RestorePointInTimeBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*RestorePointInTimeBackupResponse, error) {
	rsp, err := c.RestorePointInTimeBackup(ctx, ref, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestorePointInTimeBackupResponse(rsp)
}

// RestoreBackupWithBodyWithResponse request with arbitrary body returning *RestoreBackupResponse
func (c *ClientWithResponses) RestoreBackupWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestoreBackupResponse, error) {
	rsp, err := c.RestoreBackupWithBody(ctx, ref, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreBackupResponse(rsp)
}

func (c *ClientWithResponses) RestoreBackupWithResponse(ctx context.Context, ref string, body RestoreBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*RestoreBackupResponse, error) {
	rsp, err := c.RestoreBackup(ctx, ref, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreBackupResponse(rsp)
}

// RestorePhysicalBackupWithBodyWithResponse request with arbitrary body returning *RestorePhysicalBackupResponse
func (c *ClientWithResponses) RestorePhysicalBackupWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestorePhysicalBackupResponse, error) {
	rsp, err := c.RestorePhysicalBackupWithBody(ctx, ref, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestorePhysicalBackupResponse(rsp)
}

func (c *ClientWithResponses) RestorePhysicalBackupWithResponse(ctx context.Context, ref string, body RestorePhysicalBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*RestorePhysicalBackupResponse, error) {
	rsp, err := c.RestorePhysicalBackup(ctx, ref, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestorePhysicalBackupResponse(rsp)
}

// EnableHooksWithResponse request returning *EnableHooksResponse
func (c *ClientWithResponses) EnableHooksWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*EnableHooksResponse, error) {
	rsp, err := c.EnableHooks(ctx, ref, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableHooksResponse(rsp)
}

// GetHookLogsWithResponse request returning *GetHookLogsResponse
func (c *ClientWithResponses) GetHookLogsWithResponse(ctx context.Context, ref string, params *GetHookLogsParams, reqEditors ...RequestEditorFn) (*GetHookLogsResponse, error) {
	rsp, err := c.GetHookLogs(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHookLogsResponse(rsp)
}

// DeleteNotificationsWithBodyWithResponse request with arbitrary body returning *DeleteNotificationsResponse
func (c *ClientWithResponses) DeleteNotificationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteNotificationsResponse, error) {
	rsp, err := c.DeleteNotificationsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNotificationsResponse(rsp)
}

func (c *ClientWithResponses) DeleteNotificationsWithResponse(ctx context.Context, body DeleteNotificationsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteNotificationsResponse, error) {
	rsp, err := c.DeleteNotifications(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNotificationsResponse(rsp)
}

// GetNotificationsV2WithResponse request returning *GetNotificationsV2Response
func (c *ClientWithResponses) GetNotificationsV2WithResponse(ctx context.Context, params *GetNotificationsV2Params, reqEditors ...RequestEditorFn) (*GetNotificationsV2Response, error) {
	rsp, err := c.GetNotificationsV2(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNotificationsV2Response(rsp)
}

// UpdateNotificationsV2WithBodyWithResponse request with arbitrary body returning *UpdateNotificationsV2Response
func (c *ClientWithResponses) UpdateNotificationsV2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNotificationsV2Response, error) {
	rsp, err := c.UpdateNotificationsV2WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNotificationsV2Response(rsp)
}

func (c *ClientWithResponses) UpdateNotificationsV2WithResponse(ctx context.Context, body UpdateNotificationsV2JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNotificationsV2Response, error) {
	rsp, err := c.UpdateNotificationsV2(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNotificationsV2Response(rsp)
}

// GetOrganizationsWithResponse request returning *GetOrganizationsResponse
func (c *ClientWithResponses) GetOrganizationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOrganizationsResponse, error) {
	rsp, err := c.GetOrganizations(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationsResponse(rsp)
}

// CreateOrganizationWithTierWithBodyWithResponse request with arbitrary body returning *CreateOrganizationWithTierResponse
func (c *ClientWithResponses) CreateOrganizationWithTierWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrganizationWithTierResponse, error) {
	rsp, err := c.CreateOrganizationWithTierWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrganizationWithTierResponse(rsp)
}

func (c *ClientWithResponses) CreateOrganizationWithTierWithResponse(ctx context.Context, body CreateOrganizationWithTierJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrganizationWithTierResponse, error) {
	rsp, err := c.CreateOrganizationWithTier(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrganizationWithTierResponse(rsp)
}

// DeleteOrganizationWithResponse request returning *DeleteOrganizationResponse
func (c *ClientWithResponses) DeleteOrganizationWithResponse(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*DeleteOrganizationResponse, error) {
	rsp, err := c.DeleteOrganization(ctx, slug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOrganizationResponse(rsp)
}

// UpdateOrganizationWithBodyWithResponse request with arbitrary body returning *UpdateOrganizationResponse
func (c *ClientWithResponses) UpdateOrganizationWithBodyWithResponse(ctx context.Context, slug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrganizationResponse, error) {
	rsp, err := c.UpdateOrganizationWithBody(ctx, slug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrganizationResponse(rsp)
}

func (c *ClientWithResponses) UpdateOrganizationWithResponse(ctx context.Context, slug string, body UpdateOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrganizationResponse, error) {
	rsp, err := c.UpdateOrganization(ctx, slug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrganizationResponse(rsp)
}

// GetMembersWithResponse request returning *GetMembersResponse
func (c *ClientWithResponses) GetMembersWithResponse(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*GetMembersResponse, error) {
	rsp, err := c.GetMembers(ctx, slug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMembersResponse(rsp)
}

// DeleteInvitedUserWithResponse request returning *DeleteInvitedUserResponse
func (c *ClientWithResponses) DeleteInvitedUserWithResponse(ctx context.Context, slug string, params *DeleteInvitedUserParams, reqEditors ...RequestEditorFn) (*DeleteInvitedUserResponse, error) {
	rsp, err := c.DeleteInvitedUser(ctx, slug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInvitedUserResponse(rsp)
}

// GetInvitedUsersWithResponse request returning *GetInvitedUsersResponse
func (c *ClientWithResponses) GetInvitedUsersWithResponse(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*GetInvitedUsersResponse, error) {
	rsp, err := c.GetInvitedUsers(ctx, slug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvitedUsersResponse(rsp)
}

// InviteUserWithBodyWithResponse request with arbitrary body returning *InviteUserResponse
func (c *ClientWithResponses) InviteUserWithBodyWithResponse(ctx context.Context, slug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteUserResponse, error) {
	rsp, err := c.InviteUserWithBody(ctx, slug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteUserResponse(rsp)
}

func (c *ClientWithResponses) InviteUserWithResponse(ctx context.Context, slug string, body InviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteUserResponse, error) {
	rsp, err := c.InviteUser(ctx, slug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteUserResponse(rsp)
}

// GetInviteWithResponse request returning *GetInviteResponse
func (c *ClientWithResponses) GetInviteWithResponse(ctx context.Context, slug string, params *GetInviteParams, reqEditors ...RequestEditorFn) (*GetInviteResponse, error) {
	rsp, err := c.GetInvite(ctx, slug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInviteResponse(rsp)
}

// JoinOrganizationWithResponse request returning *JoinOrganizationResponse
func (c *ClientWithResponses) JoinOrganizationWithResponse(ctx context.Context, slug string, params *JoinOrganizationParams, reqEditors ...RequestEditorFn) (*JoinOrganizationResponse, error) {
	rsp, err := c.JoinOrganization(ctx, slug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJoinOrganizationResponse(rsp)
}

// DeleteMemberWithResponse request returning *DeleteMemberResponse
func (c *ClientWithResponses) DeleteMemberWithResponse(ctx context.Context, slug string, gotrueId string, reqEditors ...RequestEditorFn) (*DeleteMemberResponse, error) {
	rsp, err := c.DeleteMember(ctx, slug, gotrueId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMemberResponse(rsp)
}

// UpdateMemberWithBodyWithResponse request with arbitrary body returning *UpdateMemberResponse
func (c *ClientWithResponses) UpdateMemberWithBodyWithResponse(ctx context.Context, slug string, gotrueId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMemberResponse, error) {
	rsp, err := c.UpdateMemberWithBody(ctx, slug, gotrueId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMemberResponse(rsp)
}

func (c *ClientWithResponses) UpdateMemberWithResponse(ctx context.Context, slug string, gotrueId string, body UpdateMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMemberResponse, error) {
	rsp, err := c.UpdateMember(ctx, slug, gotrueId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMemberResponse(rsp)
}

// AddMemberWithResponse request returning *AddMemberResponse
func (c *ClientWithResponses) AddMemberWithResponse(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*AddMemberResponse, error) {
	rsp, err := c.AddMember(ctx, slug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddMemberResponse(rsp)
}

// RevokeColumnPrivilegesWithBodyWithResponse request with arbitrary body returning *RevokeColumnPrivilegesResponse
func (c *ClientWithResponses) RevokeColumnPrivilegesWithBodyWithResponse(ctx context.Context, ref string, params *RevokeColumnPrivilegesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevokeColumnPrivilegesResponse, error) {
	rsp, err := c.RevokeColumnPrivilegesWithBody(ctx, ref, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeColumnPrivilegesResponse(rsp)
}

func (c *ClientWithResponses) RevokeColumnPrivilegesWithResponse(ctx context.Context, ref string, params *RevokeColumnPrivilegesParams, body RevokeColumnPrivilegesJSONRequestBody, reqEditors ...RequestEditorFn) (*RevokeColumnPrivilegesResponse, error) {
	rsp, err := c.RevokeColumnPrivileges(ctx, ref, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeColumnPrivilegesResponse(rsp)
}

// GetColumnPrivilegesWithResponse request returning *GetColumnPrivilegesResponse
func (c *ClientWithResponses) GetColumnPrivilegesWithResponse(ctx context.Context, ref string, params *GetColumnPrivilegesParams, reqEditors ...RequestEditorFn) (*GetColumnPrivilegesResponse, error) {
	rsp, err := c.GetColumnPrivileges(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetColumnPrivilegesResponse(rsp)
}

// GrantColumnPrivilegesWithBodyWithResponse request with arbitrary body returning *GrantColumnPrivilegesResponse
func (c *ClientWithResponses) GrantColumnPrivilegesWithBodyWithResponse(ctx context.Context, ref string, params *GrantColumnPrivilegesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GrantColumnPrivilegesResponse, error) {
	rsp, err := c.GrantColumnPrivilegesWithBody(ctx, ref, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGrantColumnPrivilegesResponse(rsp)
}

func (c *ClientWithResponses) GrantColumnPrivilegesWithResponse(ctx context.Context, ref string, params *GrantColumnPrivilegesParams, body GrantColumnPrivilegesJSONRequestBody, reqEditors ...RequestEditorFn) (*GrantColumnPrivilegesResponse, error) {
	rsp, err := c.GrantColumnPrivileges(ctx, ref, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGrantColumnPrivilegesResponse(rsp)
}

// DeleteColumnWithResponse request returning *DeleteColumnResponse
func (c *ClientWithResponses) DeleteColumnWithResponse(ctx context.Context, ref string, params *DeleteColumnParams, reqEditors ...RequestEditorFn) (*DeleteColumnResponse, error) {
	rsp, err := c.DeleteColumn(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteColumnResponse(rsp)
}

// GetColumnsWithResponse request returning *GetColumnsResponse
func (c *ClientWithResponses) GetColumnsWithResponse(ctx context.Context, ref string, params *GetColumnsParams, reqEditors ...RequestEditorFn) (*GetColumnsResponse, error) {
	rsp, err := c.GetColumns(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetColumnsResponse(rsp)
}

// UpdateColumnWithBodyWithResponse request with arbitrary body returning *UpdateColumnResponse
func (c *ClientWithResponses) UpdateColumnWithBodyWithResponse(ctx context.Context, ref string, params *UpdateColumnParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateColumnResponse, error) {
	rsp, err := c.UpdateColumnWithBody(ctx, ref, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateColumnResponse(rsp)
}

func (c *ClientWithResponses) UpdateColumnWithResponse(ctx context.Context, ref string, params *UpdateColumnParams, body UpdateColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateColumnResponse, error) {
	rsp, err := c.UpdateColumn(ctx, ref, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateColumnResponse(rsp)
}

// CreateColumnWithBodyWithResponse request with arbitrary body returning *CreateColumnResponse
func (c *ClientWithResponses) CreateColumnWithBodyWithResponse(ctx context.Context, ref string, params *CreateColumnParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateColumnResponse, error) {
	rsp, err := c.CreateColumnWithBody(ctx, ref, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateColumnResponse(rsp)
}

func (c *ClientWithResponses) CreateColumnWithResponse(ctx context.Context, ref string, params *CreateColumnParams, body CreateColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateColumnResponse, error) {
	rsp, err := c.CreateColumn(ctx, ref, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateColumnResponse(rsp)
}

// DeleteExtensionWithResponse request returning *DeleteExtensionResponse
func (c *ClientWithResponses) DeleteExtensionWithResponse(ctx context.Context, ref string, params *DeleteExtensionParams, reqEditors ...RequestEditorFn) (*DeleteExtensionResponse, error) {
	rsp, err := c.DeleteExtension(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteExtensionResponse(rsp)
}

// GetExtensionsWithResponse request returning *GetExtensionsResponse
func (c *ClientWithResponses) GetExtensionsWithResponse(ctx context.Context, ref string, params *GetExtensionsParams, reqEditors ...RequestEditorFn) (*GetExtensionsResponse, error) {
	rsp, err := c.GetExtensions(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExtensionsResponse(rsp)
}

// CreateExtensionWithBodyWithResponse request with arbitrary body returning *CreateExtensionResponse
func (c *ClientWithResponses) CreateExtensionWithBodyWithResponse(ctx context.Context, ref string, params *CreateExtensionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateExtensionResponse, error) {
	rsp, err := c.CreateExtensionWithBody(ctx, ref, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateExtensionResponse(rsp)
}

func (c *ClientWithResponses) CreateExtensionWithResponse(ctx context.Context, ref string, params *CreateExtensionParams, body CreateExtensionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateExtensionResponse, error) {
	rsp, err := c.CreateExtension(ctx, ref, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateExtensionResponse(rsp)
}

// GetForeignTablesWithResponse request returning *GetForeignTablesResponse
func (c *ClientWithResponses) GetForeignTablesWithResponse(ctx context.Context, ref string, params *GetForeignTablesParams, reqEditors ...RequestEditorFn) (*GetForeignTablesResponse, error) {
	rsp, err := c.GetForeignTables(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetForeignTablesResponse(rsp)
}

// DeleteFunctionWithResponse request returning *DeleteFunctionResponse
func (c *ClientWithResponses) DeleteFunctionWithResponse(ctx context.Context, ref string, params *DeleteFunctionParams, reqEditors ...RequestEditorFn) (*DeleteFunctionResponse, error) {
	rsp, err := c.DeleteFunction(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFunctionResponse(rsp)
}

// GetFunctionsWithResponse request returning *GetFunctionsResponse
func (c *ClientWithResponses) GetFunctionsWithResponse(ctx context.Context, ref string, params *GetFunctionsParams, reqEditors ...RequestEditorFn) (*GetFunctionsResponse, error) {
	rsp, err := c.GetFunctions(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFunctionsResponse(rsp)
}

// UpdateFunctionWithBodyWithResponse request with arbitrary body returning *UpdateFunctionResponse
func (c *ClientWithResponses) UpdateFunctionWithBodyWithResponse(ctx context.Context, ref string, params *UpdateFunctionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFunctionResponse, error) {
	rsp, err := c.UpdateFunctionWithBody(ctx, ref, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFunctionResponse(rsp)
}

func (c *ClientWithResponses) UpdateFunctionWithResponse(ctx context.Context, ref string, params *UpdateFunctionParams, body UpdateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFunctionResponse, error) {
	rsp, err := c.UpdateFunction(ctx, ref, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFunctionResponse(rsp)
}

// CreateFunctionWithBodyWithResponse request with arbitrary body returning *CreateFunctionResponse
func (c *ClientWithResponses) CreateFunctionWithBodyWithResponse(ctx context.Context, ref string, params *CreateFunctionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFunctionResponse, error) {
	rsp, err := c.CreateFunctionWithBody(ctx, ref, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFunctionResponse(rsp)
}

func (c *ClientWithResponses) CreateFunctionWithResponse(ctx context.Context, ref string, params *CreateFunctionParams, body CreateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFunctionResponse, error) {
	rsp, err := c.CreateFunction(ctx, ref, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFunctionResponse(rsp)
}

// GetMaterializedViewsWithResponse request returning *GetMaterializedViewsResponse
func (c *ClientWithResponses) GetMaterializedViewsWithResponse(ctx context.Context, ref string, params *GetMaterializedViewsParams, reqEditors ...RequestEditorFn) (*GetMaterializedViewsResponse, error) {
	rsp, err := c.GetMaterializedViews(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMaterializedViewsResponse(rsp)
}

// DeletePolicyWithResponse request returning *DeletePolicyResponse
func (c *ClientWithResponses) DeletePolicyWithResponse(ctx context.Context, ref string, params *DeletePolicyParams, reqEditors ...RequestEditorFn) (*DeletePolicyResponse, error) {
	rsp, err := c.DeletePolicy(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePolicyResponse(rsp)
}

// GetPoliciesWithResponse request returning *GetPoliciesResponse
func (c *ClientWithResponses) GetPoliciesWithResponse(ctx context.Context, ref string, params *GetPoliciesParams, reqEditors ...RequestEditorFn) (*GetPoliciesResponse, error) {
	rsp, err := c.GetPolicies(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPoliciesResponse(rsp)
}

// UpdatePolicyWithBodyWithResponse request with arbitrary body returning *UpdatePolicyResponse
func (c *ClientWithResponses) UpdatePolicyWithBodyWithResponse(ctx context.Context, ref string, params *UpdatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error) {
	rsp, err := c.UpdatePolicyWithBody(ctx, ref, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePolicyResponse(rsp)
}

func (c *ClientWithResponses) UpdatePolicyWithResponse(ctx context.Context, ref string, params *UpdatePolicyParams, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error) {
	rsp, err := c.UpdatePolicy(ctx, ref, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePolicyResponse(rsp)
}

// CreatePolicyWithBodyWithResponse request with arbitrary body returning *CreatePolicyResponse
func (c *ClientWithResponses) CreatePolicyWithBodyWithResponse(ctx context.Context, ref string, params *CreatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error) {
	rsp, err := c.CreatePolicyWithBody(ctx, ref, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePolicyResponse(rsp)
}

func (c *ClientWithResponses) CreatePolicyWithResponse(ctx context.Context, ref string, params *CreatePolicyParams, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error) {
	rsp, err := c.CreatePolicy(ctx, ref, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePolicyResponse(rsp)
}

// DeletePublicationWithResponse request returning *DeletePublicationResponse
func (c *ClientWithResponses) DeletePublicationWithResponse(ctx context.Context, ref string, params *DeletePublicationParams, reqEditors ...RequestEditorFn) (*DeletePublicationResponse, error) {
	rsp, err := c.DeletePublication(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePublicationResponse(rsp)
}

// GetPublicationsWithResponse request returning *GetPublicationsResponse
func (c *ClientWithResponses) GetPublicationsWithResponse(ctx context.Context, ref string, params *GetPublicationsParams, reqEditors ...RequestEditorFn) (*GetPublicationsResponse, error) {
	rsp, err := c.GetPublications(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPublicationsResponse(rsp)
}

// UpdatePublicationWithBodyWithResponse request with arbitrary body returning *UpdatePublicationResponse
func (c *ClientWithResponses) UpdatePublicationWithBodyWithResponse(ctx context.Context, ref string, params *UpdatePublicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePublicationResponse, error) {
	rsp, err := c.UpdatePublicationWithBody(ctx, ref, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePublicationResponse(rsp)
}

func (c *ClientWithResponses) UpdatePublicationWithResponse(ctx context.Context, ref string, params *UpdatePublicationParams, body UpdatePublicationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePublicationResponse, error) {
	rsp, err := c.UpdatePublication(ctx, ref, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePublicationResponse(rsp)
}

// CreatePublicationWithBodyWithResponse request with arbitrary body returning *CreatePublicationResponse
func (c *ClientWithResponses) CreatePublicationWithBodyWithResponse(ctx context.Context, ref string, params *CreatePublicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePublicationResponse, error) {
	rsp, err := c.CreatePublicationWithBody(ctx, ref, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePublicationResponse(rsp)
}

func (c *ClientWithResponses) CreatePublicationWithResponse(ctx context.Context, ref string, params *CreatePublicationParams, body CreatePublicationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePublicationResponse, error) {
	rsp, err := c.CreatePublication(ctx, ref, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePublicationResponse(rsp)
}

// RunQueryWithBodyWithResponse request with arbitrary body returning *RunQueryResponse
func (c *ClientWithResponses) RunQueryWithBodyWithResponse(ctx context.Context, ref string, params *RunQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunQueryResponse, error) {
	rsp, err := c.RunQueryWithBody(ctx, ref, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunQueryResponse(rsp)
}

func (c *ClientWithResponses) RunQueryWithResponse(ctx context.Context, ref string, params *RunQueryParams, body RunQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*RunQueryResponse, error) {
	rsp, err := c.RunQuery(ctx, ref, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunQueryResponse(rsp)
}

// FormatQueryWithBodyWithResponse request with arbitrary body returning *FormatQueryResponse
func (c *ClientWithResponses) FormatQueryWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FormatQueryResponse, error) {
	rsp, err := c.FormatQueryWithBody(ctx, ref, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFormatQueryResponse(rsp)
}

func (c *ClientWithResponses) FormatQueryWithResponse(ctx context.Context, ref string, body FormatQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*FormatQueryResponse, error) {
	rsp, err := c.FormatQuery(ctx, ref, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFormatQueryResponse(rsp)
}

// ValidateQueryWithBodyWithResponse request with arbitrary body returning *ValidateQueryResponse
func (c *ClientWithResponses) ValidateQueryWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateQueryResponse, error) {
	rsp, err := c.ValidateQueryWithBody(ctx, ref, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateQueryResponse(rsp)
}

func (c *ClientWithResponses) ValidateQueryWithResponse(ctx context.Context, ref string, body ValidateQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateQueryResponse, error) {
	rsp, err := c.ValidateQuery(ctx, ref, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateQueryResponse(rsp)
}

// DeleteRoleWithResponse request returning *DeleteRoleResponse
func (c *ClientWithResponses) DeleteRoleWithResponse(ctx context.Context, ref string, params *DeleteRoleParams, reqEditors ...RequestEditorFn) (*DeleteRoleResponse, error) {
	rsp, err := c.DeleteRole(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRoleResponse(rsp)
}

// GetRolesWithResponse request returning *GetRolesResponse
func (c *ClientWithResponses) GetRolesWithResponse(ctx context.Context, ref string, params *GetRolesParams, reqEditors ...RequestEditorFn) (*GetRolesResponse, error) {
	rsp, err := c.GetRoles(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRolesResponse(rsp)
}

// UpdateRoleWithBodyWithResponse request with arbitrary body returning *UpdateRoleResponse
func (c *ClientWithResponses) UpdateRoleWithBodyWithResponse(ctx context.Context, ref string, params *UpdateRoleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error) {
	rsp, err := c.UpdateRoleWithBody(ctx, ref, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoleResponse(rsp)
}

func (c *ClientWithResponses) UpdateRoleWithResponse(ctx context.Context, ref string, params *UpdateRoleParams, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error) {
	rsp, err := c.UpdateRole(ctx, ref, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoleResponse(rsp)
}

// CreateRoleWithBodyWithResponse request with arbitrary body returning *CreateRoleResponse
func (c *ClientWithResponses) CreateRoleWithBodyWithResponse(ctx context.Context, ref string, params *CreateRoleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error) {
	rsp, err := c.CreateRoleWithBody(ctx, ref, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRoleResponse(rsp)
}

func (c *ClientWithResponses) CreateRoleWithResponse(ctx context.Context, ref string, params *CreateRoleParams, body CreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error) {
	rsp, err := c.CreateRole(ctx, ref, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRoleResponse(rsp)
}

// DeleteSchemaWithResponse request returning *DeleteSchemaResponse
func (c *ClientWithResponses) DeleteSchemaWithResponse(ctx context.Context, ref string, params *DeleteSchemaParams, reqEditors ...RequestEditorFn) (*DeleteSchemaResponse, error) {
	rsp, err := c.DeleteSchema(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSchemaResponse(rsp)
}

// GetSchemasWithResponse request returning *GetSchemasResponse
func (c *ClientWithResponses) GetSchemasWithResponse(ctx context.Context, ref string, params *GetSchemasParams, reqEditors ...RequestEditorFn) (*GetSchemasResponse, error) {
	rsp, err := c.GetSchemas(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchemasResponse(rsp)
}

// UpdateSchemaWithBodyWithResponse request with arbitrary body returning *UpdateSchemaResponse
func (c *ClientWithResponses) UpdateSchemaWithBodyWithResponse(ctx context.Context, ref string, params *UpdateSchemaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSchemaResponse, error) {
	rsp, err := c.UpdateSchemaWithBody(ctx, ref, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSchemaResponse(rsp)
}

func (c *ClientWithResponses) UpdateSchemaWithResponse(ctx context.Context, ref string, params *UpdateSchemaParams, body UpdateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSchemaResponse, error) {
	rsp, err := c.UpdateSchema(ctx, ref, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSchemaResponse(rsp)
}

// CreateSchemaWithBodyWithResponse request with arbitrary body returning *CreateSchemaResponse
func (c *ClientWithResponses) CreateSchemaWithBodyWithResponse(ctx context.Context, ref string, params *CreateSchemaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSchemaResponse, error) {
	rsp, err := c.CreateSchemaWithBody(ctx, ref, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSchemaResponse(rsp)
}

func (c *ClientWithResponses) CreateSchemaWithResponse(ctx context.Context, ref string, params *CreateSchemaParams, body CreateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSchemaResponse, error) {
	rsp, err := c.CreateSchema(ctx, ref, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSchemaResponse(rsp)
}

// SearchColumnsWithBodyWithResponse request with arbitrary body returning *SearchColumnsResponse
func (c *ClientWithResponses) SearchColumnsWithBodyWithResponse(ctx context.Context, ref string, params *SearchColumnsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchColumnsResponse, error) {
	rsp, err := c.SearchColumnsWithBody(ctx, ref, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchColumnsResponse(rsp)
}

func (c *ClientWithResponses) SearchColumnsWithResponse(ctx context.Context, ref string, params *SearchColumnsParams, body SearchColumnsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchColumnsResponse, error) {
	rsp, err := c.SearchColumns(ctx, ref, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchColumnsResponse(rsp)
}

// SearchTablesWithBodyWithResponse request with arbitrary body returning *SearchTablesResponse
func (c *ClientWithResponses) SearchTablesWithBodyWithResponse(ctx context.Context, ref string, params *SearchTablesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchTablesResponse, error) {
	rsp, err := c.SearchTablesWithBody(ctx, ref, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchTablesResponse(rsp)
}

func (c *ClientWithResponses) SearchTablesWithResponse(ctx context.Context, ref string, params *SearchTablesParams, body SearchTablesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchTablesResponse, error) {
	rsp, err := c.SearchTables(ctx, ref, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchTablesResponse(rsp)
}

// RevokeTablePrivilegesWithBodyWithResponse request with arbitrary body returning *RevokeTablePrivilegesResponse
func (c *ClientWithResponses) RevokeTablePrivilegesWithBodyWithResponse(ctx context.Context, ref string, params *RevokeTablePrivilegesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevokeTablePrivilegesResponse, error) {
	rsp, err := c.RevokeTablePrivilegesWithBody(ctx, ref, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeTablePrivilegesResponse(rsp)
}

func (c *ClientWithResponses) RevokeTablePrivilegesWithResponse(ctx context.Context, ref string, params *RevokeTablePrivilegesParams, body RevokeTablePrivilegesJSONRequestBody, reqEditors ...RequestEditorFn) (*RevokeTablePrivilegesResponse, error) {
	rsp, err := c.RevokeTablePrivileges(ctx, ref, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeTablePrivilegesResponse(rsp)
}

// GetTablePrivilegesWithResponse request returning *GetTablePrivilegesResponse
func (c *ClientWithResponses) GetTablePrivilegesWithResponse(ctx context.Context, ref string, params *GetTablePrivilegesParams, reqEditors ...RequestEditorFn) (*GetTablePrivilegesResponse, error) {
	rsp, err := c.GetTablePrivileges(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTablePrivilegesResponse(rsp)
}

// GrantTablePrivilegesWithBodyWithResponse request with arbitrary body returning *GrantTablePrivilegesResponse
func (c *ClientWithResponses) GrantTablePrivilegesWithBodyWithResponse(ctx context.Context, ref string, params *GrantTablePrivilegesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GrantTablePrivilegesResponse, error) {
	rsp, err := c.GrantTablePrivilegesWithBody(ctx, ref, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGrantTablePrivilegesResponse(rsp)
}

func (c *ClientWithResponses) GrantTablePrivilegesWithResponse(ctx context.Context, ref string, params *GrantTablePrivilegesParams, body GrantTablePrivilegesJSONRequestBody, reqEditors ...RequestEditorFn) (*GrantTablePrivilegesResponse, error) {
	rsp, err := c.GrantTablePrivileges(ctx, ref, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGrantTablePrivilegesResponse(rsp)
}

// DeleteTableWithResponse request returning *DeleteTableResponse
func (c *ClientWithResponses) DeleteTableWithResponse(ctx context.Context, ref string, params *DeleteTableParams, reqEditors ...RequestEditorFn) (*DeleteTableResponse, error) {
	rsp, err := c.DeleteTable(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTableResponse(rsp)
}

// GetTablesWithResponse request returning *GetTablesResponse
func (c *ClientWithResponses) GetTablesWithResponse(ctx context.Context, ref string, params *GetTablesParams, reqEditors ...RequestEditorFn) (*GetTablesResponse, error) {
	rsp, err := c.GetTables(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTablesResponse(rsp)
}

// UpdateTableWithBodyWithResponse request with arbitrary body returning *UpdateTableResponse
func (c *ClientWithResponses) UpdateTableWithBodyWithResponse(ctx context.Context, ref string, params *UpdateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTableResponse, error) {
	rsp, err := c.UpdateTableWithBody(ctx, ref, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTableResponse(rsp)
}

func (c *ClientWithResponses) UpdateTableWithResponse(ctx context.Context, ref string, params *UpdateTableParams, body UpdateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTableResponse, error) {
	rsp, err := c.UpdateTable(ctx, ref, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTableResponse(rsp)
}

// CreateTableWithBodyWithResponse request with arbitrary body returning *CreateTableResponse
func (c *ClientWithResponses) CreateTableWithBodyWithResponse(ctx context.Context, ref string, params *CreateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTableResponse, error) {
	rsp, err := c.CreateTableWithBody(ctx, ref, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTableResponse(rsp)
}

func (c *ClientWithResponses) CreateTableWithResponse(ctx context.Context, ref string, params *CreateTableParams, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTableResponse, error) {
	rsp, err := c.CreateTable(ctx, ref, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTableResponse(rsp)
}

// DeleteTriggerWithResponse request returning *DeleteTriggerResponse
func (c *ClientWithResponses) DeleteTriggerWithResponse(ctx context.Context, ref string, params *DeleteTriggerParams, reqEditors ...RequestEditorFn) (*DeleteTriggerResponse, error) {
	rsp, err := c.DeleteTrigger(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTriggerResponse(rsp)
}

// GetTriggersWithResponse request returning *GetTriggersResponse
func (c *ClientWithResponses) GetTriggersWithResponse(ctx context.Context, ref string, params *GetTriggersParams, reqEditors ...RequestEditorFn) (*GetTriggersResponse, error) {
	rsp, err := c.GetTriggers(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTriggersResponse(rsp)
}

// UpdateTriggerWithBodyWithResponse request with arbitrary body returning *UpdateTriggerResponse
func (c *ClientWithResponses) UpdateTriggerWithBodyWithResponse(ctx context.Context, ref string, params *UpdateTriggerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTriggerResponse, error) {
	rsp, err := c.UpdateTriggerWithBody(ctx, ref, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTriggerResponse(rsp)
}

func (c *ClientWithResponses) UpdateTriggerWithResponse(ctx context.Context, ref string, params *UpdateTriggerParams, body UpdateTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTriggerResponse, error) {
	rsp, err := c.UpdateTrigger(ctx, ref, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTriggerResponse(rsp)
}

// CreateTriggerWithBodyWithResponse request with arbitrary body returning *CreateTriggerResponse
func (c *ClientWithResponses) CreateTriggerWithBodyWithResponse(ctx context.Context, ref string, params *CreateTriggerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTriggerResponse, error) {
	rsp, err := c.CreateTriggerWithBody(ctx, ref, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTriggerResponse(rsp)
}

func (c *ClientWithResponses) CreateTriggerWithResponse(ctx context.Context, ref string, params *CreateTriggerParams, body CreateTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTriggerResponse, error) {
	rsp, err := c.CreateTrigger(ctx, ref, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTriggerResponse(rsp)
}

// GetTypesWithResponse request returning *GetTypesResponse
func (c *ClientWithResponses) GetTypesWithResponse(ctx context.Context, ref string, params *GetTypesParams, reqEditors ...RequestEditorFn) (*GetTypesResponse, error) {
	rsp, err := c.GetTypes(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTypesResponse(rsp)
}

// GetViewsWithResponse request returning *GetViewsResponse
func (c *ClientWithResponses) GetViewsWithResponse(ctx context.Context, ref string, params *GetViewsParams, reqEditors ...RequestEditorFn) (*GetViewsResponse, error) {
	rsp, err := c.GetViews(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetViewsResponse(rsp)
}

// GetProjectsWithResponse request returning *GetProjectsResponse
func (c *ClientWithResponses) GetProjectsWithResponse(ctx context.Context, params *GetProjectsParams, reqEditors ...RequestEditorFn) (*GetProjectsResponse, error) {
	rsp, err := c.GetProjects(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectsResponse(rsp)
}

// CreateProjectWithBodyWithResponse request with arbitrary body returning *CreateProjectResponse
func (c *ClientWithResponses) CreateProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error) {
	rsp, err := c.CreateProjectWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectResponse(rsp)
}

func (c *ClientWithResponses) CreateProjectWithResponse(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error) {
	rsp, err := c.CreateProject(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectResponse(rsp)
}

// GetProjectsMetricsWithBodyWithResponse request with arbitrary body returning *GetProjectsMetricsResponse
func (c *ClientWithResponses) GetProjectsMetricsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetProjectsMetricsResponse, error) {
	rsp, err := c.GetProjectsMetricsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectsMetricsResponse(rsp)
}

func (c *ClientWithResponses) GetProjectsMetricsWithResponse(ctx context.Context, body GetProjectsMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetProjectsMetricsResponse, error) {
	rsp, err := c.GetProjectsMetrics(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectsMetricsResponse(rsp)
}

// DeleteProjectWithResponse request returning *DeleteProjectResponse
func (c *ClientWithResponses) DeleteProjectWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*DeleteProjectResponse, error) {
	rsp, err := c.DeleteProject(ctx, ref, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectResponse(rsp)
}

// GetProjectWithResponse request returning *GetProjectResponse
func (c *ClientWithResponses) GetProjectWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*GetProjectResponse, error) {
	rsp, err := c.GetProject(ctx, ref, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectResponse(rsp)
}

// UpdateProjectWithBodyWithResponse request with arbitrary body returning *UpdateProjectResponse
func (c *ClientWithResponses) UpdateProjectWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error) {
	rsp, err := c.UpdateProjectWithBody(ctx, ref, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectResponse(rsp)
}

func (c *ClientWithResponses) UpdateProjectWithResponse(ctx context.Context, ref string, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error) {
	rsp, err := c.UpdateProject(ctx, ref, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectResponse(rsp)
}

// GetFunctionStatusWithResponse request returning *GetFunctionStatusResponse
func (c *ClientWithResponses) GetFunctionStatusWithResponse(ctx context.Context, ref string, params *GetFunctionStatusParams, reqEditors ...RequestEditorFn) (*GetFunctionStatusResponse, error) {
	rsp, err := c.GetFunctionStatus(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFunctionStatusResponse(rsp)
}

// GetApiPathsWithResponse request returning *GetApiPathsResponse
func (c *ClientWithResponses) GetApiPathsWithResponse(ctx context.Context, ref string, params *GetApiPathsParams, reqEditors ...RequestEditorFn) (*GetApiPathsResponse, error) {
	rsp, err := c.GetApiPaths(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApiPathsResponse(rsp)
}

// GetApiCountsWithResponse request returning *GetApiCountsResponse
func (c *ClientWithResponses) GetApiCountsWithResponse(ctx context.Context, ref string, params *GetApiCountsParams, reqEditors ...RequestEditorFn) (*GetApiCountsResponse, error) {
	rsp, err := c.GetApiCounts(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApiCountsResponse(rsp)
}

// ProjectGraphqlWithBodyWithResponse request with arbitrary body returning *ProjectGraphqlResponse
func (c *ClientWithResponses) ProjectGraphqlWithBodyWithResponse(ctx context.Context, ref string, params *ProjectGraphqlParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectGraphqlResponse, error) {
	rsp, err := c.ProjectGraphqlWithBody(ctx, ref, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectGraphqlResponse(rsp)
}

func (c *ClientWithResponses) ProjectGraphqlWithResponse(ctx context.Context, ref string, params *ProjectGraphqlParams, body ProjectGraphqlJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectGraphqlResponse, error) {
	rsp, err := c.ProjectGraphql(ctx, ref, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectGraphqlResponse(rsp)
}

// ProjectOpenApiWithResponse request returning *ProjectOpenApiResponse
func (c *ClientWithResponses) ProjectOpenApiWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*ProjectOpenApiResponse, error) {
	rsp, err := c.ProjectOpenApi(ctx, ref, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectOpenApiResponse(rsp)
}

// GetPgbouncerConfigWithResponse request returning *GetPgbouncerConfigResponse
func (c *ClientWithResponses) GetPgbouncerConfigWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*GetPgbouncerConfigResponse, error) {
	rsp, err := c.GetPgbouncerConfig(ctx, ref, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPgbouncerConfigResponse(rsp)
}

// UpdatePgbouncerConfigWithBodyWithResponse request with arbitrary body returning *UpdatePgbouncerConfigResponse
func (c *ClientWithResponses) UpdatePgbouncerConfigWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePgbouncerConfigResponse, error) {
	rsp, err := c.UpdatePgbouncerConfigWithBody(ctx, ref, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePgbouncerConfigResponse(rsp)
}

func (c *ClientWithResponses) UpdatePgbouncerConfigWithResponse(ctx context.Context, ref string, body UpdatePgbouncerConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePgbouncerConfigResponse, error) {
	rsp, err := c.UpdatePgbouncerConfig(ctx, ref, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePgbouncerConfigResponse(rsp)
}

// GetConfigWithResponse request returning *GetConfigResponse
func (c *ClientWithResponses) GetConfigWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*GetConfigResponse, error) {
	rsp, err := c.GetConfig(ctx, ref, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigResponse(rsp)
}

// UpdateConfigWithBodyWithResponse request with arbitrary body returning *UpdateConfigResponse
func (c *ClientWithResponses) UpdateConfigWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error) {
	rsp, err := c.UpdateConfigWithBody(ctx, ref, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConfigResponse(rsp)
}

func (c *ClientWithResponses) UpdateConfigWithResponse(ctx context.Context, ref string, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error) {
	rsp, err := c.UpdateConfig(ctx, ref, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConfigResponse(rsp)
}

// GetPostgRESTConfigWithResponse request returning *GetPostgRESTConfigResponse
func (c *ClientWithResponses) GetPostgRESTConfigWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*GetPostgRESTConfigResponse, error) {
	rsp, err := c.GetPostgRESTConfig(ctx, ref, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPostgRESTConfigResponse(rsp)
}

// UpdatePostgRESTConfigWithBodyWithResponse request with arbitrary body returning *UpdatePostgRESTConfigResponse
func (c *ClientWithResponses) UpdatePostgRESTConfigWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePostgRESTConfigResponse, error) {
	rsp, err := c.UpdatePostgRESTConfigWithBody(ctx, ref, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePostgRESTConfigResponse(rsp)
}

func (c *ClientWithResponses) UpdatePostgRESTConfigWithResponse(ctx context.Context, ref string, body UpdatePostgRESTConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePostgRESTConfigResponse, error) {
	rsp, err := c.UpdatePostgRESTConfig(ctx, ref, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePostgRESTConfigResponse(rsp)
}

// UpdateConfigWithBodyWithResponse request with arbitrary body returning *UpdateConfigResponse
func (c *ClientWithResponses) UpdateConfigWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error) {
	rsp, err := c.UpdateConfigWithBody(ctx, ref, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConfigResponse(rsp)
}

func (c *ClientWithResponses) UpdateConfigWithResponse(ctx context.Context, ref string, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error) {
	rsp, err := c.UpdateConfig(ctx, ref, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConfigResponse(rsp)
}

// GetStorageConfigWithResponse request returning *GetStorageConfigResponse
func (c *ClientWithResponses) GetStorageConfigWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*GetStorageConfigResponse, error) {
	rsp, err := c.GetStorageConfig(ctx, ref, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStorageConfigResponse(rsp)
}

// UpdateConfigWithBodyWithResponse request with arbitrary body returning *UpdateConfigResponse
func (c *ClientWithResponses) UpdateConfigWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error) {
	rsp, err := c.UpdateConfigWithBody(ctx, ref, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConfigResponse(rsp)
}

func (c *ClientWithResponses) UpdateConfigWithResponse(ctx context.Context, ref string, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error) {
	rsp, err := c.UpdateConfig(ctx, ref, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConfigResponse(rsp)
}

// DeleteContentWithResponse request returning *DeleteContentResponse
func (c *ClientWithResponses) DeleteContentWithResponse(ctx context.Context, ref string, params *DeleteContentParams, reqEditors ...RequestEditorFn) (*DeleteContentResponse, error) {
	rsp, err := c.DeleteContent(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteContentResponse(rsp)
}

// GetProjectContentWithResponse request returning *GetProjectContentResponse
func (c *ClientWithResponses) GetProjectContentWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*GetProjectContentResponse, error) {
	rsp, err := c.GetProjectContent(ctx, ref, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectContentResponse(rsp)
}

// UpdateContentWithBodyWithResponse request with arbitrary body returning *UpdateContentResponse
func (c *ClientWithResponses) UpdateContentWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateContentResponse, error) {
	rsp, err := c.UpdateContentWithBody(ctx, ref, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateContentResponse(rsp)
}

func (c *ClientWithResponses) UpdateContentWithResponse(ctx context.Context, ref string, body UpdateContentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateContentResponse, error) {
	rsp, err := c.UpdateContent(ctx, ref, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateContentResponse(rsp)
}

// CreateContentWithBodyWithResponse request with arbitrary body returning *CreateContentResponse
func (c *ClientWithResponses) CreateContentWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateContentResponse, error) {
	rsp, err := c.CreateContentWithBody(ctx, ref, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateContentResponse(rsp)
}

func (c *ClientWithResponses) CreateContentWithResponse(ctx context.Context, ref string, body CreateContentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateContentResponse, error) {
	rsp, err := c.CreateContent(ctx, ref, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateContentResponse(rsp)
}

// UpdateWholeContentWithBodyWithResponse request with arbitrary body returning *UpdateWholeContentResponse
func (c *ClientWithResponses) UpdateWholeContentWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWholeContentResponse, error) {
	rsp, err := c.UpdateWholeContentWithBody(ctx, ref, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWholeContentResponse(rsp)
}

func (c *ClientWithResponses) UpdateWholeContentWithResponse(ctx context.Context, ref string, body UpdateWholeContentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWholeContentResponse, error) {
	rsp, err := c.UpdateWholeContent(ctx, ref, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWholeContentResponse(rsp)
}

// GetDailyStatsWithResponse request returning *GetDailyStatsResponse
func (c *ClientWithResponses) GetDailyStatsWithResponse(ctx context.Context, ref string, params *GetDailyStatsParams, reqEditors ...RequestEditorFn) (*GetDailyStatsResponse, error) {
	rsp, err := c.GetDailyStats(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDailyStatsResponse(rsp)
}

// UpdatePasswordWithBodyWithResponse request with arbitrary body returning *UpdatePasswordResponse
func (c *ClientWithResponses) UpdatePasswordWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePasswordResponse, error) {
	rsp, err := c.UpdatePasswordWithBody(ctx, ref, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePasswordResponse(rsp)
}

func (c *ClientWithResponses) UpdatePasswordWithResponse(ctx context.Context, ref string, body UpdatePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePasswordResponse, error) {
	rsp, err := c.UpdatePassword(ctx, ref, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePasswordResponse(rsp)
}

// GetUsageMetricsWithResponse request returning *GetUsageMetricsResponse
func (c *ClientWithResponses) GetUsageMetricsWithResponse(ctx context.Context, ref string, params *GetUsageMetricsParams, reqEditors ...RequestEditorFn) (*GetUsageMetricsResponse, error) {
	rsp, err := c.GetUsageMetrics(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsageMetricsResponse(rsp)
}

// GetInvoicesWithResponse request returning *GetInvoicesResponse
func (c *ClientWithResponses) GetInvoicesWithResponse(ctx context.Context, ref string, params *GetInvoicesParams, reqEditors ...RequestEditorFn) (*GetInvoicesResponse, error) {
	rsp, err := c.GetInvoices(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvoicesResponse(rsp)
}

// GetInvoiceCountWithResponse request returning *GetInvoiceCountResponse
func (c *ClientWithResponses) GetInvoiceCountWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*GetInvoiceCountResponse, error) {
	rsp, err := c.GetInvoiceCount(ctx, ref, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvoiceCountResponse(rsp)
}

// ProjectHealthCheckWithResponse request returning *ProjectHealthCheckResponse
func (c *ClientWithResponses) ProjectHealthCheckWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*ProjectHealthCheckResponse, error) {
	rsp, err := c.ProjectHealthCheck(ctx, ref, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectHealthCheckResponse(rsp)
}

// PauseProjectWithResponse request returning *PauseProjectResponse
func (c *ClientWithResponses) PauseProjectWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*PauseProjectResponse, error) {
	rsp, err := c.PauseProject(ctx, ref, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePauseProjectResponse(rsp)
}

// ResizeDatabaseWithBodyWithResponse request with arbitrary body returning *ResizeDatabaseResponse
func (c *ClientWithResponses) ResizeDatabaseWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResizeDatabaseResponse, error) {
	rsp, err := c.ResizeDatabaseWithBody(ctx, ref, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResizeDatabaseResponse(rsp)
}

func (c *ClientWithResponses) ResizeDatabaseWithResponse(ctx context.Context, ref string, body ResizeDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*ResizeDatabaseResponse, error) {
	rsp, err := c.ResizeDatabase(ctx, ref, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResizeDatabaseResponse(rsp)
}

// RestartProjectWithResponse request returning *RestartProjectResponse
func (c *ClientWithResponses) RestartProjectWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*RestartProjectResponse, error) {
	rsp, err := c.RestartProject(ctx, ref, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestartProjectResponse(rsp)
}

// RestartServicesWithBodyWithResponse request with arbitrary body returning *RestartServicesResponse
func (c *ClientWithResponses) RestartServicesWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestartServicesResponse, error) {
	rsp, err := c.RestartServicesWithBody(ctx, ref, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestartServicesResponse(rsp)
}

func (c *ClientWithResponses) RestartServicesWithResponse(ctx context.Context, ref string, body RestartServicesJSONRequestBody, reqEditors ...RequestEditorFn) (*RestartServicesResponse, error) {
	rsp, err := c.RestartServices(ctx, ref, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestartServicesResponse(rsp)
}

// RestoreProjectWithBodyWithResponse request with arbitrary body returning *RestoreProjectResponse
func (c *ClientWithResponses) RestoreProjectWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestoreProjectResponse, error) {
	rsp, err := c.RestoreProjectWithBody(ctx, ref, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreProjectResponse(rsp)
}

func (c *ClientWithResponses) RestoreProjectWithResponse(ctx context.Context, ref string, body RestoreProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*RestoreProjectResponse, error) {
	rsp, err := c.RestoreProject(ctx, ref, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreProjectResponse(rsp)
}

// GetProjectApiWithResponse request returning *GetProjectApiResponse
func (c *ClientWithResponses) GetProjectApiWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*GetProjectApiResponse, error) {
	rsp, err := c.GetProjectApi(ctx, ref, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectApiResponse(rsp)
}

// GetProjectStatusWithResponse request returning *GetProjectStatusResponse
func (c *ClientWithResponses) GetProjectStatusWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*GetProjectStatusResponse, error) {
	rsp, err := c.GetProjectStatus(ctx, ref, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectStatusResponse(rsp)
}

// GetUsageStatusConfigWithResponse request returning *GetUsageStatusConfigResponse
func (c *ClientWithResponses) GetUsageStatusConfigWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*GetUsageStatusConfigResponse, error) {
	rsp, err := c.GetUsageStatusConfig(ctx, ref, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsageStatusConfigResponse(rsp)
}

// GetStatusWithResponse request returning *GetStatusResponse
func (c *ClientWithResponses) GetStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatusResponse, error) {
	rsp, err := c.GetStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatusResponse(rsp)
}

// GetBucketsWithResponse request returning *GetBucketsResponse
func (c *ClientWithResponses) GetBucketsWithResponse(ctx context.Context, ref string, reqEditors ...RequestEditorFn) (*GetBucketsResponse, error) {
	rsp, err := c.GetBuckets(ctx, ref, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBucketsResponse(rsp)
}

// CreateBucketWithBodyWithResponse request with arbitrary body returning *CreateBucketResponse
func (c *ClientWithResponses) CreateBucketWithBodyWithResponse(ctx context.Context, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBucketResponse, error) {
	rsp, err := c.CreateBucketWithBody(ctx, ref, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBucketResponse(rsp)
}

func (c *ClientWithResponses) CreateBucketWithResponse(ctx context.Context, ref string, body CreateBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBucketResponse, error) {
	rsp, err := c.CreateBucket(ctx, ref, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBucketResponse(rsp)
}

// DeleteBucketWithResponse request returning *DeleteBucketResponse
func (c *ClientWithResponses) DeleteBucketWithResponse(ctx context.Context, ref string, id string, reqEditors ...RequestEditorFn) (*DeleteBucketResponse, error) {
	rsp, err := c.DeleteBucket(ctx, ref, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBucketResponse(rsp)
}

// GetBucketWithResponse request returning *GetBucketResponse
func (c *ClientWithResponses) GetBucketWithResponse(ctx context.Context, ref string, id string, reqEditors ...RequestEditorFn) (*GetBucketResponse, error) {
	rsp, err := c.GetBucket(ctx, ref, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBucketResponse(rsp)
}

// UpdateBucketWithBodyWithResponse request with arbitrary body returning *UpdateBucketResponse
func (c *ClientWithResponses) UpdateBucketWithBodyWithResponse(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBucketResponse, error) {
	rsp, err := c.UpdateBucketWithBody(ctx, ref, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBucketResponse(rsp)
}

func (c *ClientWithResponses) UpdateBucketWithResponse(ctx context.Context, ref string, id string, body UpdateBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBucketResponse, error) {
	rsp, err := c.UpdateBucket(ctx, ref, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBucketResponse(rsp)
}

// EmptyBucketWithResponse request returning *EmptyBucketResponse
func (c *ClientWithResponses) EmptyBucketWithResponse(ctx context.Context, ref string, id string, reqEditors ...RequestEditorFn) (*EmptyBucketResponse, error) {
	rsp, err := c.EmptyBucket(ctx, ref, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmptyBucketResponse(rsp)
}

// DeleteObjectsWithBodyWithResponse request with arbitrary body returning *DeleteObjectsResponse
func (c *ClientWithResponses) DeleteObjectsWithBodyWithResponse(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteObjectsResponse, error) {
	rsp, err := c.DeleteObjectsWithBody(ctx, ref, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteObjectsResponse(rsp)
}

func (c *ClientWithResponses) DeleteObjectsWithResponse(ctx context.Context, ref string, id string, body DeleteObjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteObjectsResponse, error) {
	rsp, err := c.DeleteObjects(ctx, ref, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteObjectsResponse(rsp)
}

// CopyObjectWithBodyWithResponse request with arbitrary body returning *CopyObjectResponse
func (c *ClientWithResponses) CopyObjectWithBodyWithResponse(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CopyObjectResponse, error) {
	rsp, err := c.CopyObjectWithBody(ctx, ref, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCopyObjectResponse(rsp)
}

func (c *ClientWithResponses) CopyObjectWithResponse(ctx context.Context, ref string, id string, body CopyObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CopyObjectResponse, error) {
	rsp, err := c.CopyObject(ctx, ref, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCopyObjectResponse(rsp)
}

// DownloadWithBodyWithResponse request with arbitrary body returning *DownloadResponse
func (c *ClientWithResponses) DownloadWithBodyWithResponse(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DownloadResponse, error) {
	rsp, err := c.DownloadWithBody(ctx, ref, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadResponse(rsp)
}

func (c *ClientWithResponses) DownloadWithResponse(ctx context.Context, ref string, id string, body DownloadJSONRequestBody, reqEditors ...RequestEditorFn) (*DownloadResponse, error) {
	rsp, err := c.Download(ctx, ref, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadResponse(rsp)
}

// GetObjectsWithBodyWithResponse request with arbitrary body returning *GetObjectsResponse
func (c *ClientWithResponses) GetObjectsWithBodyWithResponse(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetObjectsResponse, error) {
	rsp, err := c.GetObjectsWithBody(ctx, ref, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetObjectsResponse(rsp)
}

func (c *ClientWithResponses) GetObjectsWithResponse(ctx context.Context, ref string, id string, body GetObjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetObjectsResponse, error) {
	rsp, err := c.GetObjects(ctx, ref, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetObjectsResponse(rsp)
}

// MoveObjectWithBodyWithResponse request with arbitrary body returning *MoveObjectResponse
func (c *ClientWithResponses) MoveObjectWithBodyWithResponse(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MoveObjectResponse, error) {
	rsp, err := c.MoveObjectWithBody(ctx, ref, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMoveObjectResponse(rsp)
}

func (c *ClientWithResponses) MoveObjectWithResponse(ctx context.Context, ref string, id string, body MoveObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*MoveObjectResponse, error) {
	rsp, err := c.MoveObject(ctx, ref, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMoveObjectResponse(rsp)
}

// CreatePublicUrlWithBodyWithResponse request with arbitrary body returning *CreatePublicUrlResponse
func (c *ClientWithResponses) CreatePublicUrlWithBodyWithResponse(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePublicUrlResponse, error) {
	rsp, err := c.CreatePublicUrlWithBody(ctx, ref, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePublicUrlResponse(rsp)
}

func (c *ClientWithResponses) CreatePublicUrlWithResponse(ctx context.Context, ref string, id string, body CreatePublicUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePublicUrlResponse, error) {
	rsp, err := c.CreatePublicUrl(ctx, ref, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePublicUrlResponse(rsp)
}

// CreateSignedUrlWithBodyWithResponse request with arbitrary body returning *CreateSignedUrlResponse
func (c *ClientWithResponses) CreateSignedUrlWithBodyWithResponse(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSignedUrlResponse, error) {
	rsp, err := c.CreateSignedUrlWithBody(ctx, ref, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSignedUrlResponse(rsp)
}

func (c *ClientWithResponses) CreateSignedUrlWithResponse(ctx context.Context, ref string, id string, body CreateSignedUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSignedUrlResponse, error) {
	rsp, err := c.CreateSignedUrl(ctx, ref, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSignedUrlResponse(rsp)
}

// CreateSignedUrlsWithBodyWithResponse request with arbitrary body returning *CreateSignedUrlsResponse
func (c *ClientWithResponses) CreateSignedUrlsWithBodyWithResponse(ctx context.Context, ref string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSignedUrlsResponse, error) {
	rsp, err := c.CreateSignedUrlsWithBody(ctx, ref, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSignedUrlsResponse(rsp)
}

func (c *ClientWithResponses) CreateSignedUrlsWithResponse(ctx context.Context, ref string, id string, body CreateSignedUrlsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSignedUrlsResponse, error) {
	rsp, err := c.CreateSignedUrls(ctx, ref, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSignedUrlsResponse(rsp)
}

// ParseGetGoTrueConfigResponse parses an HTTP response from a GetGoTrueConfigWithResponse call
func ParseGetGoTrueConfigResponse(rsp *http.Response) (*GetGoTrueConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGoTrueConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetGoTrueConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateGoTrueConfigResponse parses an HTTP response from a UpdateGoTrueConfigWithResponse call
func ParseUpdateGoTrueConfigResponse(rsp *http.Response) (*UpdateGoTrueConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateGoTrueConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GoTrueConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSendInviteResponse parses an HTTP response from a SendInviteWithResponse call
func ParseSendInviteResponse(rsp *http.Response) (*SendInviteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendInviteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseSendMagicLinkResponse parses an HTTP response from a SendMagicLinkWithResponse call
func ParseSendMagicLinkResponse(rsp *http.Response) (*SendMagicLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendMagicLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseSendOtpResponse parses an HTTP response from a SendOtpWithResponse call
func ParseSendOtpResponse(rsp *http.Response) (*SendOtpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendOtpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseSendRecoverResponse parses an HTTP response from a SendRecoverWithResponse call
func ParseSendRecoverResponse(rsp *http.Response) (*SendRecoverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendRecoverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetTemplateResponse parses an HTTP response from a GetTemplateWithResponse call
func ParseGetTemplateResponse(rsp *http.Response) (*GetTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUsersResponse parses an HTTP response from a GetUsersWithResponse call
func ParseGetUsersResponse(rsp *http.Response) (*GetUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UsersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteFactorsResponse parses an HTTP response from a DeleteFactorsWithResponse call
func ParseDeleteFactorsResponse(rsp *http.Response) (*DeleteFactorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFactorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBackupsResponse parses an HTTP response from a GetBackupsWithResponse call
func ParseGetBackupsResponse(rsp *http.Response) (*GetBackupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBackupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackupsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDownloadBackupResponse parses an HTTP response from a DownloadBackupWithResponse call
func ParseDownloadBackupResponse(rsp *http.Response) (*DownloadBackupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadBackupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DownloadBackupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseRestorePointInTimeBackupResponse parses an HTTP response from a RestorePointInTimeBackupWithResponse call
func ParseRestorePointInTimeBackupResponse(rsp *http.Response) (*RestorePointInTimeBackupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestorePointInTimeBackupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRestoreBackupResponse parses an HTTP response from a RestoreBackupWithResponse call
func ParseRestoreBackupResponse(rsp *http.Response) (*RestoreBackupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreBackupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRestorePhysicalBackupResponse parses an HTTP response from a RestorePhysicalBackupWithResponse call
func ParseRestorePhysicalBackupResponse(rsp *http.Response) (*RestorePhysicalBackupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestorePhysicalBackupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEnableHooksResponse parses an HTTP response from a EnableHooksWithResponse call
func ParseEnableHooksResponse(rsp *http.Response) (*EnableHooksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnableHooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetHookLogsResponse parses an HTTP response from a GetHookLogsWithResponse call
func ParseGetHookLogsResponse(rsp *http.Response) (*GetHookLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHookLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteNotificationsResponse parses an HTTP response from a DeleteNotificationsWithResponse call
func ParseDeleteNotificationsResponse(rsp *http.Response) (*DeleteNotificationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNotificationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []NotificationResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetNotificationsV2Response parses an HTTP response from a GetNotificationsV2WithResponse call
func ParseGetNotificationsV2Response(rsp *http.Response) (*GetNotificationsV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNotificationsV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []NotificationResponseV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateNotificationsV2Response parses an HTTP response from a UpdateNotificationsV2WithResponse call
func ParseUpdateNotificationsV2Response(rsp *http.Response) (*UpdateNotificationsV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateNotificationsV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []NotificationResponseV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOrganizationsResponse parses an HTTP response from a GetOrganizationsWithResponse call
func ParseGetOrganizationsResponse(rsp *http.Response) (*GetOrganizationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OrganizationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateOrganizationWithTierResponse parses an HTTP response from a CreateOrganizationWithTierWithResponse call
func ParseCreateOrganizationWithTierResponse(rsp *http.Response) (*CreateOrganizationWithTierResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrganizationWithTierResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest OrganizationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteOrganizationResponse parses an HTTP response from a DeleteOrganizationWithResponse call
func ParseDeleteOrganizationResponse(rsp *http.Response) (*DeleteOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateOrganizationResponse parses an HTTP response from a UpdateOrganizationWithResponse call
func ParseUpdateOrganizationResponse(rsp *http.Response) (*UpdateOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrganizationSlugResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMembersResponse parses an HTTP response from a GetMembersWithResponse call
func ParseGetMembersResponse(rsp *http.Response) (*GetMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Member
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteInvitedUserResponse parses an HTTP response from a DeleteInvitedUserWithResponse call
func ParseDeleteInvitedUserResponse(rsp *http.Response) (*DeleteInvitedUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInvitedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetInvitedUsersResponse parses an HTTP response from a GetInvitedUsersWithResponse call
func ParseGetInvitedUsersResponse(rsp *http.Response) (*GetInvitedUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvitedUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Invite
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInviteUserResponse parses an HTTP response from a InviteUserWithResponse call
func ParseInviteUserResponse(rsp *http.Response) (*InviteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InviteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SendInviteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetInviteResponse parses an HTTP response from a GetInviteWithResponse call
func ParseGetInviteResponse(rsp *http.Response) (*GetInviteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInviteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InviteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseJoinOrganizationResponse parses an HTTP response from a JoinOrganizationWithResponse call
func ParseJoinOrganizationResponse(rsp *http.Response) (*JoinOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JoinOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest JoinResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteMemberResponse parses an HTTP response from a DeleteMemberWithResponse call
func ParseDeleteMemberResponse(rsp *http.Response) (*DeleteMemberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateMemberResponse parses an HTTP response from a UpdateMemberWithResponse call
func ParseUpdateMemberResponse(rsp *http.Response) (*UpdateMemberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddMemberResponse parses an HTTP response from a AddMemberWithResponse call
func ParseAddMemberResponse(rsp *http.Response) (*AddMemberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Role
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRevokeColumnPrivilegesResponse parses an HTTP response from a RevokeColumnPrivilegesWithResponse call
func ParseRevokeColumnPrivilegesResponse(rsp *http.Response) (*RevokeColumnPrivilegesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokeColumnPrivilegesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PostgresColumnPrivileges
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetColumnPrivilegesResponse parses an HTTP response from a GetColumnPrivilegesWithResponse call
func ParseGetColumnPrivilegesResponse(rsp *http.Response) (*GetColumnPrivilegesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetColumnPrivilegesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PostgresColumnPrivileges
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGrantColumnPrivilegesResponse parses an HTTP response from a GrantColumnPrivilegesWithResponse call
func ParseGrantColumnPrivilegesResponse(rsp *http.Response) (*GrantColumnPrivilegesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GrantColumnPrivilegesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest []PostgresColumnPrivileges
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteColumnResponse parses an HTTP response from a DeleteColumnWithResponse call
func ParseDeleteColumnResponse(rsp *http.Response) (*DeleteColumnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteColumnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostgresColumn
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetColumnsResponse parses an HTTP response from a GetColumnsWithResponse call
func ParseGetColumnsResponse(rsp *http.Response) (*GetColumnsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetColumnsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PostgresColumn
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateColumnResponse parses an HTTP response from a UpdateColumnWithResponse call
func ParseUpdateColumnResponse(rsp *http.Response) (*UpdateColumnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateColumnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostgresColumn
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateColumnResponse parses an HTTP response from a CreateColumnWithResponse call
func ParseCreateColumnResponse(rsp *http.Response) (*CreateColumnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateColumnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PostgresColumn
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteExtensionResponse parses an HTTP response from a DeleteExtensionWithResponse call
func ParseDeleteExtensionResponse(rsp *http.Response) (*DeleteExtensionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteExtensionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostgresExtension
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetExtensionsResponse parses an HTTP response from a GetExtensionsWithResponse call
func ParseGetExtensionsResponse(rsp *http.Response) (*GetExtensionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExtensionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PostgresExtension
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateExtensionResponse parses an HTTP response from a CreateExtensionWithResponse call
func ParseCreateExtensionResponse(rsp *http.Response) (*CreateExtensionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateExtensionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PostgresExtension
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetForeignTablesResponse parses an HTTP response from a GetForeignTablesWithResponse call
func ParseGetForeignTablesResponse(rsp *http.Response) (*GetForeignTablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetForeignTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PostgresForeignTable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteFunctionResponse parses an HTTP response from a DeleteFunctionWithResponse call
func ParseDeleteFunctionResponse(rsp *http.Response) (*DeleteFunctionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFunctionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostgresFunction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFunctionsResponse parses an HTTP response from a GetFunctionsWithResponse call
func ParseGetFunctionsResponse(rsp *http.Response) (*GetFunctionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFunctionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PostgresFunction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateFunctionResponse parses an HTTP response from a UpdateFunctionWithResponse call
func ParseUpdateFunctionResponse(rsp *http.Response) (*UpdateFunctionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFunctionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostgresFunction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateFunctionResponse parses an HTTP response from a CreateFunctionWithResponse call
func ParseCreateFunctionResponse(rsp *http.Response) (*CreateFunctionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFunctionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PostgresFunction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetMaterializedViewsResponse parses an HTTP response from a GetMaterializedViewsWithResponse call
func ParseGetMaterializedViewsResponse(rsp *http.Response) (*GetMaterializedViewsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMaterializedViewsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PostgresMaterializedView
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeletePolicyResponse parses an HTTP response from a DeletePolicyWithResponse call
func ParseDeletePolicyResponse(rsp *http.Response) (*DeletePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostgresPolicy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPoliciesResponse parses an HTTP response from a GetPoliciesWithResponse call
func ParseGetPoliciesResponse(rsp *http.Response) (*GetPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PostgresPolicy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdatePolicyResponse parses an HTTP response from a UpdatePolicyWithResponse call
func ParseUpdatePolicyResponse(rsp *http.Response) (*UpdatePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostgresPolicy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreatePolicyResponse parses an HTTP response from a CreatePolicyWithResponse call
func ParseCreatePolicyResponse(rsp *http.Response) (*CreatePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PostgresPolicy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeletePublicationResponse parses an HTTP response from a DeletePublicationWithResponse call
func ParseDeletePublicationResponse(rsp *http.Response) (*DeletePublicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePublicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostgresPublication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPublicationsResponse parses an HTTP response from a GetPublicationsWithResponse call
func ParseGetPublicationsResponse(rsp *http.Response) (*GetPublicationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPublicationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PostgresPublication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdatePublicationResponse parses an HTTP response from a UpdatePublicationWithResponse call
func ParseUpdatePublicationResponse(rsp *http.Response) (*UpdatePublicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePublicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostgresPublication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreatePublicationResponse parses an HTTP response from a CreatePublicationWithResponse call
func ParseCreatePublicationResponse(rsp *http.Response) (*CreatePublicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePublicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PostgresPublication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseRunQueryResponse parses an HTTP response from a RunQueryWithResponse call
func ParseRunQueryResponse(rsp *http.Response) (*RunQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseFormatQueryResponse parses an HTTP response from a FormatQueryWithResponse call
func ParseFormatQueryResponse(rsp *http.Response) (*FormatQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FormatQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseValidateQueryResponse parses an HTTP response from a ValidateQueryWithResponse call
func ParseValidateQueryResponse(rsp *http.Response) (*ValidateQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ValidateQueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteRoleResponse parses an HTTP response from a DeleteRoleWithResponse call
func ParseDeleteRoleResponse(rsp *http.Response) (*DeleteRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostgresRole
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRolesResponse parses an HTTP response from a GetRolesWithResponse call
func ParseGetRolesResponse(rsp *http.Response) (*GetRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PostgresRole
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateRoleResponse parses an HTTP response from a UpdateRoleWithResponse call
func ParseUpdateRoleResponse(rsp *http.Response) (*UpdateRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostgresRole
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateRoleResponse parses an HTTP response from a CreateRoleWithResponse call
func ParseCreateRoleResponse(rsp *http.Response) (*CreateRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PostgresRole
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteSchemaResponse parses an HTTP response from a DeleteSchemaWithResponse call
func ParseDeleteSchemaResponse(rsp *http.Response) (*DeleteSchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostgresSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSchemasResponse parses an HTTP response from a GetSchemasWithResponse call
func ParseGetSchemasResponse(rsp *http.Response) (*GetSchemasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchemasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PostgresSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateSchemaResponse parses an HTTP response from a UpdateSchemaWithResponse call
func ParseUpdateSchemaResponse(rsp *http.Response) (*UpdateSchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostgresSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSchemaResponse parses an HTTP response from a CreateSchemaWithResponse call
func ParseCreateSchemaResponse(rsp *http.Response) (*CreateSchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PostgresSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseSearchColumnsResponse parses an HTTP response from a SearchColumnsWithResponse call
func ParseSearchColumnsResponse(rsp *http.Response) (*SearchColumnsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchColumnsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest []Column
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseSearchTablesResponse parses an HTTP response from a SearchTablesWithResponse call
func ParseSearchTablesResponse(rsp *http.Response) (*SearchTablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest []Table
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseRevokeTablePrivilegesResponse parses an HTTP response from a RevokeTablePrivilegesWithResponse call
func ParseRevokeTablePrivilegesResponse(rsp *http.Response) (*RevokeTablePrivilegesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokeTablePrivilegesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PostgresTablePrivileges
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTablePrivilegesResponse parses an HTTP response from a GetTablePrivilegesWithResponse call
func ParseGetTablePrivilegesResponse(rsp *http.Response) (*GetTablePrivilegesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTablePrivilegesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PostgresTablePrivileges
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGrantTablePrivilegesResponse parses an HTTP response from a GrantTablePrivilegesWithResponse call
func ParseGrantTablePrivilegesResponse(rsp *http.Response) (*GrantTablePrivilegesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GrantTablePrivilegesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest []PostgresTablePrivileges
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteTableResponse parses an HTTP response from a DeleteTableWithResponse call
func ParseDeleteTableResponse(rsp *http.Response) (*DeleteTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostgresTable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTablesResponse parses an HTTP response from a GetTablesWithResponse call
func ParseGetTablesResponse(rsp *http.Response) (*GetTablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PostgresTable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateTableResponse parses an HTTP response from a UpdateTableWithResponse call
func ParseUpdateTableResponse(rsp *http.Response) (*UpdateTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostgresTable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateTableResponse parses an HTTP response from a CreateTableWithResponse call
func ParseCreateTableResponse(rsp *http.Response) (*CreateTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PostgresTable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteTriggerResponse parses an HTTP response from a DeleteTriggerWithResponse call
func ParseDeleteTriggerResponse(rsp *http.Response) (*DeleteTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostgresTrigger
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTriggersResponse parses an HTTP response from a GetTriggersWithResponse call
func ParseGetTriggersResponse(rsp *http.Response) (*GetTriggersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTriggersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PostgresTrigger
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateTriggerResponse parses an HTTP response from a UpdateTriggerWithResponse call
func ParseUpdateTriggerResponse(rsp *http.Response) (*UpdateTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostgresTrigger
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateTriggerResponse parses an HTTP response from a CreateTriggerWithResponse call
func ParseCreateTriggerResponse(rsp *http.Response) (*CreateTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PostgresTrigger
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetTypesResponse parses an HTTP response from a GetTypesWithResponse call
func ParseGetTypesResponse(rsp *http.Response) (*GetTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PostgresType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetViewsResponse parses an HTTP response from a GetViewsWithResponse call
func ParseGetViewsResponse(rsp *http.Response) (*GetViewsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetViewsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PostgresView
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProjectsResponse parses an HTTP response from a GetProjectsWithResponse call
func ParseGetProjectsResponse(rsp *http.Response) (*GetProjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ProjectInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateProjectResponse parses an HTTP response from a CreateProjectWithResponse call
func ParseCreateProjectResponse(rsp *http.Response) (*CreateProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateProjectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetProjectsMetricsResponse parses an HTTP response from a GetProjectsMetricsWithResponse call
func ParseGetProjectsMetricsResponse(rsp *http.Response) (*GetProjectsMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectsMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetMetricsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteProjectResponse parses an HTTP response from a DeleteProjectWithResponse call
func ParseDeleteProjectResponse(rsp *http.Response) (*DeleteProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectRefResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProjectResponse parses an HTTP response from a GetProjectWithResponse call
func ParseGetProjectResponse(rsp *http.Response) (*GetProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectDetailResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateProjectResponse parses an HTTP response from a UpdateProjectWithResponse call
func ParseUpdateProjectResponse(rsp *http.Response) (*UpdateProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectRefResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFunctionStatusResponse parses an HTTP response from a GetFunctionStatusWithResponse call
func ParseGetFunctionStatusResponse(rsp *http.Response) (*GetFunctionStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFunctionStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnalyticsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApiPathsResponse parses an HTTP response from a GetApiPathsWithResponse call
func ParseGetApiPathsResponse(rsp *http.Response) (*GetApiPathsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApiPathsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnalyticsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApiCountsResponse parses an HTTP response from a GetApiCountsWithResponse call
func ParseGetApiCountsResponse(rsp *http.Response) (*GetApiCountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApiCountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnalyticsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProjectGraphqlResponse parses an HTTP response from a ProjectGraphqlWithResponse call
func ParseProjectGraphqlResponse(rsp *http.Response) (*ProjectGraphqlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectGraphqlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseProjectOpenApiResponse parses an HTTP response from a ProjectOpenApiWithResponse call
func ParseProjectOpenApiResponse(rsp *http.Response) (*ProjectOpenApiResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectOpenApiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPgbouncerConfigResponse parses an HTTP response from a GetPgbouncerConfigWithResponse call
func ParseGetPgbouncerConfigResponse(rsp *http.Response) (*GetPgbouncerConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPgbouncerConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PgbouncerConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdatePgbouncerConfigResponse parses an HTTP response from a UpdatePgbouncerConfigWithResponse call
func ParseUpdatePgbouncerConfigResponse(rsp *http.Response) (*UpdatePgbouncerConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePgbouncerConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdatePoolingConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetConfigResponse parses an HTTP response from a GetConfigWithResponse call
func ParseGetConfigResponse(rsp *http.Response) (*GetConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostgresConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateConfigResponse parses an HTTP response from a UpdateConfigWithResponse call
func ParseUpdateConfigResponse(rsp *http.Response) (*UpdateConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostgresConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPostgRESTConfigResponse parses an HTTP response from a GetPostgRESTConfigWithResponse call
func ParseGetPostgRESTConfigResponse(rsp *http.Response) (*GetPostgRESTConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPostgRESTConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostgrestConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdatePostgRESTConfigResponse parses an HTTP response from a UpdatePostgRESTConfigWithResponse call
func ParseUpdatePostgRESTConfigResponse(rsp *http.Response) (*UpdatePostgRESTConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePostgRESTConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostgrestConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateConfigResponse parses an HTTP response from a UpdateConfigWithResponse call
func ParseUpdateConfigResponse(rsp *http.Response) (*UpdateConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateSecretsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetStorageConfigResponse parses an HTTP response from a GetStorageConfigWithResponse call
func ParseGetStorageConfigResponse(rsp *http.Response) (*GetStorageConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStorageConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StorageConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateConfigResponse parses an HTTP response from a UpdateConfigWithResponse call
func ParseUpdateConfigResponse(rsp *http.Response) (*UpdateConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateStorageConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteContentResponse parses an HTTP response from a DeleteContentWithResponse call
func ParseDeleteContentResponse(rsp *http.Response) (*DeleteContentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteContentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserContentObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProjectContentResponse parses an HTTP response from a GetProjectContentWithResponse call
func ParseGetProjectContentResponse(rsp *http.Response) (*GetProjectContentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectContentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUserContentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateContentResponse parses an HTTP response from a UpdateContentWithResponse call
func ParseUpdateContentResponse(rsp *http.Response) (*UpdateContentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateContentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []UserContentObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateContentResponse parses an HTTP response from a CreateContentWithResponse call
func ParseCreateContentResponse(rsp *http.Response) (*CreateContentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateContentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest []UserContentObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseUpdateWholeContentResponse parses an HTTP response from a UpdateWholeContentWithResponse call
func ParseUpdateWholeContentResponse(rsp *http.Response) (*UpdateWholeContentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateWholeContentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserContentObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDailyStatsResponse parses an HTTP response from a GetDailyStatsWithResponse call
func ParseGetDailyStatsResponse(rsp *http.Response) (*GetDailyStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDailyStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdatePasswordResponse parses an HTTP response from a UpdatePasswordWithResponse call
func ParseUpdatePasswordResponse(rsp *http.Response) (*UpdatePasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUsageMetricsResponse parses an HTTP response from a GetUsageMetricsWithResponse call
func ParseGetUsageMetricsResponse(rsp *http.Response) (*GetUsageMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsageMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetInvoicesResponse parses an HTTP response from a GetInvoicesWithResponse call
func ParseGetInvoicesResponse(rsp *http.Response) (*GetInvoicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvoicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetInvoiceCountResponse parses an HTTP response from a GetInvoiceCountWithResponse call
func ParseGetInvoiceCountResponse(rsp *http.Response) (*GetInvoiceCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvoiceCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseProjectHealthCheckResponse parses an HTTP response from a ProjectHealthCheckWithResponse call
func ParseProjectHealthCheckResponse(rsp *http.Response) (*ProjectHealthCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectHealthCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePauseProjectResponse parses an HTTP response from a PauseProjectWithResponse call
func ParsePauseProjectResponse(rsp *http.Response) (*PauseProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PauseProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseResizeDatabaseResponse parses an HTTP response from a ResizeDatabaseWithResponse call
func ParseResizeDatabaseResponse(rsp *http.Response) (*ResizeDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResizeDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRestartProjectResponse parses an HTTP response from a RestartProjectWithResponse call
func ParseRestartProjectResponse(rsp *http.Response) (*RestartProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestartProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRestartServicesResponse parses an HTTP response from a RestartServicesWithResponse call
func ParseRestartServicesResponse(rsp *http.Response) (*RestartServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestartServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRestoreProjectResponse parses an HTTP response from a RestoreProjectWithResponse call
func ParseRestoreProjectResponse(rsp *http.Response) (*RestoreProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RestoreProjectInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetProjectApiResponse parses an HTTP response from a GetProjectApiWithResponse call
func ParseGetProjectApiResponse(rsp *http.Response) (*GetProjectApiResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectApiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectSettingsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProjectStatusResponse parses an HTTP response from a GetProjectStatusWithResponse call
func ParseGetProjectStatusResponse(rsp *http.Response) (*GetProjectStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUsageStatusConfigResponse parses an HTTP response from a GetUsageStatusConfigWithResponse call
func ParseGetUsageStatusConfigResponse(rsp *http.Response) (*GetUsageStatusConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsageStatusConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UsageStatusResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetStatusResponse parses an HTTP response from a GetStatusWithResponse call
func ParseGetStatusResponse(rsp *http.Response) (*GetStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBucketsResponse parses an HTTP response from a GetBucketsWithResponse call
func ParseGetBucketsResponse(rsp *http.Response) (*GetBucketsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBucketsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []StorageBucket
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateBucketResponse parses an HTTP response from a CreateBucketWithResponse call
func ParseCreateBucketResponse(rsp *http.Response) (*CreateBucketResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBucketResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteBucketResponse parses an HTTP response from a DeleteBucketWithResponse call
func ParseDeleteBucketResponse(rsp *http.Response) (*DeleteBucketResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBucketResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBucketResponse parses an HTTP response from a GetBucketWithResponse call
func ParseGetBucketResponse(rsp *http.Response) (*GetBucketResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBucketResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StorageBucket
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateBucketResponse parses an HTTP response from a UpdateBucketWithResponse call
func ParseUpdateBucketResponse(rsp *http.Response) (*UpdateBucketResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateBucketResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEmptyBucketResponse parses an HTTP response from a EmptyBucketWithResponse call
func ParseEmptyBucketResponse(rsp *http.Response) (*EmptyBucketResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EmptyBucketResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteObjectsResponse parses an HTTP response from a DeleteObjectsWithResponse call
func ParseDeleteObjectsResponse(rsp *http.Response) (*DeleteObjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteObjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCopyObjectResponse parses an HTTP response from a CopyObjectWithResponse call
func ParseCopyObjectResponse(rsp *http.Response) (*CopyObjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CopyObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CopyObjectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDownloadResponse parses an HTTP response from a DownloadWithResponse call
func ParseDownloadResponse(rsp *http.Response) (*DownloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetObjectsResponse parses an HTTP response from a GetObjectsWithResponse call
func ParseGetObjectsResponse(rsp *http.Response) (*GetObjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetObjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest []StorageObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseMoveObjectResponse parses an HTTP response from a MoveObjectWithResponse call
func ParseMoveObjectResponse(rsp *http.Response) (*MoveObjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MoveObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreatePublicUrlResponse parses an HTTP response from a CreatePublicUrlWithResponse call
func ParseCreatePublicUrlResponse(rsp *http.Response) (*CreatePublicUrlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePublicUrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PublicUrlResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseCreateSignedUrlResponse parses an HTTP response from a CreateSignedUrlWithResponse call
func ParseCreateSignedUrlResponse(rsp *http.Response) (*CreateSignedUrlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSignedUrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SignedUrlResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseCreateSignedUrlsResponse parses an HTTP response from a CreateSignedUrlsWithResponse call
func ParseCreateSignedUrlsResponse(rsp *http.Response) (*CreateSignedUrlsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSignedUrlsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest []SignedUrlsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Gets GoTrue config
	// (GET /v0/auth/{ref}/config)
	GetGoTrueConfig(ctx echo.Context, ref string) error
	// Updates GoTrue config
	// (PATCH /v0/auth/{ref}/config)
	UpdateGoTrueConfig(ctx echo.Context, ref string) error
	// Sends an invite to the given email
	// (POST /v0/auth/{ref}/invite)
	SendInvite(ctx echo.Context, ref string) error
	// Sends a magic link to the given email
	// (POST /v0/auth/{ref}/magiclink)
	SendMagicLink(ctx echo.Context, ref string) error
	// Sends an OTP to the given phone number
	// (POST /v0/auth/{ref}/otp)
	SendOtp(ctx echo.Context, ref string) error
	// Sends a recovery email to the given email
	// (POST /v0/auth/{ref}/recover)
	SendRecover(ctx echo.Context, ref string) error
	// Gets GoTrue template
	// (GET /v0/auth/{ref}/templates/{template})
	GetTemplate(ctx echo.Context, ref string, template GetTemplateParamsTemplate) error
	// Delete user with given ID
	// (DELETE /v0/auth/{ref}/users)
	DeleteUser(ctx echo.Context, ref string) error
	// Gets users
	// (GET /v0/auth/{ref}/users)
	GetUsers(ctx echo.Context, ref string, params GetUsersParams) error
	// Delete all factors associated to a user
	// (DELETE /v0/auth/{ref}/users/{id}/factors)
	DeleteFactors(ctx echo.Context, ref string, id string) error
	// Gets project backups
	// (GET /v0/database/{ref}/backups)
	GetBackups(ctx echo.Context, ref string) error
	// Download project backup
	// (POST /v0/database/{ref}/backups/download)
	DownloadBackup(ctx echo.Context, ref string) error
	// Restore project to a previous point in time
	// (POST /v0/database/{ref}/backups/pitr)
	RestorePointInTimeBackup(ctx echo.Context, ref string) error
	// Restore project backup
	// (POST /v0/database/{ref}/backups/restore)
	RestoreBackup(ctx echo.Context, ref string) error
	// Restore project with a physical backup
	// (POST /v0/database/{ref}/backups/restore-physical)
	RestorePhysicalBackup(ctx echo.Context, ref string) error
	// Enables Database Webhooks on the project
	// (POST /v0/database/{ref}/hook-enable)
	EnableHooks(ctx echo.Context, ref string) error
	// Gets hook logs with the given ID
	// (GET /v0/database/{ref}/hook-logs)
	GetHookLogs(ctx echo.Context, ref string, params GetHookLogsParams) error
	// Delete notifications
	// (DELETE /v0/notifications)
	DeleteNotifications(ctx echo.Context) error
	// Get notifications
	// (GET /v0/notifications)
	GetNotificationsV2(ctx echo.Context, params GetNotificationsV2Params) error
	// Update notifications
	// (PATCH /v0/notifications)
	UpdateNotificationsV2(ctx echo.Context) error
	// Gets user's organizations
	// (GET /v0/organizations)
	GetOrganizations(ctx echo.Context) error
	// Creates an organization (v2)
	// (POST /v0/organizations)
	CreateOrganizationWithTier(ctx echo.Context) error
	// Deletes organization
	// (DELETE /v0/organizations/{slug})
	DeleteOrganization(ctx echo.Context, slug string) error
	// Updates organization
	// (PATCH /v0/organizations/{slug})
	UpdateOrganization(ctx echo.Context, slug string) error
	// Gets organization's members
	// (GET /v0/organizations/{slug}/members)
	GetMembers(ctx echo.Context, slug string) error
	// Delete invited user
	// (DELETE /v0/organizations/{slug}/members/invite)
	DeleteInvitedUser(ctx echo.Context, slug string, params DeleteInvitedUserParams) error
	// Gets invited users
	// (GET /v0/organizations/{slug}/members/invite)
	GetInvitedUsers(ctx echo.Context, slug string) error
	// Invites user
	// (POST /v0/organizations/{slug}/members/invite)
	InviteUser(ctx echo.Context, slug string) error
	// Gets invite
	// (GET /v0/organizations/{slug}/members/join)
	GetInvite(ctx echo.Context, slug string, params GetInviteParams) error
	// Joins organization
	// (POST /v0/organizations/{slug}/members/join)
	JoinOrganization(ctx echo.Context, slug string, params JoinOrganizationParams) error
	// Removes organization member
	// (DELETE /v0/organizations/{slug}/members/{gotrue_id})
	DeleteMember(ctx echo.Context, slug string, gotrueId string) error
	// Updates organization member
	// (PATCH /v0/organizations/{slug}/members/{gotrue_id})
	UpdateMember(ctx echo.Context, slug string, gotrueId string) error
	// Gets the given organization's roles
	// (GET /v0/organizations/{slug}/roles)
	AddMember(ctx echo.Context, slug string) error
	// Revoke column privileges
	// (DELETE /v0/pg-meta/{ref}/column-privileges)
	RevokeColumnPrivileges(ctx echo.Context, ref string, params RevokeColumnPrivilegesParams) error
	// Retrieve column privileges
	// (GET /v0/pg-meta/{ref}/column-privileges)
	GetColumnPrivileges(ctx echo.Context, ref string, params GetColumnPrivilegesParams) error
	// Grant column privileges
	// (POST /v0/pg-meta/{ref}/column-privileges)
	GrantColumnPrivileges(ctx echo.Context, ref string, params GrantColumnPrivilegesParams) error
	// Deletes project pg.column with the given ID
	// (DELETE /v0/pg-meta/{ref}/columns)
	DeleteColumn(ctx echo.Context, ref string, params DeleteColumnParams) error
	// Gets project pg.columns
	// (GET /v0/pg-meta/{ref}/columns)
	GetColumns(ctx echo.Context, ref string, params GetColumnsParams) error
	// Updates project pg.column with the given ID
	// (PATCH /v0/pg-meta/{ref}/columns)
	UpdateColumn(ctx echo.Context, ref string, params UpdateColumnParams) error
	// Creates project pg.column
	// (POST /v0/pg-meta/{ref}/columns)
	CreateColumn(ctx echo.Context, ref string, params CreateColumnParams) error
	// Deletes project pg.extension with the given ID
	// (DELETE /v0/pg-meta/{ref}/extensions)
	DeleteExtension(ctx echo.Context, ref string, params DeleteExtensionParams) error
	// Gets project pg.extensions
	// (GET /v0/pg-meta/{ref}/extensions)
	GetExtensions(ctx echo.Context, ref string, params GetExtensionsParams) error
	// Creates project pg.extension
	// (POST /v0/pg-meta/{ref}/extensions)
	CreateExtension(ctx echo.Context, ref string, params CreateExtensionParams) error
	// Retrieve database foreign tables
	// (GET /v0/pg-meta/{ref}/foreign-tables)
	GetForeignTables(ctx echo.Context, ref string, params GetForeignTablesParams) error
	// Deletes project pg.function with the given ID
	// (DELETE /v0/pg-meta/{ref}/functions)
	DeleteFunction(ctx echo.Context, ref string, params DeleteFunctionParams) error
	// Gets project pg.functions
	// (GET /v0/pg-meta/{ref}/functions)
	GetFunctions(ctx echo.Context, ref string, params GetFunctionsParams) error
	// Updates project pg.function with the given ID
	// (PATCH /v0/pg-meta/{ref}/functions)
	UpdateFunction(ctx echo.Context, ref string, params UpdateFunctionParams) error
	// Creates project pg.function
	// (POST /v0/pg-meta/{ref}/functions)
	CreateFunction(ctx echo.Context, ref string, params CreateFunctionParams) error
	// Retrieve database materialized views
	// (GET /v0/pg-meta/{ref}/materialized-views)
	GetMaterializedViews(ctx echo.Context, ref string, params GetMaterializedViewsParams) error
	// Deletes project pg.policy with the given ID
	// (DELETE /v0/pg-meta/{ref}/policies)
	DeletePolicy(ctx echo.Context, ref string, params DeletePolicyParams) error
	// Gets project pg.policies
	// (GET /v0/pg-meta/{ref}/policies)
	GetPolicies(ctx echo.Context, ref string, params GetPoliciesParams) error
	// Updates project pg.policy with the given ID
	// (PATCH /v0/pg-meta/{ref}/policies)
	UpdatePolicy(ctx echo.Context, ref string, params UpdatePolicyParams) error
	// Creates project pg.policy
	// (POST /v0/pg-meta/{ref}/policies)
	CreatePolicy(ctx echo.Context, ref string, params CreatePolicyParams) error
	// Deletes project pg.publication with the given ID
	// (DELETE /v0/pg-meta/{ref}/publications)
	DeletePublication(ctx echo.Context, ref string, params DeletePublicationParams) error
	// Gets project pg.publications
	// (GET /v0/pg-meta/{ref}/publications)
	GetPublications(ctx echo.Context, ref string, params GetPublicationsParams) error
	// Updates project pg.publication with the given ID
	// (PATCH /v0/pg-meta/{ref}/publications)
	UpdatePublication(ctx echo.Context, ref string, params UpdatePublicationParams) error
	// Gets project pg.publications
	// (POST /v0/pg-meta/{ref}/publications)
	CreatePublication(ctx echo.Context, ref string, params CreatePublicationParams) error
	// Run sql query
	// (POST /v0/pg-meta/{ref}/query)
	RunQuery(ctx echo.Context, ref string, params RunQueryParams) error
	// Format sql query
	// (POST /v0/pg-meta/{ref}/query/format)
	FormatQuery(ctx echo.Context, ref string) error
	// Validate sql query
	// (POST /v0/pg-meta/{ref}/query/validate)
	ValidateQuery(ctx echo.Context, ref string) error
	// Deletes project pg.role with the given ID
	// (DELETE /v0/pg-meta/{ref}/roles)
	DeleteRole(ctx echo.Context, ref string, params DeleteRoleParams) error
	// Gets project pg.roles
	// (GET /v0/pg-meta/{ref}/roles)
	GetRoles(ctx echo.Context, ref string, params GetRolesParams) error
	// Updates project pg.role with the given ID
	// (PATCH /v0/pg-meta/{ref}/roles)
	UpdateRole(ctx echo.Context, ref string, params UpdateRoleParams) error
	// Creates project pg.role
	// (POST /v0/pg-meta/{ref}/roles)
	CreateRole(ctx echo.Context, ref string, params CreateRoleParams) error
	// Deletes project pg.schema with the given ID
	// (DELETE /v0/pg-meta/{ref}/schemas)
	DeleteSchema(ctx echo.Context, ref string, params DeleteSchemaParams) error
	// Gets project pg.schemas
	// (GET /v0/pg-meta/{ref}/schemas)
	GetSchemas(ctx echo.Context, ref string, params GetSchemasParams) error
	// Updates project pg.schema with the given ID
	// (PATCH /v0/pg-meta/{ref}/schemas)
	UpdateSchema(ctx echo.Context, ref string, params UpdateSchemaParams) error
	// Creates project pg.schema
	// (POST /v0/pg-meta/{ref}/schemas)
	CreateSchema(ctx echo.Context, ref string, params CreateSchemaParams) error
	// Searches project pg.columns. Return maximum 50 results.
	// (POST /v0/pg-meta/{ref}/search/columns)
	SearchColumns(ctx echo.Context, ref string, params SearchColumnsParams) error
	// Searches project pg.tables. Return maximum 50 results.
	// (POST /v0/pg-meta/{ref}/search/tables)
	SearchTables(ctx echo.Context, ref string, params SearchTablesParams) error
	// Revoke table privileges
	// (DELETE /v0/pg-meta/{ref}/table-privileges)
	RevokeTablePrivileges(ctx echo.Context, ref string, params RevokeTablePrivilegesParams) error
	// Retrieve table privileges
	// (GET /v0/pg-meta/{ref}/table-privileges)
	GetTablePrivileges(ctx echo.Context, ref string, params GetTablePrivilegesParams) error
	// Grant table privileges
	// (POST /v0/pg-meta/{ref}/table-privileges)
	GrantTablePrivileges(ctx echo.Context, ref string, params GrantTablePrivilegesParams) error
	// Deletes project pg.table with the given ID
	// (DELETE /v0/pg-meta/{ref}/tables)
	DeleteTable(ctx echo.Context, ref string, params DeleteTableParams) error
	// Gets project pg.tables or pg.table with the given ID
	// (GET /v0/pg-meta/{ref}/tables)
	GetTables(ctx echo.Context, ref string, params GetTablesParams) error
	// Updates project pg.table with the given ID
	// (PATCH /v0/pg-meta/{ref}/tables)
	UpdateTable(ctx echo.Context, ref string, params UpdateTableParams) error
	// Creates project pg.table
	// (POST /v0/pg-meta/{ref}/tables)
	CreateTable(ctx echo.Context, ref string, params CreateTableParams) error
	// Deletes project pg.trigger with the given ID
	// (DELETE /v0/pg-meta/{ref}/triggers)
	DeleteTrigger(ctx echo.Context, ref string, params DeleteTriggerParams) error
	// Gets project pg.triggers
	// (GET /v0/pg-meta/{ref}/triggers)
	GetTriggers(ctx echo.Context, ref string, params GetTriggersParams) error
	// Updates project pg.trigger with the given ID
	// (PATCH /v0/pg-meta/{ref}/triggers)
	UpdateTrigger(ctx echo.Context, ref string, params UpdateTriggerParams) error
	// Creates project pg.trigger
	// (POST /v0/pg-meta/{ref}/triggers)
	CreateTrigger(ctx echo.Context, ref string, params CreateTriggerParams) error
	// Gets project pg.types
	// (GET /v0/pg-meta/{ref}/types)
	GetTypes(ctx echo.Context, ref string, params GetTypesParams) error
	// Retrieve database views
	// (GET /v0/pg-meta/{ref}/views)
	GetViews(ctx echo.Context, ref string, params GetViewsParams) error
	// Gets all projects that belong to the authenticated user
	// (GET /v0/projects)
	GetProjects(ctx echo.Context, params GetProjectsParams) error
	// Creates a project
	// (POST /v0/projects)
	CreateProject(ctx echo.Context) error
	// Get metrics
	// (GET /v0/projects/metrics)
	GetProjectsMetrics(ctx echo.Context) error
	// Deletes the given project
	// (DELETE /v0/projects/{ref})
	DeleteProject(ctx echo.Context, ref string) error
	// Gets a specific project that belongs to the authenticated user
	// (GET /v0/projects/{ref})
	GetProject(ctx echo.Context, ref string) error
	// Updates the given project
	// (PATCH /v0/projects/{ref})
	UpdateProject(ctx echo.Context, ref string) error
	// Gets a project's function invocation statistics
	// (GET /v0/projects/{ref}/analytics/endpoints/functions.inv-stats)
	GetFunctionStatus(ctx echo.Context, ref string, params GetFunctionStatusParams) error
	// Gets project's logs
	// (GET /v0/projects/{ref}/analytics/endpoints/logs.all)
	GetApiPaths(ctx echo.Context, ref string, params GetApiPathsParams) error
	// Gets project's usage api counts
	// (GET /v0/projects/{ref}/analytics/endpoints/usage.api-counts)
	GetApiCounts(ctx echo.Context, ref string, params GetApiCountsParams) error
	// Queries project Graphql
	// (POST /v0/projects/{ref}/api/graphql)
	ProjectGraphql(ctx echo.Context, ref string, params ProjectGraphqlParams) error
	// Gets project OpenApi
	// (GET /v0/projects/{ref}/api/rest)
	ProjectOpenApi(ctx echo.Context, ref string) error
	// Gets project's pgbouncer config
	// (GET /v0/projects/{ref}/config/pgbouncer)
	GetPgbouncerConfig(ctx echo.Context, ref string) error
	// Updates project's pgbouncer config
	// (PATCH /v0/projects/{ref}/config/pgbouncer)
	UpdatePgbouncerConfig(ctx echo.Context, ref string) error
	// Gets project's Postgres config
	// (GET /v0/projects/{ref}/config/postgres)
	GetConfig(ctx echo.Context, ref string) error
	// Updates project's Postgres config
	// (PUT /v0/projects/{ref}/config/postgres)
	UpdateConfig(ctx echo.Context, ref string) error
	// Gets project's postgrest config
	// (GET /v0/projects/{ref}/config/postgrest)
	GetPostgRESTConfig(ctx echo.Context, ref string) error
	// Updates project's postgrest config
	// (PATCH /v0/projects/{ref}/config/postgrest)
	UpdatePostgRESTConfig(ctx echo.Context, ref string) error
	// Updates project's secrets config
	// (PATCH /v0/projects/{ref}/config/secrets)
	UpdateConfig(ctx echo.Context, ref string) error
	// Gets project's storage config
	// (GET /v0/projects/{ref}/config/storage)
	GetStorageConfig(ctx echo.Context, ref string) error
	// Updates project's storage config
	// (PATCH /v0/projects/{ref}/config/storage)
	UpdateConfig(ctx echo.Context, ref string) error
	// Deletes project's content
	// (DELETE /v0/projects/{ref}/content)
	DeleteContent(ctx echo.Context, ref string, params DeleteContentParams) error
	// Gets project's content
	// (GET /v0/projects/{ref}/content)
	GetProjectContent(ctx echo.Context, ref string) error
	// Updates project's content
	// (PATCH /v0/projects/{ref}/content)
	UpdateContent(ctx echo.Context, ref string) error
	// Creates project's content
	// (POST /v0/projects/{ref}/content)
	CreateContent(ctx echo.Context, ref string) error
	// Updates project's content
	// (PUT /v0/projects/{ref}/content)
	UpdateWholeContent(ctx echo.Context, ref string) error
	// Gets daily project stats
	// (GET /v0/projects/{ref}/daily-stats)
	GetDailyStats(ctx echo.Context, ref string, params GetDailyStatsParams) error
	// Updates the database password
	// (PATCH /v0/projects/{ref}/db-password)
	UpdatePassword(ctx echo.Context, ref string) error
	// Gets project's usage metrics
	// (GET /v0/projects/{ref}/infra-monitoring)
	GetUsageMetrics(ctx echo.Context, ref string, params GetUsageMetricsParams) error
	// Gets project's invoices
	// (GET /v0/projects/{ref}/invoices)
	GetInvoices(ctx echo.Context, ref string, params GetInvoicesParams) error
	// Gets project's invoice count
	// (HEAD /v0/projects/{ref}/invoices)
	GetInvoiceCount(ctx echo.Context, ref string) error
	// Gets project health check
	// (GET /v0/projects/{ref}/live)
	ProjectHealthCheck(ctx echo.Context, ref string) error
	// Pauses the project
	// (POST /v0/projects/{ref}/pause)
	PauseProject(ctx echo.Context, ref string) error
	// Resize database disk
	// (POST /v0/projects/{ref}/resize)
	ResizeDatabase(ctx echo.Context, ref string) error
	// Restarts project
	// (POST /v0/projects/{ref}/restart)
	RestartProject(ctx echo.Context, ref string) error
	// Restarts given services
	// (POST /v0/projects/{ref}/restart-services)
	RestartServices(ctx echo.Context, ref string) error
	// Restores project
	// (POST /v0/projects/{ref}/restore)
	RestoreProject(ctx echo.Context, ref string) error
	// Gets project's settings
	// (GET /v0/projects/{ref}/settings)
	GetProjectApi(ctx echo.Context, ref string) error
	// Gets project's status
	// (GET /v0/projects/{ref}/status)
	GetProjectStatus(ctx echo.Context, ref string) error
	// Gets project's usage
	// (GET /v0/projects/{ref}/usage)
	GetUsageStatusConfig(ctx echo.Context, ref string) error
	// Get infrastructure status
	// (GET /v0/status)
	GetStatus(ctx echo.Context) error
	// Gets list of buckets
	// (GET /v0/storage/{ref}/buckets)
	GetBuckets(ctx echo.Context, ref string) error
	// Create bucket
	// (POST /v0/storage/{ref}/buckets)
	CreateBucket(ctx echo.Context, ref string) error
	// Deletes bucket
	// (DELETE /v0/storage/{ref}/buckets/{id})
	DeleteBucket(ctx echo.Context, ref string, id string) error
	// Gets bucket
	// (GET /v0/storage/{ref}/buckets/{id})
	GetBucket(ctx echo.Context, ref string, id string) error
	// Updates bucket
	// (PATCH /v0/storage/{ref}/buckets/{id})
	UpdateBucket(ctx echo.Context, ref string, id string) error
	// Removes all objects inside a single bucket.
	// (POST /v0/storage/{ref}/buckets/{id}/empty)
	EmptyBucket(ctx echo.Context, ref string, id string) error
	// Deletes objects
	// (DELETE /v0/storage/{ref}/buckets/{id}/objects)
	DeleteObjects(ctx echo.Context, ref string, id string) error
	// Copys object
	// (POST /v0/storage/{ref}/buckets/{id}/objects/copy)
	CopyObject(ctx echo.Context, ref string, id string) error
	// Downloads a file from a private bucket
	// (POST /v0/storage/{ref}/buckets/{id}/objects/download)
	Download(ctx echo.Context, ref string, id string) error
	// Gets list of objects with the given bucket
	// (POST /v0/storage/{ref}/buckets/{id}/objects/list)
	GetObjects(ctx echo.Context, ref string, id string) error
	// Move object
	// (POST /v0/storage/{ref}/buckets/{id}/objects/move)
	MoveObject(ctx echo.Context, ref string, id string) error
	// Creates URL for an asset in a public bucket
	// (POST /v0/storage/{ref}/buckets/{id}/objects/public-url)
	CreatePublicUrl(ctx echo.Context, ref string, id string) error
	// Creates a signed URL
	// (POST /v0/storage/{ref}/buckets/{id}/objects/sign)
	CreateSignedUrl(ctx echo.Context, ref string, id string) error
	// Gets multiple signed URLs
	// (POST /v0/storage/{ref}/buckets/{id}/objects/sign-multi)
	CreateSignedUrls(ctx echo.Context, ref string, id string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetGoTrueConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetGoTrueConfig(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGoTrueConfig(ctx, ref)
	return err
}

// UpdateGoTrueConfig converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateGoTrueConfig(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateGoTrueConfig(ctx, ref)
	return err
}

// SendInvite converts echo context to params.
func (w *ServerInterfaceWrapper) SendInvite(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SendInvite(ctx, ref)
	return err
}

// SendMagicLink converts echo context to params.
func (w *ServerInterfaceWrapper) SendMagicLink(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SendMagicLink(ctx, ref)
	return err
}

// SendOtp converts echo context to params.
func (w *ServerInterfaceWrapper) SendOtp(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SendOtp(ctx, ref)
	return err
}

// SendRecover converts echo context to params.
func (w *ServerInterfaceWrapper) SendRecover(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SendRecover(ctx, ref)
	return err
}

// GetTemplate converts echo context to params.
func (w *ServerInterfaceWrapper) GetTemplate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	// ------------- Path parameter "template" -------------
	var template GetTemplateParamsTemplate

	err = runtime.BindStyledParameterWithLocation("simple", false, "template", runtime.ParamLocationPath, ctx.Param("template"), &template)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter template: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTemplate(ctx, ref, template)
	return err
}

// DeleteUser converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteUser(ctx, ref)
	return err
}

// GetUsers converts echo context to params.
func (w *ServerInterfaceWrapper) GetUsers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUsersParams
	// ------------- Required query parameter "keywords" -------------

	err = runtime.BindQueryParameter("form", true, true, "keywords", ctx.QueryParams(), &params.Keywords)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter keywords: %s", err))
	}

	// ------------- Required query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, true, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, true, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Required query parameter "verified" -------------

	err = runtime.BindQueryParameter("form", true, true, "verified", ctx.QueryParams(), &params.Verified)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter verified: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUsers(ctx, ref, params)
	return err
}

// DeleteFactors converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteFactors(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteFactors(ctx, ref, id)
	return err
}

// GetBackups converts echo context to params.
func (w *ServerInterfaceWrapper) GetBackups(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBackups(ctx, ref)
	return err
}

// DownloadBackup converts echo context to params.
func (w *ServerInterfaceWrapper) DownloadBackup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DownloadBackup(ctx, ref)
	return err
}

// RestorePointInTimeBackup converts echo context to params.
func (w *ServerInterfaceWrapper) RestorePointInTimeBackup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RestorePointInTimeBackup(ctx, ref)
	return err
}

// RestoreBackup converts echo context to params.
func (w *ServerInterfaceWrapper) RestoreBackup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RestoreBackup(ctx, ref)
	return err
}

// RestorePhysicalBackup converts echo context to params.
func (w *ServerInterfaceWrapper) RestorePhysicalBackup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RestorePhysicalBackup(ctx, ref)
	return err
}

// EnableHooks converts echo context to params.
func (w *ServerInterfaceWrapper) EnableHooks(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.EnableHooks(ctx, ref)
	return err
}

// GetHookLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetHookLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetHookLogsParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetHookLogs(ctx, ref, params)
	return err
}

// DeleteNotifications converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteNotifications(ctx echo.Context) error {
	var err error

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteNotifications(ctx)
	return err
}

// GetNotificationsV2 converts echo context to params.
func (w *ServerInterfaceWrapper) GetNotificationsV2(ctx echo.Context) error {
	var err error

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetNotificationsV2Params
	// ------------- Optional query parameter "archived" -------------

	err = runtime.BindQueryParameter("form", true, false, "archived", ctx.QueryParams(), &params.Archived)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter archived: %s", err))
	}

	// ------------- Required query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, true, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Required query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, true, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNotificationsV2(ctx, params)
	return err
}

// UpdateNotificationsV2 converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateNotificationsV2(ctx echo.Context) error {
	var err error

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateNotificationsV2(ctx)
	return err
}

// GetOrganizations converts echo context to params.
func (w *ServerInterfaceWrapper) GetOrganizations(ctx echo.Context) error {
	var err error

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOrganizations(ctx)
	return err
}

// CreateOrganizationWithTier converts echo context to params.
func (w *ServerInterfaceWrapper) CreateOrganizationWithTier(ctx echo.Context) error {
	var err error

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateOrganizationWithTier(ctx)
	return err
}

// DeleteOrganization converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteOrganization(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "slug" -------------
	var slug string

	err = runtime.BindStyledParameterWithLocation("simple", false, "slug", runtime.ParamLocationPath, ctx.Param("slug"), &slug)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter slug: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteOrganization(ctx, slug)
	return err
}

// UpdateOrganization converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateOrganization(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "slug" -------------
	var slug string

	err = runtime.BindStyledParameterWithLocation("simple", false, "slug", runtime.ParamLocationPath, ctx.Param("slug"), &slug)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter slug: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateOrganization(ctx, slug)
	return err
}

// GetMembers converts echo context to params.
func (w *ServerInterfaceWrapper) GetMembers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "slug" -------------
	var slug string

	err = runtime.BindStyledParameterWithLocation("simple", false, "slug", runtime.ParamLocationPath, ctx.Param("slug"), &slug)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter slug: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMembers(ctx, slug)
	return err
}

// DeleteInvitedUser converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteInvitedUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "slug" -------------
	var slug string

	err = runtime.BindStyledParameterWithLocation("simple", false, "slug", runtime.ParamLocationPath, ctx.Param("slug"), &slug)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter slug: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteInvitedUserParams
	// ------------- Required query parameter "invited_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "invited_id", ctx.QueryParams(), &params.InvitedId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter invited_id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteInvitedUser(ctx, slug, params)
	return err
}

// GetInvitedUsers converts echo context to params.
func (w *ServerInterfaceWrapper) GetInvitedUsers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "slug" -------------
	var slug string

	err = runtime.BindStyledParameterWithLocation("simple", false, "slug", runtime.ParamLocationPath, ctx.Param("slug"), &slug)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter slug: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetInvitedUsers(ctx, slug)
	return err
}

// InviteUser converts echo context to params.
func (w *ServerInterfaceWrapper) InviteUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "slug" -------------
	var slug string

	err = runtime.BindStyledParameterWithLocation("simple", false, "slug", runtime.ParamLocationPath, ctx.Param("slug"), &slug)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter slug: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InviteUser(ctx, slug)
	return err
}

// GetInvite converts echo context to params.
func (w *ServerInterfaceWrapper) GetInvite(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "slug" -------------
	var slug string

	err = runtime.BindStyledParameterWithLocation("simple", false, "slug", runtime.ParamLocationPath, ctx.Param("slug"), &slug)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter slug: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInviteParams
	// ------------- Required query parameter "token" -------------

	err = runtime.BindQueryParameter("form", true, true, "token", ctx.QueryParams(), &params.Token)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetInvite(ctx, slug, params)
	return err
}

// JoinOrganization converts echo context to params.
func (w *ServerInterfaceWrapper) JoinOrganization(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "slug" -------------
	var slug string

	err = runtime.BindStyledParameterWithLocation("simple", false, "slug", runtime.ParamLocationPath, ctx.Param("slug"), &slug)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter slug: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params JoinOrganizationParams
	// ------------- Required query parameter "token" -------------

	err = runtime.BindQueryParameter("form", true, true, "token", ctx.QueryParams(), &params.Token)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.JoinOrganization(ctx, slug, params)
	return err
}

// DeleteMember converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteMember(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "slug" -------------
	var slug string

	err = runtime.BindStyledParameterWithLocation("simple", false, "slug", runtime.ParamLocationPath, ctx.Param("slug"), &slug)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter slug: %s", err))
	}

	// ------------- Path parameter "gotrue_id" -------------
	var gotrueId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "gotrue_id", runtime.ParamLocationPath, ctx.Param("gotrue_id"), &gotrueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gotrue_id: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteMember(ctx, slug, gotrueId)
	return err
}

// UpdateMember converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateMember(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "slug" -------------
	var slug string

	err = runtime.BindStyledParameterWithLocation("simple", false, "slug", runtime.ParamLocationPath, ctx.Param("slug"), &slug)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter slug: %s", err))
	}

	// ------------- Path parameter "gotrue_id" -------------
	var gotrueId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "gotrue_id", runtime.ParamLocationPath, ctx.Param("gotrue_id"), &gotrueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter gotrue_id: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateMember(ctx, slug, gotrueId)
	return err
}

// AddMember converts echo context to params.
func (w *ServerInterfaceWrapper) AddMember(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "slug" -------------
	var slug string

	err = runtime.BindStyledParameterWithLocation("simple", false, "slug", runtime.ParamLocationPath, ctx.Param("slug"), &slug)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter slug: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AddMember(ctx, slug)
	return err
}

// RevokeColumnPrivileges converts echo context to params.
func (w *ServerInterfaceWrapper) RevokeColumnPrivileges(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params RevokeColumnPrivilegesParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RevokeColumnPrivileges(ctx, ref, params)
	return err
}

// GetColumnPrivileges converts echo context to params.
func (w *ServerInterfaceWrapper) GetColumnPrivileges(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetColumnPrivilegesParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetColumnPrivileges(ctx, ref, params)
	return err
}

// GrantColumnPrivileges converts echo context to params.
func (w *ServerInterfaceWrapper) GrantColumnPrivileges(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GrantColumnPrivilegesParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GrantColumnPrivileges(ctx, ref, params)
	return err
}

// DeleteColumn converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteColumn(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteColumnParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "cascade" -------------

	err = runtime.BindQueryParameter("form", true, false, "cascade", ctx.QueryParams(), &params.Cascade)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cascade: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteColumn(ctx, ref, params)
	return err
}

// GetColumns converts echo context to params.
func (w *ServerInterfaceWrapper) GetColumns(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetColumnsParams
	// ------------- Required query parameter "included_schemas" -------------

	err = runtime.BindQueryParameter("form", true, true, "included_schemas", ctx.QueryParams(), &params.IncludedSchemas)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter included_schemas: %s", err))
	}

	// ------------- Required query parameter "excluded_schemas" -------------

	err = runtime.BindQueryParameter("form", true, true, "excluded_schemas", ctx.QueryParams(), &params.ExcludedSchemas)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter excluded_schemas: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetColumns(ctx, ref, params)
	return err
}

// UpdateColumn converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateColumn(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateColumnParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateColumn(ctx, ref, params)
	return err
}

// CreateColumn converts echo context to params.
func (w *ServerInterfaceWrapper) CreateColumn(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateColumnParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateColumn(ctx, ref, params)
	return err
}

// DeleteExtension converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteExtension(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteExtensionParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteExtension(ctx, ref, params)
	return err
}

// GetExtensions converts echo context to params.
func (w *ServerInterfaceWrapper) GetExtensions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetExtensionsParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetExtensions(ctx, ref, params)
	return err
}

// CreateExtension converts echo context to params.
func (w *ServerInterfaceWrapper) CreateExtension(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateExtensionParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateExtension(ctx, ref, params)
	return err
}

// GetForeignTables converts echo context to params.
func (w *ServerInterfaceWrapper) GetForeignTables(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetForeignTablesParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Required query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, true, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, true, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Required query parameter "include_columns" -------------

	err = runtime.BindQueryParameter("form", true, true, "include_columns", ctx.QueryParams(), &params.IncludeColumns)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include_columns: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetForeignTables(ctx, ref, params)
	return err
}

// DeleteFunction converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteFunction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteFunctionParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteFunction(ctx, ref, params)
	return err
}

// GetFunctions converts echo context to params.
func (w *ServerInterfaceWrapper) GetFunctions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFunctionsParams
	// ------------- Required query parameter "included_schemas" -------------

	err = runtime.BindQueryParameter("form", true, true, "included_schemas", ctx.QueryParams(), &params.IncludedSchemas)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter included_schemas: %s", err))
	}

	// ------------- Required query parameter "excluded_schemas" -------------

	err = runtime.BindQueryParameter("form", true, true, "excluded_schemas", ctx.QueryParams(), &params.ExcludedSchemas)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter excluded_schemas: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFunctions(ctx, ref, params)
	return err
}

// UpdateFunction converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateFunction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateFunctionParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateFunction(ctx, ref, params)
	return err
}

// CreateFunction converts echo context to params.
func (w *ServerInterfaceWrapper) CreateFunction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateFunctionParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateFunction(ctx, ref, params)
	return err
}

// GetMaterializedViews converts echo context to params.
func (w *ServerInterfaceWrapper) GetMaterializedViews(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetMaterializedViewsParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Required query parameter "included_schemas" -------------

	err = runtime.BindQueryParameter("form", true, true, "included_schemas", ctx.QueryParams(), &params.IncludedSchemas)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter included_schemas: %s", err))
	}

	// ------------- Required query parameter "excluded_schemas" -------------

	err = runtime.BindQueryParameter("form", true, true, "excluded_schemas", ctx.QueryParams(), &params.ExcludedSchemas)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter excluded_schemas: %s", err))
	}

	// ------------- Required query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, true, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, true, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Required query parameter "include_columns" -------------

	err = runtime.BindQueryParameter("form", true, true, "include_columns", ctx.QueryParams(), &params.IncludeColumns)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include_columns: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMaterializedViews(ctx, ref, params)
	return err
}

// DeletePolicy converts echo context to params.
func (w *ServerInterfaceWrapper) DeletePolicy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeletePolicyParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeletePolicy(ctx, ref, params)
	return err
}

// GetPolicies converts echo context to params.
func (w *ServerInterfaceWrapper) GetPolicies(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPoliciesParams
	// ------------- Required query parameter "included_schemas" -------------

	err = runtime.BindQueryParameter("form", true, true, "included_schemas", ctx.QueryParams(), &params.IncludedSchemas)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter included_schemas: %s", err))
	}

	// ------------- Required query parameter "excluded_schemas" -------------

	err = runtime.BindQueryParameter("form", true, true, "excluded_schemas", ctx.QueryParams(), &params.ExcludedSchemas)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter excluded_schemas: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPolicies(ctx, ref, params)
	return err
}

// UpdatePolicy converts echo context to params.
func (w *ServerInterfaceWrapper) UpdatePolicy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdatePolicyParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdatePolicy(ctx, ref, params)
	return err
}

// CreatePolicy converts echo context to params.
func (w *ServerInterfaceWrapper) CreatePolicy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreatePolicyParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreatePolicy(ctx, ref, params)
	return err
}

// DeletePublication converts echo context to params.
func (w *ServerInterfaceWrapper) DeletePublication(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeletePublicationParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeletePublication(ctx, ref, params)
	return err
}

// GetPublications converts echo context to params.
func (w *ServerInterfaceWrapper) GetPublications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPublicationsParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPublications(ctx, ref, params)
	return err
}

// UpdatePublication converts echo context to params.
func (w *ServerInterfaceWrapper) UpdatePublication(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdatePublicationParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdatePublication(ctx, ref, params)
	return err
}

// CreatePublication converts echo context to params.
func (w *ServerInterfaceWrapper) CreatePublication(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreatePublicationParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreatePublication(ctx, ref, params)
	return err
}

// RunQuery converts echo context to params.
func (w *ServerInterfaceWrapper) RunQuery(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params RunQueryParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RunQuery(ctx, ref, params)
	return err
}

// FormatQuery converts echo context to params.
func (w *ServerInterfaceWrapper) FormatQuery(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.FormatQuery(ctx, ref)
	return err
}

// ValidateQuery converts echo context to params.
func (w *ServerInterfaceWrapper) ValidateQuery(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ValidateQuery(ctx, ref)
	return err
}

// DeleteRole converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteRoleParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteRole(ctx, ref, params)
	return err
}

// GetRoles converts echo context to params.
func (w *ServerInterfaceWrapper) GetRoles(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRolesParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRoles(ctx, ref, params)
	return err
}

// UpdateRole converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateRoleParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateRole(ctx, ref, params)
	return err
}

// CreateRole converts echo context to params.
func (w *ServerInterfaceWrapper) CreateRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateRoleParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateRole(ctx, ref, params)
	return err
}

// DeleteSchema converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSchema(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteSchemaParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSchema(ctx, ref, params)
	return err
}

// GetSchemas converts echo context to params.
func (w *ServerInterfaceWrapper) GetSchemas(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSchemasParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSchemas(ctx, ref, params)
	return err
}

// UpdateSchema converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateSchema(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateSchemaParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateSchema(ctx, ref, params)
	return err
}

// CreateSchema converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSchema(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateSchemaParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateSchema(ctx, ref, params)
	return err
}

// SearchColumns converts echo context to params.
func (w *ServerInterfaceWrapper) SearchColumns(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchColumnsParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SearchColumns(ctx, ref, params)
	return err
}

// SearchTables converts echo context to params.
func (w *ServerInterfaceWrapper) SearchTables(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchTablesParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SearchTables(ctx, ref, params)
	return err
}

// RevokeTablePrivileges converts echo context to params.
func (w *ServerInterfaceWrapper) RevokeTablePrivileges(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params RevokeTablePrivilegesParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RevokeTablePrivileges(ctx, ref, params)
	return err
}

// GetTablePrivileges converts echo context to params.
func (w *ServerInterfaceWrapper) GetTablePrivileges(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTablePrivilegesParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTablePrivileges(ctx, ref, params)
	return err
}

// GrantTablePrivileges converts echo context to params.
func (w *ServerInterfaceWrapper) GrantTablePrivileges(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GrantTablePrivilegesParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GrantTablePrivileges(ctx, ref, params)
	return err
}

// DeleteTable converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteTable(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteTableParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Required query parameter "cascade" -------------

	err = runtime.BindQueryParameter("form", true, true, "cascade", ctx.QueryParams(), &params.Cascade)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cascade: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteTable(ctx, ref, params)
	return err
}

// GetTables converts echo context to params.
func (w *ServerInterfaceWrapper) GetTables(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTablesParams
	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Required query parameter "include_system_schemas" -------------

	err = runtime.BindQueryParameter("form", true, true, "include_system_schemas", ctx.QueryParams(), &params.IncludeSystemSchemas)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include_system_schemas: %s", err))
	}

	// ------------- Required query parameter "included_schemas" -------------

	err = runtime.BindQueryParameter("form", true, true, "included_schemas", ctx.QueryParams(), &params.IncludedSchemas)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter included_schemas: %s", err))
	}

	// ------------- Required query parameter "excluded_schemas" -------------

	err = runtime.BindQueryParameter("form", true, true, "excluded_schemas", ctx.QueryParams(), &params.ExcludedSchemas)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter excluded_schemas: %s", err))
	}

	// ------------- Required query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, true, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, true, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Required query parameter "include_columns" -------------

	err = runtime.BindQueryParameter("form", true, true, "include_columns", ctx.QueryParams(), &params.IncludeColumns)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include_columns: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTables(ctx, ref, params)
	return err
}

// UpdateTable converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateTable(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateTableParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateTable(ctx, ref, params)
	return err
}

// CreateTable converts echo context to params.
func (w *ServerInterfaceWrapper) CreateTable(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateTableParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateTable(ctx, ref, params)
	return err
}

// DeleteTrigger converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteTrigger(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteTriggerParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteTrigger(ctx, ref, params)
	return err
}

// GetTriggers converts echo context to params.
func (w *ServerInterfaceWrapper) GetTriggers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTriggersParams
	// ------------- Required query parameter "included_schemas" -------------

	err = runtime.BindQueryParameter("form", true, true, "included_schemas", ctx.QueryParams(), &params.IncludedSchemas)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter included_schemas: %s", err))
	}

	// ------------- Required query parameter "excluded_schemas" -------------

	err = runtime.BindQueryParameter("form", true, true, "excluded_schemas", ctx.QueryParams(), &params.ExcludedSchemas)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter excluded_schemas: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTriggers(ctx, ref, params)
	return err
}

// UpdateTrigger converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateTrigger(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateTriggerParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateTrigger(ctx, ref, params)
	return err
}

// CreateTrigger converts echo context to params.
func (w *ServerInterfaceWrapper) CreateTrigger(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateTriggerParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateTrigger(ctx, ref, params)
	return err
}

// GetTypes converts echo context to params.
func (w *ServerInterfaceWrapper) GetTypes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTypesParams
	// ------------- Required query parameter "included_schemas" -------------

	err = runtime.BindQueryParameter("form", true, true, "included_schemas", ctx.QueryParams(), &params.IncludedSchemas)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter included_schemas: %s", err))
	}

	// ------------- Required query parameter "excluded_schemas" -------------

	err = runtime.BindQueryParameter("form", true, true, "excluded_schemas", ctx.QueryParams(), &params.ExcludedSchemas)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter excluded_schemas: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTypes(ctx, ref, params)
	return err
}

// GetViews converts echo context to params.
func (w *ServerInterfaceWrapper) GetViews(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetViewsParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Required query parameter "include_system_schemas" -------------

	err = runtime.BindQueryParameter("form", true, true, "include_system_schemas", ctx.QueryParams(), &params.IncludeSystemSchemas)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include_system_schemas: %s", err))
	}

	// ------------- Required query parameter "included_schemas" -------------

	err = runtime.BindQueryParameter("form", true, true, "included_schemas", ctx.QueryParams(), &params.IncludedSchemas)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter included_schemas: %s", err))
	}

	// ------------- Required query parameter "excluded_schemas" -------------

	err = runtime.BindQueryParameter("form", true, true, "excluded_schemas", ctx.QueryParams(), &params.ExcludedSchemas)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter excluded_schemas: %s", err))
	}

	// ------------- Required query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, true, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, true, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Required query parameter "include_columns" -------------

	err = runtime.BindQueryParameter("form", true, true, "include_columns", ctx.QueryParams(), &params.IncludeColumns)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include_columns: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-connection-encrypted" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-connection-encrypted")]; found {
		var XConnectionEncrypted string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-connection-encrypted, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-connection-encrypted", runtime.ParamLocationHeader, valueList[0], &XConnectionEncrypted)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-connection-encrypted: %s", err))
		}

		params.XConnectionEncrypted = XConnectionEncrypted
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-connection-encrypted is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetViews(ctx, ref, params)
	return err
}

// GetProjects converts echo context to params.
func (w *ServerInterfaceWrapper) GetProjects(ctx echo.Context) error {
	var err error

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProjectsParams
	// ------------- Required query parameter "include_readonly_mode_status" -------------

	err = runtime.BindQueryParameter("form", true, true, "include_readonly_mode_status", ctx.QueryParams(), &params.IncludeReadonlyModeStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include_readonly_mode_status: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProjects(ctx, params)
	return err
}

// CreateProject converts echo context to params.
func (w *ServerInterfaceWrapper) CreateProject(ctx echo.Context) error {
	var err error

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateProject(ctx)
	return err
}

// GetProjectsMetrics converts echo context to params.
func (w *ServerInterfaceWrapper) GetProjectsMetrics(ctx echo.Context) error {
	var err error

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProjectsMetrics(ctx)
	return err
}

// DeleteProject converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteProject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteProject(ctx, ref)
	return err
}

// GetProject converts echo context to params.
func (w *ServerInterfaceWrapper) GetProject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProject(ctx, ref)
	return err
}

// UpdateProject converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateProject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateProject(ctx, ref)
	return err
}

// GetFunctionStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetFunctionStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFunctionStatusParams
	// ------------- Required query parameter "interval" -------------

	err = runtime.BindQueryParameter("form", true, true, "interval", ctx.QueryParams(), &params.Interval)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter interval: %s", err))
	}

	// ------------- Required query parameter "function_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "function_id", ctx.QueryParams(), &params.FunctionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter function_id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFunctionStatus(ctx, ref, params)
	return err
}

// GetApiPaths converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiPaths(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApiPathsParams
	// ------------- Required query parameter "sql" -------------

	err = runtime.BindQueryParameter("form", true, true, "sql", ctx.QueryParams(), &params.Sql)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sql: %s", err))
	}

	// ------------- Required query parameter "project" -------------

	err = runtime.BindQueryParameter("form", true, true, "project", ctx.QueryParams(), &params.Project)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project: %s", err))
	}

	// ------------- Required query parameter "iso_timestamp_start" -------------

	err = runtime.BindQueryParameter("form", true, true, "iso_timestamp_start", ctx.QueryParams(), &params.IsoTimestampStart)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter iso_timestamp_start: %s", err))
	}

	// ------------- Required query parameter "iso_timestamp_end" -------------

	err = runtime.BindQueryParameter("form", true, true, "iso_timestamp_end", ctx.QueryParams(), &params.IsoTimestampEnd)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter iso_timestamp_end: %s", err))
	}

	// ------------- Required query parameter "timestamp_start" -------------

	err = runtime.BindQueryParameter("form", true, true, "timestamp_start", ctx.QueryParams(), &params.TimestampStart)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timestamp_start: %s", err))
	}

	// ------------- Required query parameter "timestamp_end" -------------

	err = runtime.BindQueryParameter("form", true, true, "timestamp_end", ctx.QueryParams(), &params.TimestampEnd)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timestamp_end: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApiPaths(ctx, ref, params)
	return err
}

// GetApiCounts converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiCounts(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApiCountsParams
	// ------------- Required query parameter "interval" -------------

	err = runtime.BindQueryParameter("form", true, true, "interval", ctx.QueryParams(), &params.Interval)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter interval: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApiCounts(ctx, ref, params)
	return err
}

// ProjectGraphql converts echo context to params.
func (w *ServerInterfaceWrapper) ProjectGraphql(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ProjectGraphqlParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-graphql-authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-graphql-authorization")]; found {
		var XGraphqlAuthorization string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-graphql-authorization, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-graphql-authorization", runtime.ParamLocationHeader, valueList[0], &XGraphqlAuthorization)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-graphql-authorization: %s", err))
		}

		params.XGraphqlAuthorization = XGraphqlAuthorization
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-graphql-authorization is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ProjectGraphql(ctx, ref, params)
	return err
}

// ProjectOpenApi converts echo context to params.
func (w *ServerInterfaceWrapper) ProjectOpenApi(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ProjectOpenApi(ctx, ref)
	return err
}

// GetPgbouncerConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetPgbouncerConfig(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPgbouncerConfig(ctx, ref)
	return err
}

// UpdatePgbouncerConfig converts echo context to params.
func (w *ServerInterfaceWrapper) UpdatePgbouncerConfig(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdatePgbouncerConfig(ctx, ref)
	return err
}

// GetConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetConfig(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetConfig(ctx, ref)
	return err
}

// UpdateConfig converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateConfig(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateConfig(ctx, ref)
	return err
}

// GetPostgRESTConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetPostgRESTConfig(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPostgRESTConfig(ctx, ref)
	return err
}

// UpdatePostgRESTConfig converts echo context to params.
func (w *ServerInterfaceWrapper) UpdatePostgRESTConfig(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdatePostgRESTConfig(ctx, ref)
	return err
}

// UpdateConfig converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateConfig(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateConfig(ctx, ref)
	return err
}

// GetStorageConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetStorageConfig(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStorageConfig(ctx, ref)
	return err
}

// UpdateConfig converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateConfig(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateConfig(ctx, ref)
	return err
}

// DeleteContent converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteContent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteContentParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteContent(ctx, ref, params)
	return err
}

// GetProjectContent converts echo context to params.
func (w *ServerInterfaceWrapper) GetProjectContent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProjectContent(ctx, ref)
	return err
}

// UpdateContent converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateContent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateContent(ctx, ref)
	return err
}

// CreateContent converts echo context to params.
func (w *ServerInterfaceWrapper) CreateContent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateContent(ctx, ref)
	return err
}

// UpdateWholeContent converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateWholeContent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateWholeContent(ctx, ref)
	return err
}

// GetDailyStats converts echo context to params.
func (w *ServerInterfaceWrapper) GetDailyStats(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDailyStatsParams
	// ------------- Required query parameter "attribute" -------------

	err = runtime.BindQueryParameter("form", true, true, "attribute", ctx.QueryParams(), &params.Attribute)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter attribute: %s", err))
	}

	// ------------- Required query parameter "interval" -------------

	err = runtime.BindQueryParameter("form", true, true, "interval", ctx.QueryParams(), &params.Interval)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter interval: %s", err))
	}

	// ------------- Required query parameter "endDate" -------------

	err = runtime.BindQueryParameter("form", true, true, "endDate", ctx.QueryParams(), &params.EndDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endDate: %s", err))
	}

	// ------------- Required query parameter "startDate" -------------

	err = runtime.BindQueryParameter("form", true, true, "startDate", ctx.QueryParams(), &params.StartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startDate: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDailyStats(ctx, ref, params)
	return err
}

// UpdatePassword converts echo context to params.
func (w *ServerInterfaceWrapper) UpdatePassword(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdatePassword(ctx, ref)
	return err
}

// GetUsageMetrics converts echo context to params.
func (w *ServerInterfaceWrapper) GetUsageMetrics(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUsageMetricsParams
	// ------------- Required query parameter "attribute" -------------

	err = runtime.BindQueryParameter("form", true, true, "attribute", ctx.QueryParams(), &params.Attribute)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter attribute: %s", err))
	}

	// ------------- Required query parameter "startDate" -------------

	err = runtime.BindQueryParameter("form", true, true, "startDate", ctx.QueryParams(), &params.StartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startDate: %s", err))
	}

	// ------------- Required query parameter "endDate" -------------

	err = runtime.BindQueryParameter("form", true, true, "endDate", ctx.QueryParams(), &params.EndDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endDate: %s", err))
	}

	// ------------- Optional query parameter "interval" -------------

	err = runtime.BindQueryParameter("form", true, false, "interval", ctx.QueryParams(), &params.Interval)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter interval: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUsageMetrics(ctx, ref, params)
	return err
}

// GetInvoices converts echo context to params.
func (w *ServerInterfaceWrapper) GetInvoices(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInvoicesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetInvoices(ctx, ref, params)
	return err
}

// GetInvoiceCount converts echo context to params.
func (w *ServerInterfaceWrapper) GetInvoiceCount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetInvoiceCount(ctx, ref)
	return err
}

// ProjectHealthCheck converts echo context to params.
func (w *ServerInterfaceWrapper) ProjectHealthCheck(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ProjectHealthCheck(ctx, ref)
	return err
}

// PauseProject converts echo context to params.
func (w *ServerInterfaceWrapper) PauseProject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PauseProject(ctx, ref)
	return err
}

// ResizeDatabase converts echo context to params.
func (w *ServerInterfaceWrapper) ResizeDatabase(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ResizeDatabase(ctx, ref)
	return err
}

// RestartProject converts echo context to params.
func (w *ServerInterfaceWrapper) RestartProject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RestartProject(ctx, ref)
	return err
}

// RestartServices converts echo context to params.
func (w *ServerInterfaceWrapper) RestartServices(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RestartServices(ctx, ref)
	return err
}

// RestoreProject converts echo context to params.
func (w *ServerInterfaceWrapper) RestoreProject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RestoreProject(ctx, ref)
	return err
}

// GetProjectApi converts echo context to params.
func (w *ServerInterfaceWrapper) GetProjectApi(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProjectApi(ctx, ref)
	return err
}

// GetProjectStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetProjectStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProjectStatus(ctx, ref)
	return err
}

// GetUsageStatusConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetUsageStatusConfig(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUsageStatusConfig(ctx, ref)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// GetBuckets converts echo context to params.
func (w *ServerInterfaceWrapper) GetBuckets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBuckets(ctx, ref)
	return err
}

// CreateBucket converts echo context to params.
func (w *ServerInterfaceWrapper) CreateBucket(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateBucket(ctx, ref)
	return err
}

// DeleteBucket converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteBucket(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteBucket(ctx, ref, id)
	return err
}

// GetBucket converts echo context to params.
func (w *ServerInterfaceWrapper) GetBucket(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBucket(ctx, ref, id)
	return err
}

// UpdateBucket converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateBucket(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateBucket(ctx, ref, id)
	return err
}

// EmptyBucket converts echo context to params.
func (w *ServerInterfaceWrapper) EmptyBucket(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.EmptyBucket(ctx, ref, id)
	return err
}

// DeleteObjects converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteObjects(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteObjects(ctx, ref, id)
	return err
}

// CopyObject converts echo context to params.
func (w *ServerInterfaceWrapper) CopyObject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CopyObject(ctx, ref, id)
	return err
}

// Download converts echo context to params.
func (w *ServerInterfaceWrapper) Download(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Download(ctx, ref, id)
	return err
}

// GetObjects converts echo context to params.
func (w *ServerInterfaceWrapper) GetObjects(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetObjects(ctx, ref, id)
	return err
}

// MoveObject converts echo context to params.
func (w *ServerInterfaceWrapper) MoveObject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MoveObject(ctx, ref, id)
	return err
}

// CreatePublicUrl converts echo context to params.
func (w *ServerInterfaceWrapper) CreatePublicUrl(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreatePublicUrl(ctx, ref, id)
	return err
}

// CreateSignedUrl converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSignedUrl(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateSignedUrl(ctx, ref, id)
	return err
}

// CreateSignedUrls converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSignedUrls(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ref", runtime.ParamLocationPath, ctx.Param("ref"), &ref)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ref: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateSignedUrls(ctx, ref, id)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v0/auth/:ref/config", wrapper.GetGoTrueConfig)
	router.PATCH(baseURL+"/v0/auth/:ref/config", wrapper.UpdateGoTrueConfig)
	router.POST(baseURL+"/v0/auth/:ref/invite", wrapper.SendInvite)
	router.POST(baseURL+"/v0/auth/:ref/magiclink", wrapper.SendMagicLink)
	router.POST(baseURL+"/v0/auth/:ref/otp", wrapper.SendOtp)
	router.POST(baseURL+"/v0/auth/:ref/recover", wrapper.SendRecover)
	router.GET(baseURL+"/v0/auth/:ref/templates/:template", wrapper.GetTemplate)
	router.DELETE(baseURL+"/v0/auth/:ref/users", wrapper.DeleteUser)
	router.GET(baseURL+"/v0/auth/:ref/users", wrapper.GetUsers)
	router.DELETE(baseURL+"/v0/auth/:ref/users/:id/factors", wrapper.DeleteFactors)
	router.GET(baseURL+"/v0/database/:ref/backups", wrapper.GetBackups)
	router.POST(baseURL+"/v0/database/:ref/backups/download", wrapper.DownloadBackup)
	router.POST(baseURL+"/v0/database/:ref/backups/pitr", wrapper.RestorePointInTimeBackup)
	router.POST(baseURL+"/v0/database/:ref/backups/restore", wrapper.RestoreBackup)
	router.POST(baseURL+"/v0/database/:ref/backups/restore-physical", wrapper.RestorePhysicalBackup)
	router.POST(baseURL+"/v0/database/:ref/hook-enable", wrapper.EnableHooks)
	router.GET(baseURL+"/v0/database/:ref/hook-logs", wrapper.GetHookLogs)
	router.DELETE(baseURL+"/v0/notifications", wrapper.DeleteNotifications)
	router.GET(baseURL+"/v0/notifications", wrapper.GetNotificationsV2)
	router.PATCH(baseURL+"/v0/notifications", wrapper.UpdateNotificationsV2)
	router.GET(baseURL+"/v0/organizations", wrapper.GetOrganizations)
	router.POST(baseURL+"/v0/organizations", wrapper.CreateOrganizationWithTier)
	router.DELETE(baseURL+"/v0/organizations/:slug", wrapper.DeleteOrganization)
	router.PATCH(baseURL+"/v0/organizations/:slug", wrapper.UpdateOrganization)
	router.GET(baseURL+"/v0/organizations/:slug/members", wrapper.GetMembers)
	router.DELETE(baseURL+"/v0/organizations/:slug/members/invite", wrapper.DeleteInvitedUser)
	router.GET(baseURL+"/v0/organizations/:slug/members/invite", wrapper.GetInvitedUsers)
	router.POST(baseURL+"/v0/organizations/:slug/members/invite", wrapper.InviteUser)
	router.GET(baseURL+"/v0/organizations/:slug/members/join", wrapper.GetInvite)
	router.POST(baseURL+"/v0/organizations/:slug/members/join", wrapper.JoinOrganization)
	router.DELETE(baseURL+"/v0/organizations/:slug/members/:gotrue_id", wrapper.DeleteMember)
	router.PATCH(baseURL+"/v0/organizations/:slug/members/:gotrue_id", wrapper.UpdateMember)
	router.GET(baseURL+"/v0/organizations/:slug/roles", wrapper.AddMember)
	router.DELETE(baseURL+"/v0/pg-meta/:ref/column-privileges", wrapper.RevokeColumnPrivileges)
	router.GET(baseURL+"/v0/pg-meta/:ref/column-privileges", wrapper.GetColumnPrivileges)
	router.POST(baseURL+"/v0/pg-meta/:ref/column-privileges", wrapper.GrantColumnPrivileges)
	router.DELETE(baseURL+"/v0/pg-meta/:ref/columns", wrapper.DeleteColumn)
	router.GET(baseURL+"/v0/pg-meta/:ref/columns", wrapper.GetColumns)
	router.PATCH(baseURL+"/v0/pg-meta/:ref/columns", wrapper.UpdateColumn)
	router.POST(baseURL+"/v0/pg-meta/:ref/columns", wrapper.CreateColumn)
	router.DELETE(baseURL+"/v0/pg-meta/:ref/extensions", wrapper.DeleteExtension)
	router.GET(baseURL+"/v0/pg-meta/:ref/extensions", wrapper.GetExtensions)
	router.POST(baseURL+"/v0/pg-meta/:ref/extensions", wrapper.CreateExtension)
	router.GET(baseURL+"/v0/pg-meta/:ref/foreign-tables", wrapper.GetForeignTables)
	router.DELETE(baseURL+"/v0/pg-meta/:ref/functions", wrapper.DeleteFunction)
	router.GET(baseURL+"/v0/pg-meta/:ref/functions", wrapper.GetFunctions)
	router.PATCH(baseURL+"/v0/pg-meta/:ref/functions", wrapper.UpdateFunction)
	router.POST(baseURL+"/v0/pg-meta/:ref/functions", wrapper.CreateFunction)
	router.GET(baseURL+"/v0/pg-meta/:ref/materialized-views", wrapper.GetMaterializedViews)
	router.DELETE(baseURL+"/v0/pg-meta/:ref/policies", wrapper.DeletePolicy)
	router.GET(baseURL+"/v0/pg-meta/:ref/policies", wrapper.GetPolicies)
	router.PATCH(baseURL+"/v0/pg-meta/:ref/policies", wrapper.UpdatePolicy)
	router.POST(baseURL+"/v0/pg-meta/:ref/policies", wrapper.CreatePolicy)
	router.DELETE(baseURL+"/v0/pg-meta/:ref/publications", wrapper.DeletePublication)
	router.GET(baseURL+"/v0/pg-meta/:ref/publications", wrapper.GetPublications)
	router.PATCH(baseURL+"/v0/pg-meta/:ref/publications", wrapper.UpdatePublication)
	router.POST(baseURL+"/v0/pg-meta/:ref/publications", wrapper.CreatePublication)
	router.POST(baseURL+"/v0/pg-meta/:ref/query", wrapper.RunQuery)
	router.POST(baseURL+"/v0/pg-meta/:ref/query/format", wrapper.FormatQuery)
	router.POST(baseURL+"/v0/pg-meta/:ref/query/validate", wrapper.ValidateQuery)
	router.DELETE(baseURL+"/v0/pg-meta/:ref/roles", wrapper.DeleteRole)
	router.GET(baseURL+"/v0/pg-meta/:ref/roles", wrapper.GetRoles)
	router.PATCH(baseURL+"/v0/pg-meta/:ref/roles", wrapper.UpdateRole)
	router.POST(baseURL+"/v0/pg-meta/:ref/roles", wrapper.CreateRole)
	router.DELETE(baseURL+"/v0/pg-meta/:ref/schemas", wrapper.DeleteSchema)
	router.GET(baseURL+"/v0/pg-meta/:ref/schemas", wrapper.GetSchemas)
	router.PATCH(baseURL+"/v0/pg-meta/:ref/schemas", wrapper.UpdateSchema)
	router.POST(baseURL+"/v0/pg-meta/:ref/schemas", wrapper.CreateSchema)
	router.POST(baseURL+"/v0/pg-meta/:ref/search/columns", wrapper.SearchColumns)
	router.POST(baseURL+"/v0/pg-meta/:ref/search/tables", wrapper.SearchTables)
	router.DELETE(baseURL+"/v0/pg-meta/:ref/table-privileges", wrapper.RevokeTablePrivileges)
	router.GET(baseURL+"/v0/pg-meta/:ref/table-privileges", wrapper.GetTablePrivileges)
	router.POST(baseURL+"/v0/pg-meta/:ref/table-privileges", wrapper.GrantTablePrivileges)
	router.DELETE(baseURL+"/v0/pg-meta/:ref/tables", wrapper.DeleteTable)
	router.GET(baseURL+"/v0/pg-meta/:ref/tables", wrapper.GetTables)
	router.PATCH(baseURL+"/v0/pg-meta/:ref/tables", wrapper.UpdateTable)
	router.POST(baseURL+"/v0/pg-meta/:ref/tables", wrapper.CreateTable)
	router.DELETE(baseURL+"/v0/pg-meta/:ref/triggers", wrapper.DeleteTrigger)
	router.GET(baseURL+"/v0/pg-meta/:ref/triggers", wrapper.GetTriggers)
	router.PATCH(baseURL+"/v0/pg-meta/:ref/triggers", wrapper.UpdateTrigger)
	router.POST(baseURL+"/v0/pg-meta/:ref/triggers", wrapper.CreateTrigger)
	router.GET(baseURL+"/v0/pg-meta/:ref/types", wrapper.GetTypes)
	router.GET(baseURL+"/v0/pg-meta/:ref/views", wrapper.GetViews)
	router.GET(baseURL+"/v0/projects", wrapper.GetProjects)
	router.POST(baseURL+"/v0/projects", wrapper.CreateProject)
	router.GET(baseURL+"/v0/projects/metrics", wrapper.GetProjectsMetrics)
	router.DELETE(baseURL+"/v0/projects/:ref", wrapper.DeleteProject)
	router.GET(baseURL+"/v0/projects/:ref", wrapper.GetProject)
	router.PATCH(baseURL+"/v0/projects/:ref", wrapper.UpdateProject)
	router.GET(baseURL+"/v0/projects/:ref/analytics/endpoints/functions.inv-stats", wrapper.GetFunctionStatus)
	router.GET(baseURL+"/v0/projects/:ref/analytics/endpoints/logs.all", wrapper.GetApiPaths)
	router.GET(baseURL+"/v0/projects/:ref/analytics/endpoints/usage.api-counts", wrapper.GetApiCounts)
	router.POST(baseURL+"/v0/projects/:ref/api/graphql", wrapper.ProjectGraphql)
	router.GET(baseURL+"/v0/projects/:ref/api/rest", wrapper.ProjectOpenApi)
	router.GET(baseURL+"/v0/projects/:ref/config/pgbouncer", wrapper.GetPgbouncerConfig)
	router.PATCH(baseURL+"/v0/projects/:ref/config/pgbouncer", wrapper.UpdatePgbouncerConfig)
	router.GET(baseURL+"/v0/projects/:ref/config/postgres", wrapper.GetConfig)
	router.PUT(baseURL+"/v0/projects/:ref/config/postgres", wrapper.UpdateConfig)
	router.GET(baseURL+"/v0/projects/:ref/config/postgrest", wrapper.GetPostgRESTConfig)
	router.PATCH(baseURL+"/v0/projects/:ref/config/postgrest", wrapper.UpdatePostgRESTConfig)
	router.PATCH(baseURL+"/v0/projects/:ref/config/secrets", wrapper.UpdateConfig)
	router.GET(baseURL+"/v0/projects/:ref/config/storage", wrapper.GetStorageConfig)
	router.PATCH(baseURL+"/v0/projects/:ref/config/storage", wrapper.UpdateConfig)
	router.DELETE(baseURL+"/v0/projects/:ref/content", wrapper.DeleteContent)
	router.GET(baseURL+"/v0/projects/:ref/content", wrapper.GetProjectContent)
	router.PATCH(baseURL+"/v0/projects/:ref/content", wrapper.UpdateContent)
	router.POST(baseURL+"/v0/projects/:ref/content", wrapper.CreateContent)
	router.PUT(baseURL+"/v0/projects/:ref/content", wrapper.UpdateWholeContent)
	router.GET(baseURL+"/v0/projects/:ref/daily-stats", wrapper.GetDailyStats)
	router.PATCH(baseURL+"/v0/projects/:ref/db-password", wrapper.UpdatePassword)
	router.GET(baseURL+"/v0/projects/:ref/infra-monitoring", wrapper.GetUsageMetrics)
	router.GET(baseURL+"/v0/projects/:ref/invoices", wrapper.GetInvoices)
	router.HEAD(baseURL+"/v0/projects/:ref/invoices", wrapper.GetInvoiceCount)
	router.GET(baseURL+"/v0/projects/:ref/live", wrapper.ProjectHealthCheck)
	router.POST(baseURL+"/v0/projects/:ref/pause", wrapper.PauseProject)
	router.POST(baseURL+"/v0/projects/:ref/resize", wrapper.ResizeDatabase)
	router.POST(baseURL+"/v0/projects/:ref/restart", wrapper.RestartProject)
	router.POST(baseURL+"/v0/projects/:ref/restart-services", wrapper.RestartServices)
	router.POST(baseURL+"/v0/projects/:ref/restore", wrapper.RestoreProject)
	router.GET(baseURL+"/v0/projects/:ref/settings", wrapper.GetProjectApi)
	router.GET(baseURL+"/v0/projects/:ref/status", wrapper.GetProjectStatus)
	router.GET(baseURL+"/v0/projects/:ref/usage", wrapper.GetUsageStatusConfig)
	router.GET(baseURL+"/v0/status", wrapper.GetStatus)
	router.GET(baseURL+"/v0/storage/:ref/buckets", wrapper.GetBuckets)
	router.POST(baseURL+"/v0/storage/:ref/buckets", wrapper.CreateBucket)
	router.DELETE(baseURL+"/v0/storage/:ref/buckets/:id", wrapper.DeleteBucket)
	router.GET(baseURL+"/v0/storage/:ref/buckets/:id", wrapper.GetBucket)
	router.PATCH(baseURL+"/v0/storage/:ref/buckets/:id", wrapper.UpdateBucket)
	router.POST(baseURL+"/v0/storage/:ref/buckets/:id/empty", wrapper.EmptyBucket)
	router.DELETE(baseURL+"/v0/storage/:ref/buckets/:id/objects", wrapper.DeleteObjects)
	router.POST(baseURL+"/v0/storage/:ref/buckets/:id/objects/copy", wrapper.CopyObject)
	router.POST(baseURL+"/v0/storage/:ref/buckets/:id/objects/download", wrapper.Download)
	router.POST(baseURL+"/v0/storage/:ref/buckets/:id/objects/list", wrapper.GetObjects)
	router.POST(baseURL+"/v0/storage/:ref/buckets/:id/objects/move", wrapper.MoveObject)
	router.POST(baseURL+"/v0/storage/:ref/buckets/:id/objects/public-url", wrapper.CreatePublicUrl)
	router.POST(baseURL+"/v0/storage/:ref/buckets/:id/objects/sign", wrapper.CreateSignedUrl)
	router.POST(baseURL+"/v0/storage/:ref/buckets/:id/objects/sign-multi", wrapper.CreateSignedUrls)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9+3fbNrL/v8Kr757TdleJ4/Sx+809e/Yqtuxoa1teSU7aW2d5IBGWsKZIhgDtuHX+",
	"93vw4BsAQUr0I+IvbRKBeMx8ZjAYDGb+6C38deB70CO49+aPHl6s4BqwPw7WaApBuFiNA4J8j/1bEPoB",
	"DAmCvDH72SZgyf5K7gLYe9Pz5/+BC9L78qVf/Jd+b+AB946gBZ5AHPgehuVOYRj6If2D78HxVe/Nb8UG",
	"C9+BmeG8aD2HIe2cfcmaIALXkvk6/hogL/MtJiHylvRb118AukrtjzP2g6TBGmIMlvLfQgiwtN8MgUAY",
	"gruqjjABJMLyjkr/9pGNjCOX5OhRYkh+AjKWvQWL6ygoExM5UiYgD8OQQMcGRLoKhM9XdxgtgJt2LBrN",
	"fd+FwKOtgtCn49uKQUqkyGAuhJ8iFEKn9+Y3OkfJiLnuk87yU/+opMTIMaRFeS7qTjXyMOcNcmz8Uwiv",
	"em96/28vFd49Ibl7YpEScAU5MhwCAiTSB0IXQUzOi23hhYc+S5nhAlLnAxnGAkRCG3pg7kJHDogQLlXS",
	"SRAMR47yp5/hnfS3W+AudWMW2CdGSftM5lToqrCafsJAKQOkkIiurmAoFdcD343WnrEwemCt0CUMLHKa",
	"0Xmrf7ENsS4GT4bKfB6PIVs7X+B5iG6QC5cScViGwCNQPkH2mx8q9I7Nfi6sLqdzxKA2EXoeetGaLmdw",
	"ctLr96bDk+HBrNfvjc6mwwn9w8X54WA27PV7k+HRcDI8OxhOM4tK1HOeNvEk+8lSSkMXZiunU3A3Zn97",
	"6zt3ZTJdhf5azkRftoPkp8g+Zk31Q6uVVgDIqnoc1ko6RAgBgRwL8vUtVnBxLV3gwl+voSfffBx4BSKX",
	"vAduBKXylW1w5IdrvonFOICfgxBizIXeRQSGwJUwvN9DDvQIInfH0INhYlfE3bz91TocHg0uTiiGBicf",
	"Br9O5b3gkehHDliEzyLXVQMa4fMQrUF4l1eBuRYXHvoUKb5Xag8Gy5Fc5RC5jVTUpqKHREuw5jooeAR6",
	"5ByEQGbYLfjPCpbiRYgCpXGH5FuHcvH+rQdDlWFS1Bz4k8s2isAPCcWMv7TpP8m4fYMwmiNXcDvuIMIw",
	"TA2WXr/nh0v692juokW1sskq4iwhxHe5UdXUH34m0KOwV8giwAvg1AWRZgu6gSGWs6uwvHjk8mYTd6Fe",
	"1FHkLYhyTSBcYpnlnBGCgnU1hytwg/juE3Pv/fhkMBud0C1iOhu8ZX8YnZ5e8D/LULDwvSu0tIME6DIV",
	"hTykPqsAbxmpjhBKZoSQRKFnE9UBR8MsDBdRiMidzSaWs1tUthQjboZiuUVllpCwNTu9DJNLQ6u5PQ6X",
	"wEO/g5jj71+XeX6NvJq6IAB3dK+x15CsfPm3GP0OlbZpFiv073YA7pbCxrSD0I//eBUyM4H9mUCwjv8M",
	"PQLDIEQYVquCWNEiLZ3OfRct7hQysSjuZOfDyeloOh2950bQdDYZHczo36TQ1m7ZgNM+7lljbB0OT4bs",
	"D9Qskw1UISFqIfBdWFPoG9jRCraoLT3OF74BKBgTkZWNEYF2FLpyCrt+5FBE3SAHyg3kRYSJv7ZxFIA5",
	"wNBGFFsecG06W4hJ5cHzgHUwFd+PxOeT+GvKmLkdAMw6WiPvBHpLaiX+IGPh3A5CtEDe0mZAV2zSztzW",
	"HAydOdtsZT9dB1h/3lRv/+FStfnfwHABXZur8IjbffKZF7exPHeSQdKtWxAuu2IpkUzYWAkytVkPPN+z",
	"rxUHagOMQc8JfKQwzhs7lOx5CLzFSs9QhO0QAsf33Dt77TuwOfuTfUSFgyCENwjextMK4VVNrcKETLpL",
	"K7GOYXiDFlDJHKXzsN/D0TwxDJvBlbvZMnxKgFskF19bxnWSON+Ks5AxVk7aDKz6KULzJNFgnlnSQG0J",
	"6g8CcrOA9olXtgNdSFTeBtGGk03fhoSRtwBVPUWBo2zDtpcKFHrJYZKEEZS4hkvblpqqE9+Fir3KWSOv",
	"pjwsgGfP76gGtEMXy1dI2yzY2LYzr2xCt3p1I9df5q4Jsj8z5S41zBe+50FmItkuWiOi0GYrGCKimQBT",
	"VEGMSX1DHAUwZEdEaYs1pMPa/lU9cvPPavJIYyNjfOuH8g38BrjIsSOPINfQVFJjbsrskC0JsdxK4601",
	"UyB+CJbwbbS4hipbzXX9W+jYa7Tm3r6adL5CLrTpoUIHMkf44OjW33vT2/v3t5eXt/f/df/i/vLy5f3l",
	"5Z/vv7m/vPz2/vLyu3vr/jJ69er1T/eXl3+6/5/7v9//9/2b+8vLv9z37y8v//Hdn/+01+srVNzC4KzH",
	"VLloXZ59X0YPNX1nVD8pnBAat199H0Q95M1CtFzCUH1quin5AAdHs+Gk1++9HR6NJ/Lzktj1mLWS/XQ8",
	"GR2PztiB6/xkdDBInYj93uFoOnh7MjyUd3gT3/ImcIv7VJ6yZP2UICk8KXZ9p0nyqZJFSQvNUUtjrSHo",
	"kRLxJ+MP3CMzG54Oz2bSRbZ8Q5JBRYHTCZ+KhC1Sq0ybjNmVrrt4AyPHsf7sVgb1GlUdB0vhAyUSrJF0",
	"LofMauI3DFguUwEgq1pIk1w8yPXMoX/ruT5w+BWdfHRH3JyWPm54gqm67P7enrMNRa7CvrcVly26iAGJ",
	"jmarKprx+YvyZCLpsMkg1cRUHyvprnARGlgAcUPdYLpbMT+NZNFBN99Vgt/+ptda8n4lYSq8mdyoi389",
	"U97OhMDDV364rlqmsFb4bGbxV1lxLa2A34n9K4Khwkf4if5UTSLeTEajY0iO/VkYwQNmaatBI7Y6ezo6",
	"Prs4l9Nq+MtsODkbnNiD8/OToT04PBzNRmP6Dwcno+HZzB4dTqU0LHyYtDZpPDzjW7DJjKbDg8lwVtHr",
	"/15MzKfAGhtOgbU1n8LF5ETf7O1o9vbi4OfhzHS26QdmM07bm8z6cDQ9GE8OTScTNzebStzaZCLD08Ho",
	"xLDfo8HB8O14/LPprJP2Nbs3mffR6Ph0YDwR1thwFqytyRSOR7N3F29N5yBam01CNDacxcmgzixoa+NZ",
	"0MY1ZlEphsfj8XEzbSe+NF0nb224Tt7YZJ0/D34ejE0nwRubzYG3NZrC8NeDk/HAWAqT9oYTiZvXmksl",
	"409GZz8PD0dnprNO2pvNOmluMuuzMcWe6UxEa7N5iMYmszh/Nz4zRej0ZHBgzHDeuE7HJtOdno9no6Nf",
	"jSchmhtOQ7Q2mcjsw2h28M50HqK12TREY9NZzIaTOtOgzc3nQVubTOTDePLzeGo6D9HabBqicY1ZVKqB",
	"/x2PT03nytqazZQ11czznx9m9vCXc+kZlhpAw4k9uJiND8ZnR6PJqXww0W48O6/qajo8YJYuM60O3g3O",
	"jivkPP7u4u0/hwezqS3mMaC6RLqe4gfZoYw+GJ29H83Mmp4OjkcHTMEaNZ8MD8bvh5NfdY1nw9Pzk8Fs",
	"mF8p/ctseDYz+zJH3Vpf8rXX+yYlQr3vYmrovzoa2KeDX+zh2WR8cjI8pJbwbDyZSjF2PphOP1Dr/nR0",
	"Zp8Mz45n76TtJoPZ0D4ZnY5mglTT/PDSltPTqabd8GgynL6zZ+Ofh2f2ZDwbVG+M08FpxemCCcto9qt9",
	"MDifHbwb1Gx9Phm/Hx0OJ1LCllprVETStrDM4cV0aI/OZsPJ+8GJlC7Jl9xBbSccmgz/dTGaDO3JcHAx",
	"ezc8m40OiiKdXRoFpUqBUsZUaijaiOLoiA48PDv4VT5d2mo4nQ6Oh29Hk0N7cHAwnE6pKaccOducu/gH",
	"s/FE2VynIuPfNcilTfRsPZ0mIqZpMJ3RkSob2O8HJ6ND++JsNjrRNP5ldjI+YM6RkZZWacvp8Ey7gg+j",
	"k9GYkn98cTazp4rtMNv0YiZgWdVSMMyeDifvRwdDk87fDyfUAqsxnfgL41mJD+pM7v34jDatInqmmU7E",
	"05ZHk/Gpos3s3B4cUuXK1Ka60bvxdKb+1UQOZ+dMV7BLYHmAQ6FT2toenh1Mfj2fcQ1p+N14opkqx6l9",
	"NjgdqhtdTBVQvpiM7MHJyfiDfTKSEqTgXk3UXL/oJk3NNAkbskTPrio7PSnppQae0iCqsMU05k6FUaa1",
	"q6qNFFPTycQEMTWmzMwgjflSAofS76g8FmvsA50xoN76VYaR3AwyMukrLSO50dbEcDA1U0qnlbIFITMX",
	"8tt3abMubM1aU0JrOKj2VMUOqtwvVbtj5V5YtfNV7HOmu5p0D1PtWOX9qWDpFOwajRWjvPfR3B6p7n+U",
	"FziaayDVRY702kZ751Jxg6O7f9Fcn2gvYtQXKbqrDf01ieaWQ3lNobnsUF1XqK8bdNcWynsH9b2B7v5B",
	"eYEgvy5QO+11zn+l917pftc48VVueJ0TXe+Q1/jTVd5zne9b70fXuMHVbmydO1zpz1Y6mTWuapWzWeMr",
	"1nqd1V5jtddX5z1Wun813lutH1jtx1X7YXX+XKVDVu5+VTlQ1U5YhR9VEQFxCkmIForgJ/ai4wa42Yi2",
	"fafX731P//NXRxrOtmY9Fl+W2p8iGKJcyGU5LKnJ+4Wl0fNNMal+uqTCqElXejqpg0T4CObJM8QLGN5v",
	"ZRhZ3LtidtoQNsNQpFyMTiGerlY8Uj8ZUTFb/hDiInQ3mm/Sy/aipo4hmaKlBx3l3ODnAIUQjzypD8CU",
	"0vEYTembzqJqFfghloEl69ggXNJkgRcYhuKlPgesJLat2Wv8qhBKF2AiHsA49vyuXjKU5A2AUU4VqjcV",
	"XRXIlrTsq5L/aHMJVISFFt5qp53GZFCQKk+lB19yPs2BPn0TZ0xuytLHZpkVyxIbJGHRuWjWhPZl9FTD",
	"W73jxMHBRtuNVGaqpNFR5Q3Kxk128ZJdvGQXL9nFS3bxkl28ZBcv2cVLdvGSXbxkFy/ZxUt28ZJdvGQX",
	"L9nFS3bxkl28ZBcv2cVLdvGSXbxkFy/ZxUt28ZJdvGQXL9nFS3bxkl28ZBcv2cVLPqd4yRB4pFA3CKuS",
	"RNJWdjk/5uWl85fLy5f0f/J8l7qyQ0+mtFC6PE1xISUJWXLNKgo+Gh2SrP+zycXZQYk29N9Hx8fDiTSU",
	"NYSuJmN3gYrZxjXpOPJuEIGykF367+oU5uJnuAbI1bZQBGiFvmlhrrSffnZWxTmkXaqXqUkTH5GVH6Lf",
	"oWOrkxOzgew1IIuVogELN3Rs4l9DRTZmPmlVdYBc8nF1MSPave34ENueT2z4GWFikNe23Hl2Oopu86vu",
	"lwhVXLSa+BdYlW+2GkzaqMPaUIoBk4mn02Hnnz7yNMUOkesib6mThLqV7txoqUiOGaIA2rxegqrERGHN",
	"+en183Xu6EDSbmVkOGU5tiX61SdhpER0wOt5acgjSC8N2C/GjqYB++YBnun8irPJjJ3pULp2/wY+Uu26",
	"M5+gK5FaPUbh+/2mKV7N45PXUNGfl5mQWkflWmlKOWhDhqW1UdXZXsszk88jyRzL1mhM9NePSXRlrvoQ",
	"+aE8NFlTdFYZi11N8biiVUzKZAJp6ZcK4mYLW7WgVxG2iynyjcqkBMRGXlIZukZBpY3UdYNiJjyzMdfd",
	"guQlLR/TQDqL/GKrWDR1o+VDbn+PxIj6RG5E2fPl3I+8BYug1yYLTmtzTPkMFfWiHA+rtbAzt1c+Jqrf",
	"dN+x+o8yxjlzG2NXkel5XjSfS5VM7cD3XbtQYy4jvUvPDyHV1CGJAl5VEBJR26O+PgWf7YWLoEdsSk/5",
	"o5WYI/r6SmmzVKvGR8GD8eno7Ng+HH846/Xjv7GruKS6Qb+Xvec4GQ8OR2fH8keMlD7FCgosQ7aoZtfv",
	"4aSkK50LZFUkpBUBogDcIOyHNapG57V9FmApe1NgpVBJAZVAREZb2aQkxO2X8S+VJh95ZOTN0Jqe7Ygf",
	"KkpthHDh38DwziasZgcIl5DYkbLad/5srfpUPiFMliHEqqrXSUXByhvnTHWQyrZ0x1VXwowF70ZZQ5ii",
	"rG4ZjKTUsPGDOFEZ2F7mSgyXTScct9AURkMVZYZtr6LOMGWhsoww/TmgRFV2oKnf4SAPuHbg42I9x0x9",
	"hHYrdWTKlhcKaYjzX2mSmYq7WaxkkZWwPE9/OV8LXMxzpEDfLDdiKMalN1MxqBa21A9Y4UWViBr7VWdj",
	"Z3o2eiZXLAovfXLuVpyhkhamRX+y3tTix8UB88vOLVJPa73ZAq+uqNa+gfYCLFbQVhaTXQPkEegBbwHt",
	"Wz+8ttdwrd7Dk82Av5EHn9Gaboyvf3q9/8P3/d4aefwf9pOp096XXNxoD9SQcF3o2sVxhWmRdLn/6vUP",
	"mQ5fVXa4zU7sAIb2EpAVt6Fq98e7sYPQX0CMYQWxpN0I20Ja0S22RvwQLZHHy4TTRqxO+EJRWR6vQAgd",
	"ex5dXanMuMSKYZusH8n3FQ1KvmgQm5QC11bgqt5jY82orPTNzFFC+elkW1X2bFDrq6IPeem3RPCLU5dN",
	"1EzTHvkhREtvFm9SMi1bI3VF3liSlVGswaDablZDpZrfRxPdaUAsUetKWqo94nCPq+mVZret2uzrwIWE",
	"nafEOUG+ARZKuCuIbVzSXeWaiU0FAwI8h6rwUmhkasHnasRLeNEvIkFNomJF+Uwl+tLEiwzVgfQUEBgi",
	"4KLfofMewdtnItUI24EfRK76kNCO3OfGNVMDvD59e7XpjU6SrdWq37pafpiS9nWOU/KDVOaQJbCRuGf4",
	"ElLCFxUB45wWMmmFZ+OMJ19r0WedquF2SN1C0FmexV7ywjJLsy0RS7LqZPo61k58meUExJEpf8wp8fhJ",
	"VpVuWp7btPy08/hVqbdSKbqeDZ8FaW6CRQ6X2VkgTpaVcqqUgNWXAVLCrwwB8stN8KEThWmitttRcJVi",
	"r5uc4ogzvyNQIZuPaiY5EDh26N9iG2KC1nkFWylMLuV19dc6BxkLq7iGd3USF7KPfoZ3Ou8YXqHAvM9J",
	"5it5rwz6OfdxbBMdDo8GFyfcKDoc/tLr944uWIjf2Xj2TnVZE7pYf21EG1z54UL1u+5AInedmZip2Wnl",
	"5iAhQV+AWgwoRYMUYClCCwgocq9SznSu22vkOfXOgA3ctflZ1LIxC+wocoJN39i7Ksqyb7Ek+8L3HHNj",
	"/SEKuD/94uy1N6AnW7Odx3WmJ5VC2XaB0fhIk2A3BU2xMHu+CHyp6nvSg7LuO+OpVgSE66a5p7bF28xt",
	"uxWLntrkii25BjNwMDwvt03Ti9VN3TbZC0cTqpKqmy5nbsPPJAQ2ZjmO1TXtnblO2azBZ7avZn5MbmOK",
	"yZvjptk++/KJSJeWWlyl1dSnu1YPxT+ahejmnStJ6GZGO6mCkkX260EQGLBLsxToOYGPFO7xEAKXRX+s",
	"I5cgdnlIakTUZHmVjFPRq2ath5AA5GoCx1w/cuwg9G+Qo3D8GMaWvddcdekiy5RHdn2wFsL2PATeYqW3",
	"qK8DrJuYCzA5pJIOMJxAatIOlLFhcbvzEDJ60U6P53U3/8yrClVeZBBCj9iZRPEKnKn+falaLVVUF6Gr",
	"uNAIb9ACCmJVp+EuNM/FD8c2zehswF3S/R7/g/1uODiZvfs1/YeLs/SfsqFwF2c/n/EAueNxJlpudDaa",
	"2UeDURwadzp+L/40nY0n9NzV712cH0/UAXPVAbT93g3d1eAU/Q6l/C3GUeRFKBvuJomIjn0KBSBwfibc",
	"y4RMFycsEciUszK50GiHkXflN9IJ7QotczsBx/fcO2Z86ltvJmwhvEHwNp5Wk1oQtcVQ88Chdnh3CXzt",
	"QK7MODnpNFg7TSp0yEpYaJ97qGhcjFFUCGi2m35alIN/rZnxBF6pN87aN1XSNcjMUT5N5esiMTmhgAcB",
	"+hneaZ4qBsi+hnf1fCJxNL1+snHXGdtrifVTJgR5S6ybbWCndwUGhUzKphw1WKr118OFwuct+yah8FVK",
	"9T+3xMZwEUJSN/qhvubioLMF62vXnZGDVuZAU6lIefASF5lEf1VEpaex6LJI9TQ+nUellzSspmRPqTpM",
	"+WDh33quDxRbWfzrmVIyQ+Bheu6vVVdnFn+VlEz5opu8Wj6DuIlB0ZikqYxQOde77DULJiFAHlFLmkL/",
	"Yj8KF9CuCtIVzXT+dN5CezClKo9F+FcNJ5qZdcZb1fJgFAlWXKBsOVJaySchW4B07XJW02OV/KUFN7RZ",
	"2K+9NDC1C+0VwxEQxppmAj9FEBPZG48qJZdXbvGRBjhr5IEA9fp0/3uxBATegruMz5LqH/6IuNfvXfvM",
	"Ok8erLA/Y99B0Zr+UTiPPrmZv2QP+0ynMTnu9Xu3wF3yJ/U+XkWEqgrpAaekSjmXc09bTSzLhAxajZcn",
	"N1Y9qGGNMszQX8vJOFh+aZPrUzU3P4Qn/hItgPsWLK6jQJFTwMw7rhnkfHWHG43Sl74ZMjYVJZ/qZsm3",
	"Yfn0rgNc4aeq6FZ+mpyDxbUd1biW5SQcOVKvcuOjqclh8IHObNzpHBsr5WNZ+fiVHNFKxkhCXTnXb/xr",
	"+Jipg556YiBOoY0zA33teX/kcWj1jsDKGy3pgJH3rwiGd3JWfKI/VQ/Bm8m654UmuWDIh9j4Zil/Waee",
	"BMPeI87Bc6qyHW2c3Kl2yp3aCZumZee1LO2MXHYTw0uu3APm9H8RNzNNIVMw6cr9SNdRrNH5nM6PyeTV",
	"UMJxEwPzM2mqJRRuh1La9WkcWDAM+Sucyjvv+AK4smEjmvXFTPrqsrOCw2+jxTWUHJB4jKha6muGWVXE",
	"lS/kXNKW+jQI1M4solBFU4yqIUzVFfEVctkV0Yk6GBkfhRDOkNnroLRxv9C3ZpKqMrRzxlXV/Rb/1bQ2",
	"s0DIl35DTLDqo2DB3phqcxkp8yM1QFUd5MQZWxKapQBif8kBJwep0tIyC0nJXMm/fN3rEjPV4e7+1RWG",
	"8p94eIfCtRWSt3f1KnPzT+R6UdJQcbxQJUFQRWTrxyptS2UZTSK1Co+RZcb0CqLlSk7MTxEoVPTNHhrj",
	"0Nt4DHYm5145Algc/RVy5c+db5GTiwPKGEaltSuCzB8w5OyjalZpMGytYxP7zQ+fVbLVorEnlqA5UBXW",
	"IiPiBdMwuvNI8oBPl/pF9Qz9vTKXS7bBUUlY4OcgTJIHuYjAUPFq3wn94JB3pbjRL7gVDsYnF6dn9ujQ",
	"ngyPed0D5fvf41wGmHhub3+10hh8EV4smxrCo4rsL2cVyV8uNLlf1L58+ZviLxrmsxrZ58mr6tKVCMlz",
	"OcvERjXn9btqVVn2mA/cex1CcW3m+kub/pOMFfnS6HEH4uZNXNJzh5jMQKsmYfyEXi5B9ePDt/WqvvBc",
	"fkvP45/qk3cFc7LF2+UM6gq4dwXcuwLuXQH3roB7V8C9K+DeFXDvCrh3Bdy7Au5Po4B7khbwp1c//O3V",
	"K2lawK66e1fd/Wuq7p7Jp5nB+0/9GmXf02ya+z/89Ye/ff/TD3+Vph+trAvfoKOucPxDFY7PRkv99u/+",
	"R0WcVFdOfpNy8lkif/vbqxf//+Mf+/39H7/8nf35L/1/fPdnNdm7svNd2fmu7PyDlJ1XuH95PTBFeLhp",
	"fJguBIwPky3FxOI4ZcWvFOXDVBcBpXtRrJlAthaOfLXVNXC2XexGEe5QKFBTVYuGr+9cpHCTry2b4W6N",
	"vBPoLcmq9+aHqlvU5DvNwPlSOPLxpVVjMnac4uSSSWher6KMpGJMOtrfSsMpJDgzvGl5mW1VfSliW7l6",
	"eXWWdB4axrGMtnVvtZvdiW0vT+wXzXp8KjeVGUR2BYrPrtLR1jAvWbxODLIlMeTi0JXD6MphPI1yGHnM",
	"Eu2eu/3MVjk1WakpNfPXPXcze6aifKEiRkhzb9d68/e15t+umdVZzbqJr3oV8yTTWpdWYZat+tmlpTZW",
	"HTxdc813TZrczKphWN4L7aa6WAFvCW0SgsU1Pe8oouG0WTQKSiHTti/r/2PVfNVm4xpiLA/qKqb3Ew01",
	"Y2XD9xUxca7r30LHXrPnw3F1lRqZMJErXuOrQa5+3yHNGNEr99qXzbNy3TpMVL3dKNbcrnyOIRm5+cuR",
	"hqNrXhLqYoTrJzLadlbsQoc28hz4WT52awm01SpGZFlWCFDTTMsPkTs5TcOniH83SR/R5VfeKL+yBFTU",
	"NHsu0d7agvtPIxhc9WYlS6ekEH1m1NzipFqV7q/TxKlREPwbgFzOec8OXKC0EDFRFFFQ7ZdRYf9X7Aq8",
	"WdyRGKkvmVfF0vQpi+npr/KdYJZQ4pwnHBd1vkL42q7MB8RVhr3wI4/UHIB9iLwbX9wO1Px87Xtk5d7Z",
	"otYJxj7LGbZhN026SFMBcxOwETWSTgIIrjMuoprdiPREzYASf4zW9L8h9BwYNlpM3FFt2ElyL/OqFrke",
	"+xlRKC1ZuwwFvzVokuA0h3kl+zUslQuXXC8oDZ1I8ZQYeB5UHxDFGTlci+rC0COqF8C5hsS/hp6umfol",
	"ccUjZe4+Uf6svpVjv9j8tFfZwBbTtEt5g1JNlmuvo0yuIaOMvYjCUGXQS5p7POe/qmkVSaG3CO8CSjWt",
	"r0BVyt3DhHmMlb/r84vgRDz0rg+b5WaTt2EPtTFaenRbVAwUrHwPqn/RsT7bQMvKXEM1yEWzKr6E4NYG",
	"QWCvIQG28vU8bUWpV9UMgois6BFsUS2spcbqtSQ5yvT9xYnM1P34CgO86qm/VMsJA1yVP6GhkV2VqpXB",
	"MJ7v/K6Ba3hDQ71ECy3xilZ64WuZ8Z1PvZrLnCAzwZNy8snsM+ss00u1Z2msWOIT4CoMbWF7GWWlS7bG",
	"qvAKPmDcvWzG74GL6JLazHCVG0NNHebeNfDN8XblgTLPQpnHV4S4QBBybc3/FL8s7/3zwyzOJsBG4+2S",
	"XleEBL0vX5gg8VSCLIUCE9Diybc3FMUxsAVCaCXnHgsQ65L1hN/s7YEAvYxTL71E/t7Nq8veS+vchQBD",
	"y/MJtMgKEOsWWvBzABfEIitoxWU3rDQIAVvEt7jafknniwhVRr2p6Noafg5giNbQI8C1BucjivO47ERv",
	"/+Wrl694/A5kuUPf9L5n/8Sz8zCS7d282qMqde+PEF592UtvFkQySMo0pmlHTu9N7xiS7Hta1lEaHfBb",
	"QX/F+bctniaZ7pE8LVCsbJJE8DHD+V1N6g5Zg89xLM9rfhuX/WsRox9ZUgyGOLa2169eFZwaIEjuNPb+",
	"g7mOTUfTiWFh5WkO6S8lgFCK/8iHzv9wBJALHcrREJIQwRto8T4tQfYsrBk5Y0D/9pEuDkfrNaDiSfmA",
	"C9/G2dOTtPPYonztfeQ5n3hKljw3yw+knyJDWZ7VWFtthZeKh+Ff8sqHTv1Lm4jK0r0ZjPgO1RREnAzm",
	"OPrSL2oLbkEz7S78TXmApVn+dgRYyV5tAqX9WuMWN0ApXn549X0ZLwZAwtBzLOBZnKH0X+h+tEQ30LP4",
	"ydQYVZTnWN9XHYitwRItXORd61F2Spud0GYd0J4+0CzGVYuydRtYq+iuDtx8EuiBNiZBB7FnocvGs/M8",
	"Gphzw8pca9TTZ/r+6oBMOB30QJvAOJ1bB7Ynr89iNxLXOFvRadVd1oEcgevApdbe3h/xH7/oTnkz0agM",
	"vwYQK/kSpL2QdEh1V2mqw9Rp3xP+5BfCURp7dnv9HtsYXrjcLogpKrvO3fToWOxvG4fChCAMO9KzX4Zm",
	"5lhI/E9pRGee/4fs3y9wp302PwG2qn04Ay12RWGsYA7Tj6xbRFZCp4wOtS4ElaK4ELeHTwkmsX7hXspk",
	"kGt4d+uHDm6kqwp9xdEPG3ckMuluoacbGKIrBJ1afbXpMss7yLcM/URZcm1Wz3MWX3nX1Jl7fyDny94V",
	"WBDfRIEeiYZPUzjyY6CHhc1DaMWYT3UVI3Dd+FsLYOwvECC8Y2CJMLEK3DiiYLPAzpzVFcI6c+utaLI7",
	"/nSx4g396EtILMEEKyZzPVVQ/FrCXP5TFXv3snUf5Me6Q9GCr303bKv8mts645nPYEPAxUwu4KaGklF0",
	"0Bx3ASIaV0JcKc1HHhl5M7SGu4S+zLIFIWoisIFdwoZJ2Mu2DVax2o+wxa93kWexKovGoJnU6LQ5kMTU",
	"K7G0SwBSlnJ8QAjVVTET+fcbA+NFIGpNVmubXFHKnUKKpB7nA0KFnedjNm0MHNYbKPVXH0gr379+wV8e",
	"qbEzZL+/8/3rp28HK7jV9MTCSWMdCqpZH+Cckgxbvse8vvGzFGNOclpisx5VDHP9pfbQQll1Qts8C++P",
	"2Qk3vR3S+32a+3mqv1xBwGusik8/v0hj6l8kIdFfz3mdHuIo4CwKOK500quO0WHNA11VTxTt2ZrUBo6c",
	"XHKvXpsxSbI0Yi04pY0CT7NziU9NdDqlMNRG5yjua8kzoq6npvC12kmdI+v714pLrYLEgnCxQjdM0EqC",
	"kAlXbezWdeK6Rfqsxs090MkA+yyTSWUKqGTEj48Gr9dbglfiHW4IsGNIyujSRlGWIdZUSxhnCntCamFb",
	"fBMBjQ25dqH6mur8bLlzrVkzzjV8CJJmR0z9U9sVhAjD8Bts5alQ/9ak1EV6GMj/+0dR4bhM4gP2Ti67",
	"5g+IrEQB0ja21vKAbGd9/dCOSDmba7D1wuOPBaBjsSq7FntyiLylBbwcW8wZy2mDix1Y3968/k7DW5lM",
	"7f2B3Wj5pdqcytKh6uyQbWvR/uUnCPHLxgbx1i+hmnGF0ykvanpJ021NT4bebVnNpdy3DxzJnx1/6kab",
	"Pg4Rm2Az6MRB/YbQ0Qjy3pqlTtbulaeiydOS4u3uznyN296PsxT/BlsxrevtyIpOFOxOfjdie+Zxh16d",
	"8wcejkm4WFs4ULl8xAPvmq4f473BbAsQs2gWpZX7uJqv6iNwhktft7iK90bbEdclJDkW1BXQ/Lcm/JPb",
	"zHxRjyliLW3g6cIeIzQgfZ+24ZYt3jrVE3E+MjaVbROd/R+fJ6LQa4EnpqZ56oWnErW4FTykeqORwthA",
	"U/zTR95TMPhb5PX25J8Sa0NOU4lraKrT0c0M9Zpa4I+lT6lqI8fgNC7M20eGSb6bZP7tnOkrbfS1X7DQ",
	"BQPqXKXTPrC0EyPh1h3ovzKWteUWyJT+MXcIbOO0XhstskO7OVp0KiGpPyK1CAaO87hYepATwcR3t+5O",
	"J6vSEZ6Tut52n95OSzur9NsEyxdrSECSvMWN1t6LIEQ3yIVLqL3ansAb/xoesE/O0y/kV6MthCT0n28Y",
	"mBnqpPRVZHJ6nKu8tDRMAQSGwtL87Q4ljcXhamXgWmN7VfWg9oDsONS/XjAJlbwRnNR9qA5axyHwSKc+",
	"21KfUvI21577Xw/gl5Qym6D9WNOByqgwiJLjdNgdCSiNzwnAH1I3iEBNCw0fjE8uTs/s0aE9GR4Pfznv",
	"GQe5LgBeAFYh7nGcZ3mZaOlhZ7B8KcC7QaxofMUex7rrOpUEvAsZ0V65HAjJ2SWJkF/DLdzIgY4otrGV",
	"9/fw8wZ9PoI91PqmADMQbvoGNtNBBeS17qluI3jAjaBVDxpfyGOE1LS7kQif3VY2kth3t4WNRBcvuWtC",
	"9bHNWNC6uN5/JrjmJShSCNaPAy2hWI9Z6YkBfibQw2ZPa4Zx2x3eLhIaNN4xHsPETznXmpWfAGnLhr6u",
	"34a2/jDFfOdWbMOMzsDtQSzpjBJrbEzDLCga7/w7qCJb3fwTej7m/t+a9kxNAJgZorkVADPoq2sIXPkh",
	"REvvRVqvW6U+j3jLGW+48w4T5ytNUSg8QXbqZXiiTpssHh/sAivOwWAJubGE3NS/xlL11ECERaFck3SH",
	"oukOW/IxCTY15Lf2EtsI6zHfWrPjYxBt2YzXdNvQij9K0N757HfZZ5+KxIOcNVIl2/iocZVBbnPPfafC",
	"W1LhbTno49k+pou+rf0jddJvY/+QuOmb7x+64/ruyVCrp/X6CN9/NghPz+pX6QjNj+pXKfLqmvlrQGCI",
	"gIt+h86LGwRv9a++M63fs8bdiX2Lx+OnY3R1noWtm5ZF2Xl470JW1i0u6xt4GCS91Vc/ge+iBYIGToZz",
	"2vJuh+1TToBn5WAQPGvNvRBwkmzXuaDstKFr4TyGeOdZ2GXPQiwLD+JXSNRqY7dCkKK2uVeh09kt6Oy2",
	"PAp8ro/pT2hnu0i9CZtvFxJfQtPtQudJ2DW5adWPUBfX+88E16kPIYj7b+5BCGLE1Tbgo7lrnk/7PG29",
	"y7tCSoXnZc5nuNeeTZ8hzpYNe23PTa37LP67AMBWLOcs7B7GfM4ytbkJnYfGBmZ0pzXb1JqtGdTphB/V",
	"qm5Pa2dM6+1obZl9vYnW1hrZuyhV7VraTQC//5wAn7G5c4O0vkNIbW+u+9Ql2SLvX0I7dujeqMCbIGRb",
	"oG61xlIYeRb+5FocLOb3PbnPGmJz78oP14CoIXrEfleg9GuEUmbBLaMpWUmTbGecb01wc1T8sil0boCL",
	"qDGgBs970WKH4JNb8mPssbkJbJhANeZwE5i9L39bH2hJikS904plEdzdcxdd/rN6n8qzPrbln6Kg2bJj",
	"StFlQ4/UxHe7FHctuaLqJBTd0AfVJKloAVObeZ06tQefh5+JzvQxHUxt6NvUs7SpvpW4lJrpW50vabdk",
	"pVUnUj007z8LNKduo5D33vyiNuRIq2vqxuFRlcbulBNrd/U+J8CzupcVPGvN5OXjbdnoVXba0OydJgGA",
	"neG7fcM3htiDmL6xsmps/KbBoM3N304RtqAI2zKB+Vwf0whuRwenZvDmOlhiCDfVwTpTeNfkplVjuC6u",
	"958JrlODGMf9NzeJcYy42kYxBOFilc1zLgf2lLXbuaTOLSE7S822kG1k2zxMfmYOskYpmjmlZLk58Utr",
	"AkkUetYafEbraG39+MoKIY5cgl82l4Q0XZdOEHYtV1ercsCI+ahi8CCprlIpqJvaSiYEvI8tywDrtFYJ",
	"LUa5rgRMWxW0CuR9kgW0ihB4mPpZDKqblM8qd6B2rOw2yr9aIMXlDDeAkrILbeWsTmu2WThra0pz/6vB",
	"Oi+b1Rzox+rvFVaEwT0Lt7p217vI1r8152JlUazKrua+70LgPdCNjbC527qw4Vjd7n2Nqs+G1zU7mPC5",
	"vgA0ToaE7zCB620m2ugyVH39GaoexBMg7vj4Pmn54Vb0VfEC0Kj3TW4Hu+17/lzC42p62J7JZp/eDG4s",
	"PJKLwaYio7kX3DGJafVasFWn8aNBOr0UJKL75neCRKCtthM4RMslw2blAY633OU9gFPgWYXKxVxr7+gl",
	"iLLlw5ey16bHrxjnXVLCXU5KmIjDw9j8Meia2/UpbDew3TvN3Ybmbs1+55N9VAu+nV0jY8NvvmvIrPim",
	"u4bWjt816WnXkq8L7v3nAu6MNZ8MsIE9n6CutkV/F+grEM5Yg84O2mk7iA7+QEYQg1tzC0igta4YVJb2",
	"6Mp5bL2cR3cN013DNFBGj1McZON6IDVKgIhfMuooP8+x597RKUahh5nhukYeWgM3UYTIu/J7fUk21rhn",
	"uR5TICKEwPE9985e+1RoCSARftiYATN88MWN6NqN4FFrjwFuQl5Kc0CsOXR9b0nRQlkAIrKCHqFrgI4V",
	"YakxVp10kTfstZqGkI/xGDZ1bgL69Eh1jWEQc0dO9oJo7a2pfC7UIjYg1trHxPrxVcr1BfCsOWTplBB0",
	"LEAsYBG0hi8vvYMoDKFH3DsLR0HghwRb3+w73/Stb76n/wWeY33zV+cbC3kEhjfAZRHYSvE8FZNrBwXH",
	"kIgBHsNnkI6+Hf4fQ2KtE3qVlKv4yfp2Dgn4TgIEZv4ZZGZPwPXk0qi15dyJpfSqKo+ZYpOt689PPTBa",
	"SdbkGt9VHh1CApC7NXmiyhQHcIGu0CIxKTJbHm6w52nzdz9dvrWW+7ruHvyE5NrYbyvYWttFa6gIpJp8",
	"D3jAvSNogfeg5wQ+oktPakC/RN7NC2rAao/6cVXTaWzpPiVYKk9v3LDQjgS9aE2J+OMaeb1+bz/+/4rK",
	"7b4DaH9/pf/7aDxuTFr7CSU6HMQQaAvgzFXF2f4NtpJqyci78UUmdooxhOkcamte444l1k4C/lri4fpL",
	"/BK4rk4mBgE6B2T1TKQBf3K34RIJcqexzbwr2LfpWQETsA7oGTpsoVvobcU918I8m8/xK1IUVM6aebbj",
	"j7cm8hEGS/gSBOjFwo88/XY4CNABb/T17YRr5EUEuvTzlR+F7A8OQK50C/yKoMj4b4EAWYL/TWFZ6qgZ",
	"RAO0twxBsPrkqrMrCHgdi3ZPE4zlqyCxrhf0sOSH6Pe4okpNFbj9k8jb6Ooqvtd+RgUbmLgnx9IYDcb4",
	"/Rfz3uFSB3WOGAHaCyGHqFRpCuyNA+gNAvSV+SNaZW5GS1kx+ZrdBafEN+brwveu0HIvWM79yFvQEdSb",
	"4nnc6IB9tEs+p/zKNyxykFy0pVtKQn+LM6Tx3lTqSLI3iV+qfVRPn9+t+aryS38Mn1Vcgdl3kbc0w912",
	"nFcbwbEQclgXkXolJS7DdTpq91STIEpbminuf1PFVOynQi9FRKWVdlAZ5Vj8mEHPWwFZSds0hlhZ2dRB",
	"mZGuIVqDiDaaDKezndU6pN2NSWYpxSNvbCkVO9rEUnr6QGhbOZHH107koa2kxlCUWEl10KjVXBguQsi9",
	"m1rM7h5Up5wyj23Si2lsexcVfN8CFgs9NUci8UOwhLoddMqb7Nz+mVv3A+6egiWb7p2FbjbYOXdQC2VZ",
	"/4ha6CEQWFZSDfEnUVLmEFQqqZiW+jDIA9HQLH786dz0XmDmvqIdjbWOa8NEBgnp49k1zV6Q6aJZtGPK",
	"kTZDdjP0275bpTYNCxq4goBPTJtWbQEJN9tSumKMc0oW/GgZoiUSafakp66arY2usn6tApjmQUe7DM2N",
	"UYeh+8+HofFD6eYMLbyXNmCo2uP6YeW7rUsphiFpXUofYrt8cGGUmzcsoqc67veQNpuyVs8i0gkQEqJ5",
	"ROB2nn8ahE2Zvpj1nEOwnWmxCMTanT1IjINBKAMDXhKSwAFYz8qR9VAH+fMXAcD41g+dSifYedxwlzy2",
	"Ys01z55bPxUmr4QTbjV6NVHupgZWkHcVghdr30PEZ7TXqMoLDJYwfab41SjLOC50EUQ2C23s9enwdvbv",
	"4GaZ+7uD8LWNfHseOUv2FD/+h4Xv4WgdxPF+YJ18gm9BIP5i/tSimSpsX0Vndo4yIffXvX7vR/qf/Vf0",
	"v9+z/+6v2IOTNoJst6W6iyGu8RvTzQJl1S9VNWJ546OFPtJjFLd5FqIYJ79onuziATJRFHC0laNMHlcJ",
	"Y5tCCqVclx5jVhA4OriwqP7ncdGwHVLzGPVN6S16qSHCLrqBVcHC7yBwyepgBRfXz5Ul2wj6XTEyWAtG",
	"h2aRv7kuanApABGGmucH9Ofn8sR8vxEjGAWYIVn77S6jDs59W4P0IcTodw3tJ+z3Q2Hd7sYBha+5ZpaW",
	"Bu54Okp6cKC2a50sR5Kv6/GdvTDUMZ42eOZi1/zSmq2+vjQKsuGGski/fYFheBPbnVrmTOOGuyKW2UU/",
	"gHwyCPB8CAlP6iOh0EFNQPihXjvTBjuVxiO/5sfIpZWfAc961vBGlnXUTMv4IWykZTAkBHlL7alWLO3r",
	"e0JnkJ5lKuiz/dv2hPKNA57iDuqwm6dSqWb2k8y50s6hVNCkedyZoJQxE7jDscqryzmwc1GImbVvX+Y4",
	"5TdyHWoZXS1e0zRr5xaAnCyR3RlgEkYLEoWwCaQ1XfCVsdA2geB5tLiG+kvct6LJ14VcowgMEcbIKfAQ",
	"6bpdhInlX1kxW+oBvPi1JGwxjpquirIRS94Jy5OvOMfrtszP4oraKIAwF2itF8wTf6bFjE6F7P2BHIO0",
	"n08SWKXc8AIMgigWi7uVzKIiHjcAhMCQfrb3728vL2/v/+v+xf3l5cv7y8s/339zf3n57f3l5Xf31v1l",
	"9OrV65/uLy//dP8/93+//+/7N/eXl3+5799fXv7juz//aa/3CD5kEZhbF01xNK4JnPoVe06HkpZQss1X",
	"JvHmuP3NsC702B5ohjtt2E4Hvi2Cr+WHLnW363aCjeoiNY4w2sqeuwfXAblTOxOH9OcO020p1C3fUDBm",
	"1gbUBK79G8hrKvAAC2whDyMHWsDCyFu6MVFfboo20X21pTeeKypjdJh7Eno0x6VH06DCzIxRVdvO9BOU",
	"bQPVews/0KjSAz+4E+H7HaqfJqpTFj1KOZZk9LYevVKAWkkspukR3w/uYlHZlqQ4/q3n+jweTi4th3GL",
	"Tlae6A4gGNRIXra4BYhpsFinK1SnEH+8AmwB9qV1FfprlvId3WzNqZVA3kVYE1lzDEln8jxtwKcsamtz",
	"qHOtUO9R5zauFeKjQaE+cyNHi1mfW5I8erpRS96pfwM7s+xJS17KokfbZiiGaltOp5mPtoTlIJq7aPEi",
	"CjWZ2UVZP9byInQ7WD/dDSVh0qOUVI8Hb+24IXIFsHGsi8lJ/SQBF5MT68oPLeBZAGMWn0AtNN7jdrcJ",
	"jJZelVBN0dKDTidUT1qoEiY9hlAlg7csVMDCbKRmYpX7eovy82IduQQZS1F32HkOYvTI551kGqlEtX/o",
	"YTgOXJiRk7oBVdIu9LL25cv/BQAA//8JkRw7j10CAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
